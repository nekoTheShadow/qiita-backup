{"rendered_body":"<p>元ねた: <a href=\"https://qiita.com/color_box/items/7fa900909745787ac821\" id=\"reference-6c3adc4b15f76a083e17\">「Ruby2.6のInfiniteRangeをActiveRecordで利用した時の挙動を各RDBMSに対して調査した」</a></p>\n\n<p>上記の記事では、<code>SELECT * FROM users WHERE id BETWEEN 1 and null</code>というようなSQLがどのような挙動を示すのかを4つのRDBMSで調査されており、結果としては4つのRDBMSすべてでEmpty Setとなったようです。<strong>記事を興味深く読む中で、ふと気になったのがDb2ではどのような挙動になるのかということ。</strong>そこで「Db2において、betweenに指定する2つの値のうち、片方をNULLにした場合、どのようにふるまうのか」を簡単に調査して、まとめたものが本記事になります。</p>\n\n<p>SQLの実行環境としてはIBM Db2 on Cloud (Entry Plan)を利用しました。2019/01/20現在、IBM Db2 on CloudのDb2バージョンは以下の通りになります。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre><code>SQL&gt; SELECT SERVICE_LEVEL, FIXPACK_NUM FROM SYSIBMADM.ENV_INST_INFO;\n\nSERVICE_LEVEL                                      FIXPACK_NUM\n-------------------------------------------------- -----------\nDB2 v11.1.3.3                                                3\n</code></pre></div></div>\n\n<p><strong>さてIBM Db2 on Cloudにおいて、以下のようなSQLを実行したところ、<code>SELECT * FROM users WHERE id BETWEEN 1 AND null</code>の結果セットはEmptyでした。</strong>つまり「元ネタ」の記事で検証していた4つのRDBMSと同様の挙動をDb2は示すらしいということが分かりました。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre><code>SQL&gt; CREATE TABLE users (id INTEGER, name VARCHAR(100));\n\nDB250000I: The command completed successfully.\n\nSQL&gt; INSERT INTO users VALUES (NULL, 'Alice'), (0, 'Bob'), (1, 'Charlie'), (2, 'Dave');\n\nDB250000I: The command completed successfully.\n\nSQL&gt; SELECT * FROM users;\n\n         ID NAME\n----------- --------------------------------------------------\n            Alice\n          0 Bob\n          1 Charlie\n          2 Dave\n\nSQL&gt; SELECT * FROM users WHERE id BETWEEN 1 AND NULL;\n\nNo rows were retrieved.\n\n</code></pre></div></div>\n\n<hr>\n\n<p><strong>注意: ここからは筆者の推測と憶測が中心になります。</strong> <a href=\"https://www.ibm.com/support/knowledgecenter/ja/SSEPGG_11.1.0/com.ibm.db2.luw.sql.ref.doc/doc/r0000748.html\" rel=\"nofollow noopener\" target=\"_blank\">IBM Knowledge Center「BETWEEN 述部」</a>には次のような記述があります。</p>\n\n<blockquote>\n<p>次の BETWEEN 述部は、<br>\nvalue1 BETWEEN value2 AND value3<br>\n次の検索条件と同等です。<br>\nvalue1 &gt;= value2 AND value1 &lt;= value3</p>\n</blockquote>\n\n<p>つまり<code>id BETWEEN 1 AND NULL</code>は<code>1 &lt;= id AND id &lt;= NULL</code>と同等になるわけです。ここで<a href=\"https://www.ibm.com/support/knowledgecenter/ja/SSEPGG_11.1.0/com.ibm.db2.luw.sql.ref.doc/doc/r0000746.html\" rel=\"nofollow noopener\" target=\"_blank\">IBM Knowledge Center「基本述部」</a>を確認したところ、NULLと数値を比較すると「不明」と判断されるようです。SQLは2値論理(TRUE/FALSE)ではなく、3値論理(TRUE/FALSE/UNKNOWN)を扱うというのはよく知られていますが、この「不明」というのはUNKNOWNに相当するものと思われます。</p>\n\n<blockquote>\n<p>述部のオペランドが expression として指定されている場合、両方の式のデータ・タイプは比較可能なタイプでなければなりません。 一方のオペランドの値が NULL 値の場合、述部の結果は不明です。 それ以外の場合の結果は、真または偽のいずれかになります。</p>\n</blockquote>\n\n<p><a href=\"https://www.ibm.com/support/knowledgecenter/ja/SSEPGG_11.1.0/com.ibm.db2.luw.sql.ref.doc/doc/r0000754.html\" rel=\"nofollow noopener\" target=\"_blank\">IBM Knowledge Center「検索条件」</a>には真理値表が掲載されています。その真理値表を参考として、<code>1 &lt;= id AND id &lt;= NULL</code>がどのような真理値を返すかをまとめたものが以下の表です。</p>\n\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center\">id</th>\n<th style=\"text-align: center\">name</th>\n<th style=\"text-align: center\">1 &lt;= id</th>\n<th style=\"text-align: center\">id &lt;= NULL</th>\n<th style=\"text-align: center\">1 &lt;= id AND id &lt;= NULL</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center\">NULL</td>\n<td style=\"text-align: center\">Alice</td>\n<td style=\"text-align: center\">不明</td>\n<td style=\"text-align: center\">不明</td>\n<td style=\"text-align: center\">不明</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">0</td>\n<td style=\"text-align: center\">Bob</td>\n<td style=\"text-align: center\">偽</td>\n<td style=\"text-align: center\">不明</td>\n<td style=\"text-align: center\">偽</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">1</td>\n<td style=\"text-align: center\">Charlie</td>\n<td style=\"text-align: center\">真</td>\n<td style=\"text-align: center\">不明</td>\n<td style=\"text-align: center\">不明</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">2</td>\n<td style=\"text-align: center\">Dave</td>\n<td style=\"text-align: center\">真</td>\n<td style=\"text-align: center\">不明</td>\n<td style=\"text-align: center\">不明</td>\n</tr>\n</tbody>\n</table>\n\n<p>この表からわかるのは<code>id BETWEEN 1 AND NULL</code>(=<code>1 &lt;= id AND id &lt;= NULL</code>)は「偽ないし不明」として評価されるということです。「<code>id BETWEEN 1 AND NULL</code>が真を返すことはない」と言い換えてもいいかもしれません。</p>\n\n<p>ここでWHERE節について書かれた<a href=\"https://www.ibm.com/support/knowledgecenter/ja/SSEPGG_11.1.0/com.ibm.db2.luw.sql.ref.doc/doc/r0059208.html\" rel=\"nofollow noopener\" target=\"_blank\">IBM Knowledge Center「where-clause」</a>を見ると、次のような記述が見つかるはずです。</p>\n\n<blockquote>\n<p>WHERE 節は、 search-condition (検索条件) が真である R の行で構成される中間結果表を指定します。 R は、その副選択の FROM 節の結果です。</p>\n</blockquote>\n\n<p>繰り返すように<code>id BETWEEN 1 AND NULL</code>の結果値は不明か偽のどちらかです。対してWHERE節は検索条件が真のものだけをフィルタリングしようとするため、<code>SELECT * FROM users WHERE id BETWEEN 1 AND NULL</code>というクエリの結果が0行になるのだと思われます。</p>\n\n<hr>\n\n<p>【参考1】<code>1 &lt;= id</code>, <code>id &lt;= NULL</code>, <code>1 &lt;= id AND id &lt;= NULL</code>および<code>id BETWEEN 1 AND NULL</code>およびがどのように評価されるのかについては、次のようなSQLで確認することができます。確かに<code>id BETWEEN 1 AND NULL</code>は偽もしくは不明になっていますね。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre><code>SQL&gt; SELECT id, cast(name as varchar(10)), (1 &lt;= id), (id &lt;= NULL), (1 &lt;= id AND id &lt;= NULL), (id BETWEEN 1 AND NULL) FROM users;\n\n         ID 2          3     4     5     6\n----------- ---------- ----- ----- ----- -----\n            Alice\n          0 Bob        false       false false\n          1 Charlie    true\n          2 Dave       true\n</code></pre></div></div>\n\n<p>【参考2】WHERE節の性質、すなわち「結果を返すのは検索条件がTRUEのカラムだけで、FALSEやUNKNOWNの場合は返さない」という性質は、たとえば次のようなSQLで確認することができます。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre><code>SQL&gt; SELECT * FROM users WHERE TRUE;\n\n         ID NAME\n----------- --------------------------------------------------\n            Alice\n          0 Bob\n          1 Charlie\n          2 Dave\n\nSQL&gt; SELECT * FROM users WHERE FALSE;\n\nNo rows were retrieved.\n\nSQL&gt; SELECT * FROM users WHERE NULL;\n\nNo rows were retrieved.\n</code></pre></div></div>\n\n<hr>\n\n<p>以上の挙動はDb2特有のものというよりは、DBMSに共通的なもののような気がします。ただ、自分が標準SQLやデータベース理論あるいは集合論などにまったくうといため、明言は避けます(´・ω・｀) ふだんからSQLやDBを雰囲気で使っていることがばれますね(反省) SQLやDBに詳しい人が教えてくれる--はず(´・ω・｀)</p>\n\n<p><code>BETWEEN 1 AND NULL</code>というのは極端な例ですが、概してNULL周りの挙動はトラブルのもとです。DBMSごとに挙動が変わったり、JOINする際に考えることが増えたり、あるいはインデックスの効かないSQLが出来上がったりします。そもそも現実のアプリケーション構築において、DBのカラムにNULLを持たせるような設計になっていた場合、正規化が不足していたり、ドメインの理解がおろそかになっていたりする可能性があります。仮にNULLを使うのであれば、そのカラムにおいてNULLという値が業務上どのような意味合いを持つのかをよく考え、それをプログラマやオペレータに周知徹底する必要があると思います。</p>\n","body":"元ねた: [「Ruby2.6のInfiniteRangeをActiveRecordで利用した時の挙動を各RDBMSに対して調査した」](https://qiita.com/color_box/items/7fa900909745787ac821)\n\n上記の記事では、`SELECT * FROM users WHERE id BETWEEN 1 and null`というようなSQLがどのような挙動を示すのかを4つのRDBMSで調査されており、結果としては4つのRDBMSすべてでEmpty Setとなったようです。__記事を興味深く読む中で、ふと気になったのがDb2ではどのような挙動になるのかということ。__そこで「Db2において、betweenに指定する2つの値のうち、片方をNULLにした場合、どのようにふるまうのか」を簡単に調査して、まとめたものが本記事になります。\n\nSQLの実行環境としてはIBM Db2 on Cloud (Entry Plan)を利用しました。2019/01/20現在、IBM Db2 on CloudのDb2バージョンは以下の通りになります。\n\n```\nSQL> SELECT SERVICE_LEVEL, FIXPACK_NUM FROM SYSIBMADM.ENV_INST_INFO;\n\nSERVICE_LEVEL                                      FIXPACK_NUM\n-------------------------------------------------- -----------\nDB2 v11.1.3.3                                                3\n```\n\n__さてIBM Db2 on Cloudにおいて、以下のようなSQLを実行したところ、`SELECT * FROM users WHERE id BETWEEN 1 AND null`の結果セットはEmptyでした。__つまり「元ネタ」の記事で検証していた4つのRDBMSと同様の挙動をDb2は示すらしいということが分かりました。\n\n```\nSQL> CREATE TABLE users (id INTEGER, name VARCHAR(100));\n\nDB250000I: The command completed successfully.\n\nSQL> INSERT INTO users VALUES (NULL, 'Alice'), (0, 'Bob'), (1, 'Charlie'), (2, 'Dave');\n\nDB250000I: The command completed successfully.\n\nSQL> SELECT * FROM users;\n\n         ID NAME\n----------- --------------------------------------------------\n            Alice\n          0 Bob\n          1 Charlie\n          2 Dave\n\nSQL> SELECT * FROM users WHERE id BETWEEN 1 AND NULL;\n\nNo rows were retrieved.\n\n```\n\n---\n\n__注意: ここからは筆者の推測と憶測が中心になります。__ [IBM Knowledge Center「BETWEEN 述部」](https://www.ibm.com/support/knowledgecenter/ja/SSEPGG_11.1.0/com.ibm.db2.luw.sql.ref.doc/doc/r0000748.html)には次のような記述があります。\n\n> 次の BETWEEN 述部は、\nvalue1 BETWEEN value2 AND value3\n次の検索条件と同等です。\nvalue1 >= value2 AND value1 <= value3\n\nつまり`id BETWEEN 1 AND NULL`は`1 <= id AND id <= NULL`と同等になるわけです。ここで[IBM Knowledge Center「基本述部」](https://www.ibm.com/support/knowledgecenter/ja/SSEPGG_11.1.0/com.ibm.db2.luw.sql.ref.doc/doc/r0000746.html)を確認したところ、NULLと数値を比較すると「不明」と判断されるようです。SQLは2値論理(TRUE/FALSE)ではなく、3値論理(TRUE/FALSE/UNKNOWN)を扱うというのはよく知られていますが、この「不明」というのはUNKNOWNに相当するものと思われます。\n\n> 述部のオペランドが expression として指定されている場合、両方の式のデータ・タイプは比較可能なタイプでなければなりません。 一方のオペランドの値が NULL 値の場合、述部の結果は不明です。 それ以外の場合の結果は、真または偽のいずれかになります。\n\n[IBM Knowledge Center「検索条件」](https://www.ibm.com/support/knowledgecenter/ja/SSEPGG_11.1.0/com.ibm.db2.luw.sql.ref.doc/doc/r0000754.html)には真理値表が掲載されています。その真理値表を参考として、`1 <= id AND id <= NULL`がどのような真理値を返すかをまとめたものが以下の表です。\n\n|id|name|1 <= id|id <= NULL|1 <= id AND id <= NULL|\n|:-:|:-:|:-:|:-:|:-:|\n|NULL|Alice|不明|不明|不明|\n|0|Bob|偽|不明|偽|\n|1|Charlie|真|不明|不明|\n|2|Dave|真|不明|不明|\n\nこの表からわかるのは`id BETWEEN 1 AND NULL`(=`1 <= id AND id <= NULL`)は「偽ないし不明」として評価されるということです。「`id BETWEEN 1 AND NULL`が真を返すことはない」と言い換えてもいいかもしれません。\n\nここでWHERE節について書かれた[IBM Knowledge Center「where-clause」](https://www.ibm.com/support/knowledgecenter/ja/SSEPGG_11.1.0/com.ibm.db2.luw.sql.ref.doc/doc/r0059208.html)を見ると、次のような記述が見つかるはずです。\n\n> WHERE 節は、 search-condition (検索条件) が真である R の行で構成される中間結果表を指定します。 R は、その副選択の FROM 節の結果です。\n\n繰り返すように`id BETWEEN 1 AND NULL`の結果値は不明か偽のどちらかです。対してWHERE節は検索条件が真のものだけをフィルタリングしようとするため、`SELECT * FROM users WHERE id BETWEEN 1 AND NULL`というクエリの結果が0行になるのだと思われます。\n\n---\n\n【参考1】`1 <= id`, `id <= NULL`, `1 <= id AND id <= NULL`および`id BETWEEN 1 AND NULL`およびがどのように評価されるのかについては、次のようなSQLで確認することができます。確かに`id BETWEEN 1 AND NULL`は偽もしくは不明になっていますね。\n\n```\nSQL> SELECT id, cast(name as varchar(10)), (1 <= id), (id <= NULL), (1 <= id AND id <= NULL), (id BETWEEN 1 AND NULL) FROM users;\n\n         ID 2          3     4     5     6\n----------- ---------- ----- ----- ----- -----\n            Alice\n          0 Bob        false       false false\n          1 Charlie    true\n          2 Dave       true\n```\n\n【参考2】WHERE節の性質、すなわち「結果を返すのは検索条件がTRUEのカラムだけで、FALSEやUNKNOWNの場合は返さない」という性質は、たとえば次のようなSQLで確認することができます。\n\n\n```\nSQL> SELECT * FROM users WHERE TRUE;\n\n         ID NAME\n----------- --------------------------------------------------\n            Alice\n          0 Bob\n          1 Charlie\n          2 Dave\n\nSQL> SELECT * FROM users WHERE FALSE;\n\nNo rows were retrieved.\n\nSQL> SELECT * FROM users WHERE NULL;\n\nNo rows were retrieved.\n```\n---\n\n以上の挙動はDb2特有のものというよりは、DBMSに共通的なもののような気がします。ただ、自分が標準SQLやデータベース理論あるいは集合論などにまったくうといため、明言は避けます(´・ω・｀) ふだんからSQLやDBを雰囲気で使っていることがばれますね(反省) SQLやDBに詳しい人が教えてくれる--はず(´・ω・｀)\n\n`BETWEEN 1 AND NULL`というのは極端な例ですが、概してNULL周りの挙動はトラブルのもとです。DBMSごとに挙動が変わったり、JOINする際に考えることが増えたり、あるいはインデックスの効かないSQLが出来上がったりします。そもそも現実のアプリケーション構築において、DBのカラムにNULLを持たせるような設計になっていた場合、正規化が不足していたり、ドメインの理解がおろそかになっていたりする可能性があります。仮にNULLを使うのであれば、そのカラムにおいてNULLという値が業務上どのような意味合いを持つのかをよく考え、それをプログラマやオペレータに周知徹底する必要があると思います。\n\n","coediting":false,"comments_count":1,"created_at":"2019-01-21T00:53:26+09:00","group":null,"id":"b9406e69333543358819","likes_count":4,"private":false,"reactions_count":0,"stocks_count":1,"tags":[{"name":"db2","versions":[]}],"title":"BETWEEN 1 AND NULLとしたときの挙動について","updated_at":"2019-01-21T01:19:24+09:00","url":"https://qiita.com/neko_the_shadow/items/b9406e69333543358819","user":{"description":"IT業界の片隅でひっそり生きるシステムエンジニアです(´・ω・｀)","facebook_id":"","followees_count":0,"followers_count":36,"github_login_name":null,"id":"neko_the_shadow","items_count":204,"linkedin_id":"","location":"神奈川県川崎市","name":"","organization":"","permanent_id":105859,"profile_image_url":"https://qiita-image-store.s3.amazonaws.com/0/105859/profile-images/1473709753","team_only":false,"twitter_screen_name":"neko_the_shadow","website_url":"https://nekotheshadow.github.io/"},"page_views_count":8060,"team_membership":null}