{"rendered_body":"<p>Python3には<code>bisect</code>というモジュールがあり、この中には<code>bisect_left</code>、<code>bisect_right</code>という関数が用意されています。<code>bisect_left</code>はソート済みの配列を二分探索により探索し、挿入点のうちもっとも左側のものを戻り値とします。<code>bisect_right</code>はその逆で、挿入点のうち、もっとも右側が戻り値となります。</p>\n\n<div class=\"code-frame\" data-lang=\"python\"><div class=\"highlight\"><pre><code><span class=\"kn\">import</span> <span class=\"nn\">bisect</span>\n\n<span class=\"n\">digits</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">111</span><span class=\"p\">,</span> <span class=\"mi\">222</span><span class=\"p\">,</span> <span class=\"mi\">333</span><span class=\"p\">,</span> <span class=\"mi\">333</span><span class=\"p\">,</span> <span class=\"mi\">333</span><span class=\"p\">,</span> <span class=\"mi\">444</span><span class=\"p\">,</span> <span class=\"mi\">555</span><span class=\"p\">]</span>\n<span class=\"n\">bisect</span><span class=\"p\">.</span><span class=\"n\">bisect_left</span><span class=\"p\">(</span><span class=\"n\">digits</span><span class=\"p\">,</span> <span class=\"mi\">333</span><span class=\"p\">)</span>  <span class=\"c1\">#=&gt; 2\n</span><span class=\"n\">bisect</span><span class=\"p\">.</span><span class=\"n\">bisect_right</span><span class=\"p\">(</span><span class=\"n\">digits</span><span class=\"p\">,</span> <span class=\"mi\">333</span><span class=\"p\">)</span> <span class=\"c1\">#=&gt; 5\n</span></code></pre></div></div>\n\n<p>Go言語で<code>bisect_left</code>や<code>bisect_right</code>と同じようなことをしたい場合、すなわち、<strong>二分探索でもっとも左側の挿入点を探したい、もっとも右側の挿入点を探したい</strong>場合、<code>sort</code>パッケージの<code>Search</code>を利用し、それぞれ次のように実装します。</p>\n\n<div class=\"code-frame\" data-lang=\"go\"><div class=\"highlight\"><pre><code><span class=\"n\">digits</span> <span class=\"o\">:=</span> <span class=\"p\">[]</span><span class=\"kt\">int</span><span class=\"p\">{</span><span class=\"m\">111</span><span class=\"p\">,</span> <span class=\"m\">222</span><span class=\"p\">,</span> <span class=\"m\">333</span><span class=\"p\">,</span> <span class=\"m\">333</span><span class=\"p\">,</span> <span class=\"m\">333</span><span class=\"p\">,</span> <span class=\"m\">444</span><span class=\"p\">,</span> <span class=\"m\">555</span><span class=\"p\">}</span>\n<span class=\"n\">sort</span><span class=\"o\">.</span><span class=\"n\">Search</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">digits</span><span class=\"p\">),</span> <span class=\"k\">func</span><span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"kt\">bool</span> <span class=\"p\">{</span> <span class=\"k\">return</span> <span class=\"n\">digits</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">&gt;=</span> <span class=\"m\">333</span> <span class=\"p\">})</span> <span class=\"c\">//=&gt; 2</span>\n<span class=\"n\">sort</span><span class=\"o\">.</span><span class=\"n\">Search</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">digits</span><span class=\"p\">),</span> <span class=\"k\">func</span><span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"kt\">bool</span> <span class=\"p\">{</span> <span class=\"k\">return</span> <span class=\"n\">digits</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">&gt;</span> <span class=\"m\">333</span> <span class=\"p\">})</span>  <span class=\"c\">//=&gt; 5</span>\n</code></pre></div></div>\n\n<p>つまり<code>bisect_left</code>の場合は等号付き不等号で比較、<code>bisect_right</code>の場合は不等号で比較すればよいわけです。</p>\n","body":"Python3には`bisect`というモジュールがあり、この中には`bisect_left`、`bisect_right`という関数が用意されています。`bisect_left`はソート済みの配列を二分探索により探索し、挿入点のうちもっとも左側のものを戻り値とします。`bisect_right`はその逆で、挿入点のうち、もっとも右側が戻り値となります。\n\n```python\nimport bisect\n\ndigits = [111, 222, 333, 333, 333, 444, 555]\nbisect.bisect_left(digits, 333)  #=> 2\nbisect.bisect_right(digits, 333) #=> 5\n```\n\nGo言語で`bisect_left`や`bisect_right`と同じようなことをしたい場合、すなわち、__二分探索でもっとも左側の挿入点を探したい、もっとも右側の挿入点を探したい__場合、`sort`パッケージの`Search`を利用し、それぞれ次のように実装します。\n\n```go\ndigits := []int{111, 222, 333, 333, 333, 444, 555}\nsort.Search(len(digits), func(i int) bool { return digits[i] >= 333 }) //=> 2\nsort.Search(len(digits), func(i int) bool { return digits[i] > 333 })  //=> 5\n```\n\nつまり`bisect_left`の場合は等号付き不等号で比較、`bisect_right`の場合は不等号で比較すればよいわけです。\n","coediting":false,"comments_count":0,"created_at":"2020-02-09T23:24:11+09:00","group":null,"id":"6a722857995e35b06fa1","likes_count":0,"private":false,"reactions_count":0,"stocks_count":0,"tags":[{"name":"Go","versions":[]}],"title":"Pythonのbisect_leftとbisect_rightをGo言語でも使いたい","updated_at":"2020-08-15T12:44:35+09:00","url":"https://qiita.com/neko_the_shadow/items/6a722857995e35b06fa1","user":{"description":"IT業界の片隅でひっそり生きるシステムエンジニアです(´・ω・｀)","facebook_id":"","followees_count":0,"followers_count":37,"github_login_name":"nekoTheShadow","id":"neko_the_shadow","items_count":218,"linkedin_id":"","location":"神奈川県川崎市","name":"","organization":"","permanent_id":105859,"profile_image_url":"https://qiita-image-store.s3.amazonaws.com/0/105859/profile-images/1473709753","team_only":false,"twitter_screen_name":"neko_the_shadow","website_url":"https://github.com/nekoTheShadow"},"page_views_count":1259,"team_membership":null,"organization_url_name":null,"slide":false}