{"rendered_body":"<p>データの挿入や更新を行う際蓄積されたデータとの比較をしたい、あるいはデータの整合性を確保するためにほかのデータとの関係性を見たいということがあると思います。<strong>こういうときはcheck制約においてサブクエリを利用したくなるのですが――結論から述べると、少なくともPostgreSQLではできませんでした。</strong>標準SQLでは「check制約でサブクエリを発行する」ことが認められているので、近い将来サポートされるとは思いますが……。それはさておき、上記のような要件を達成するためいろいろと試行錯誤した結果、<strong>ストアドファンクションを利用してサブクエリを発行した風に見せかける</strong>のが手っ取り早そうという結論に至りました。</p>\n\n<p>たとえばホテルの部屋の予約状況を示すテーブルbookingがあり、要素として部屋番号、予約開始日、予約終了日を持っているとします。「ある部屋がいつからいつまで予約されているのか」を記録しているというイメージです。<strong>さてホテルですからダブルブッキングは避けねばなりません。ただしある予約の開始日と別の予約の終了日が同一になることは許したい。</strong>これをcheck制約で実現しようとすると、サブクエリを発行する必要がありますが、上述したようにそれは難しいので、ストアドファンクションを利用したいと思います。</p>\n\n<div class=\"code-frame\" data-lang=\"sql\"><div class=\"highlight\"><pre><span class=\"c1\">-- bookingテーブルを定義する。</span>\n<span class=\"k\">create</span> <span class=\"k\">table</span> <span class=\"n\">booking</span> <span class=\"p\">(</span>\n    <span class=\"n\">booking_id</span> <span class=\"nb\">integer</span> <span class=\"k\">primary</span> <span class=\"k\">key</span><span class=\"p\">,</span>\n    <span class=\"n\">room_id</span>    <span class=\"nb\">integer</span> <span class=\"k\">not</span> <span class=\"k\">null</span><span class=\"p\">,</span>\n    <span class=\"n\">start_day</span>  <span class=\"nb\">date</span>    <span class=\"k\">not</span> <span class=\"k\">null</span><span class=\"p\">,</span>\n    <span class=\"n\">end_day</span>    <span class=\"nb\">date</span>    <span class=\"k\">not</span> <span class=\"k\">null</span><span class=\"p\">,</span>\n\n    <span class=\"c1\">-- 開始日は終了日より先で、開始日と終了日は同一であってはならない。</span>\n    <span class=\"k\">constraint</span> <span class=\"n\">invalid_period</span> <span class=\"k\">check</span> <span class=\"p\">(</span><span class=\"n\">start_day</span> <span class=\"o\">&lt;</span> <span class=\"n\">end_day</span><span class=\"p\">)</span>\n<span class=\"p\">);</span>\n\n<span class=\"c1\">-- ダブルブッキングを数える関数。更新したい予約の部屋番号、開始日、終了日を指定する。</span>\n<span class=\"c1\">-- ただしある予約の開始日と別の予約の終了日が重なってもダブルブッキングとして数えない。</span>\n<span class=\"k\">create</span> <span class=\"k\">function</span> <span class=\"n\">count_double_booking</span><span class=\"p\">(</span><span class=\"nb\">integer</span><span class=\"p\">,</span> <span class=\"nb\">date</span><span class=\"p\">,</span> <span class=\"nb\">date</span><span class=\"p\">)</span> <span class=\"k\">returns</span> <span class=\"nb\">bigint</span> <span class=\"k\">as</span> <span class=\"err\">$$</span>\n    <span class=\"k\">select</span> <span class=\"k\">count</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"p\">)</span>\n    <span class=\"k\">from</span> <span class=\"n\">booking</span>\n    <span class=\"k\">where</span> <span class=\"n\">booking</span><span class=\"p\">.</span><span class=\"n\">room_id</span> <span class=\"o\">=</span> <span class=\"err\">$</span><span class=\"mi\">1</span>\n    <span class=\"k\">and</span> <span class=\"n\">daterange</span><span class=\"p\">(</span><span class=\"err\">$</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"err\">$</span><span class=\"mi\">3</span><span class=\"p\">)</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">daterange</span><span class=\"p\">(</span><span class=\"n\">start_day</span><span class=\"p\">,</span> <span class=\"n\">end_day</span><span class=\"p\">)</span>\n<span class=\"err\">$$</span> <span class=\"k\">language</span> <span class=\"k\">SQL</span><span class=\"p\">;</span> \n\n<span class=\"c1\">-- check制約を設けて、ダブルブッキングを禁じる。</span>\n<span class=\"k\">alter</span> <span class=\"k\">table</span> <span class=\"n\">booking</span> \n<span class=\"k\">add</span> <span class=\"k\">constraint</span> <span class=\"n\">double_booking</span> \n<span class=\"k\">check</span> <span class=\"p\">(</span><span class=\"n\">count_double_booking</span><span class=\"p\">(</span><span class=\"n\">room_id</span><span class=\"p\">,</span> <span class=\"n\">start_day</span><span class=\"p\">,</span> <span class=\"n\">end_day</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n\n<span class=\"c1\">-- 正常に挿入できるデータ。</span>\n<span class=\"k\">insert</span> <span class=\"k\">into</span> <span class=\"n\">booking</span> <span class=\"k\">values</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s1\">'2016-01-01'</span><span class=\"p\">,</span> <span class=\"s1\">'2016-01-04'</span><span class=\"p\">);</span>\n<span class=\"k\">insert</span> <span class=\"k\">into</span> <span class=\"n\">booking</span> <span class=\"k\">values</span> <span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s1\">'2016-01-04'</span><span class=\"p\">,</span> <span class=\"s1\">'2016-01-05'</span><span class=\"p\">);</span>\n<span class=\"k\">insert</span> <span class=\"k\">into</span> <span class=\"n\">booking</span> <span class=\"k\">values</span> <span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"s1\">'2016-01-01'</span><span class=\"p\">,</span> <span class=\"s1\">'2016-01-05'</span><span class=\"p\">);</span>\n<span class=\"k\">insert</span> <span class=\"k\">into</span> <span class=\"n\">booking</span> <span class=\"k\">values</span> <span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"s1\">'2016-01-01'</span><span class=\"p\">,</span> <span class=\"s1\">'2016-01-06'</span><span class=\"p\">);</span>\n\n<span class=\"c1\">-- ダブルブッキングが生じるため挿入と更新に失敗する。</span>\n<span class=\"k\">insert</span> <span class=\"k\">into</span> <span class=\"n\">booking</span> <span class=\"k\">values</span> <span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s1\">'2016-01-02'</span><span class=\"p\">,</span> <span class=\"s1\">'2016-01-03'</span><span class=\"p\">);</span>\n<span class=\"k\">update</span> <span class=\"n\">booking</span> <span class=\"k\">set</span> <span class=\"n\">end_day</span> <span class=\"o\">=</span> <span class=\"s1\">'2016-01-05'</span> <span class=\"k\">where</span> <span class=\"n\">booking_id</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n\n<span class=\"cm\">/*\nERROR:  リレーション\"booking\"の新しい行は検査制約\"double_booking\"に違反しています\nDETAIL:  失敗した行は(5, 1, 2016-01-02, 2016-01-03)を含みます\n\nERROR:  リレーション\"booking\"の新しい行は検査制約\"double_booking\"に違反しています\nDETAIL:  失敗した行は(1, 1, 2016-01-01, 2016-01-05)を含みます\n*/</span>\n</pre></div></div>\n\n<p>余談: PostgreSQLの範囲型を初めて利用したのですが、便利ですね。「期間」「区間」を扱うのが楽になりそうです。</p>\n","body":"\nデータの挿入や更新を行う際蓄積されたデータとの比較をしたい、あるいはデータの整合性を確保するためにほかのデータとの関係性を見たいということがあると思います。__こういうときはcheck制約においてサブクエリを利用したくなるのですが――結論から述べると、少なくともPostgreSQLではできませんでした。__標準SQLでは「check制約でサブクエリを発行する」ことが認められているので、近い将来サポートされるとは思いますが……。それはさておき、上記のような要件を達成するためいろいろと試行錯誤した結果、__ストアドファンクションを利用してサブクエリを発行した風に見せかける__のが手っ取り早そうという結論に至りました。\n\nたとえばホテルの部屋の予約状況を示すテーブルbookingがあり、要素として部屋番号、予約開始日、予約終了日を持っているとします。「ある部屋がいつからいつまで予約されているのか」を記録しているというイメージです。__さてホテルですからダブルブッキングは避けねばなりません。ただしある予約の開始日と別の予約の終了日が同一になることは許したい。__これをcheck制約で実現しようとすると、サブクエリを発行する必要がありますが、上述したようにそれは難しいので、ストアドファンクションを利用したいと思います。\n\n```sql\n-- bookingテーブルを定義する。\ncreate table booking (\n    booking_id integer primary key,\n    room_id    integer not null,\n    start_day  date    not null,\n    end_day    date    not null,\n\n    -- 開始日は終了日より先で、開始日と終了日は同一であってはならない。\n    constraint invalid_period check (start_day < end_day)\n);\n\n-- ダブルブッキングを数える関数。更新したい予約の部屋番号、開始日、終了日を指定する。\n-- ただしある予約の開始日と別の予約の終了日が重なってもダブルブッキングとして数えない。\ncreate function count_double_booking(integer, date, date) returns bigint as $$\n    select count(*)\n    from booking\n    where booking.room_id = $1\n    and daterange($2, $3) && daterange(start_day, end_day)\n$$ language SQL; \n\n-- check制約を設けて、ダブルブッキングを禁じる。\nalter table booking \nadd constraint double_booking \ncheck (count_double_booking(room_id, start_day, end_day) = 0);\n\n-- 正常に挿入できるデータ。\ninsert into booking values (1, 1, '2016-01-01', '2016-01-04');\ninsert into booking values (2, 1, '2016-01-04', '2016-01-05');\ninsert into booking values (3, 2, '2016-01-01', '2016-01-05');\ninsert into booking values (4, 3, '2016-01-01', '2016-01-06');\n\n-- ダブルブッキングが生じるため挿入と更新に失敗する。\ninsert into booking values (5, 1, '2016-01-02', '2016-01-03');\nupdate booking set end_day = '2016-01-05' where booking_id = 1;\n\n/*\nERROR:  リレーション\"booking\"の新しい行は検査制約\"double_booking\"に違反しています\nDETAIL:  失敗した行は(5, 1, 2016-01-02, 2016-01-03)を含みます\n\nERROR:  リレーション\"booking\"の新しい行は検査制約\"double_booking\"に違反しています\nDETAIL:  失敗した行は(1, 1, 2016-01-01, 2016-01-05)を含みます\n*/\n```\n余談: PostgreSQLの範囲型を初めて利用したのですが、便利ですね。「期間」「区間」を扱うのが楽になりそうです。\n","coediting":false,"comments_count":0,"created_at":"2017-01-31T01:02:54+09:00","group":null,"id":"35dcb9285d70f35f60e4","likes_count":2,"private":false,"reactions_count":0,"tags":[{"name":"SQL","versions":[]},{"name":"PostgreSQL","versions":[]}],"title":"ストアドファンクションを利用してcheck制約でサブクエリを発行する","updated_at":"2017-01-31T01:02:54+09:00","url":"https://qiita.com/neko_the_shadow/items/35dcb9285d70f35f60e4","user":{"description":"IT業界の片隅でひっそり生きるシステムエンジニアです(´・ω・｀)","facebook_id":"","followees_count":0,"followers_count":35,"github_login_name":null,"id":"neko_the_shadow","items_count":178,"linkedin_id":"","location":"神奈川県川崎市","name":"","organization":"","permanent_id":105859,"profile_image_url":"https://qiita-image-store.s3.amazonaws.com/0/105859/profile-images/1473709753","team_only":false,"twitter_screen_name":"neko_the_shadow","website_url":"https://nekotheshadow.github.io/"},"page_views_count":null}