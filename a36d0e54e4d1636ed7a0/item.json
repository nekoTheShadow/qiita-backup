{"rendered_body":"<p>Java11にはさまざまなソートAPIが用意されていますが、ソートアルゴリズムとして、プリミティブ型のソートにはDual Pivot Quick Sortが、参照型のソートにはTimsortがそれぞれ採用されています (以下は<code>java.util.Arrays</code>より抜粋したもの)</p>\n\n<div class=\"code-frame\" data-lang=\"java\">\n<div class=\"code-lang\"><span class=\"bold\">Arrays.java</span></div>\n<div class=\"highlight\"><pre><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Arrays</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">sort</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"nc\">DualPivotQuicksort</span><span class=\"o\">.</span><span class=\"na\">sort</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"kc\">null</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">sort</span><span class=\"o\">(</span><span class=\"nc\">Object</span><span class=\"o\">[]</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"nc\">LegacyMergeSort</span><span class=\"o\">.</span><span class=\"na\">userRequested</span><span class=\"o\">)</span>\n            <span class=\"n\">legacyMergeSort</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">);</span>\n        <span class=\"k\">else</span>\n            <span class=\"nc\">ComparableTimSort</span><span class=\"o\">.</span><span class=\"na\">sort</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">,</span> <span class=\"kc\">null</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n</div>\n\n<p>詳細は<a href=\"https://en.wikipedia.org/wiki/Timsort\" rel=\"nofollow noopener\" target=\"_blank\">英語版Wikipedia</a>や<a href=\"https://dic.nicovideo.jp/a/%E3%83%86%E3%82%A3%E3%83%A0%E3%82%BD%E3%83%BC%E3%83%88\" rel=\"nofollow noopener\" target=\"_blank\">ニコニコ大百科</a>の記事などを見てほしいのですが、Timsortはざっくりいってしまうとマージソートの改良版みたいなもので、平均計算時間・最悪計算時間ともに$O(nlog{n})$です。一方、Dual Pivot Quick Sortは改良版とはいえもともとはクイックソートなので、平均計算時間はTimsortと同じ$O(nlog{n})$ですが、最悪計算時間は$O(n^2)$になります。<strong>つまり、Java11でプリミティブ型のソートを行う場合は$O(n^2)$になる可能性があることに注意する必要があるということです。</strong></p>\n\n<p>実をいうと、プリミティブ型のソートの最悪計算時間が$O(n^2)$だということはJavaDocにもきっちり書かれていることで、たとえば以下は<code>Arrays.sort</code>からの抜粋になります。</p>\n\n<blockquote>\n<p>Implementation note: The sorting algorithm is a Dual-Pivot Quicksortby Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithmoffers O(n log(n)) performance on many data sets that cause otherquicksorts to degrade to quadratic performance, and is typicallyfaster than traditional (one-pivot) Quicksort implementations.</p>\n</blockquote>\n\n<p>要は知らなかったではすまされないということですね…</p>\n\n<p>プリミティブ型のソートの計算時間が$O(n^2)$になるのは天文学的な確率というか、現実的にはJavaを意図的に攻撃するような場合にしか起きないのですが、例えばCodeforcesにはHackという、他人のソースコードが正解できないようなテストケースを考えて提出できる仕組みがあり、このHackでは狙われる場合があります。Codeforcesユーザの中ではこれをAnti Quick SortとかQuick Sort Killerとかいうそうで、そういうテストケースのジェネレータを公開している人もいます: <a href=\"https://codeforces.com/blog/entry/4827\" class=\"autolink\" rel=\"nofollow noopener\" target=\"_blank\">https://codeforces.com/blog/entry/4827</a></p>\n\n<p>現実のアプリケーションを作っている現場では、俗に「いじわるテスト」などと称して、ある種のストレステストを行うことがありますが、このときにAnti Quick Sort / Quick Sort Killerを試してみても良いかもしれません。</p>\n","body":"Java11にはさまざまなソートAPIが用意されていますが、ソートアルゴリズムとして、プリミティブ型のソートにはDual Pivot Quick Sortが、参照型のソートにはTimsortがそれぞれ採用されています (以下は`java.util.Arrays`より抜粋したもの)\n\n```java:Arrays.java\npublic class Arrays {\n    public static void sort(int[] a) {\n        DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);\n    }\n    \n    public static void sort(Object[] a) {\n        if (LegacyMergeSort.userRequested)\n            legacyMergeSort(a);\n        else\n            ComparableTimSort.sort(a, 0, a.length, null, 0, 0);\n    }\n}\n```\n\n詳細は[英語版Wikipedia](https://en.wikipedia.org/wiki/Timsort)や[ニコニコ大百科](https://dic.nicovideo.jp/a/%E3%83%86%E3%82%A3%E3%83%A0%E3%82%BD%E3%83%BC%E3%83%88)の記事などを見てほしいのですが、Timsortはざっくりいってしまうとマージソートの改良版みたいなもので、平均計算時間・最悪計算時間ともに$O(nlog{n})$です。一方、Dual Pivot Quick Sortは改良版とはいえもともとはクイックソートなので、平均計算時間はTimsortと同じ$O(nlog{n})$ですが、最悪計算時間は$O(n^2)$になります。**つまり、Java11でプリミティブ型のソートを行う場合は$O(n^2)$になる可能性があることに注意する必要があるということです。**\n\n実をいうと、プリミティブ型のソートの最悪計算時間が$O(n^2)$だということはJavaDocにもきっちり書かれていることで、たとえば以下は`Arrays.sort`からの抜粋になります。\n\n> Implementation note: The sorting algorithm is a Dual-Pivot Quicksortby Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithmoffers O(n log(n)) performance on many data sets that cause otherquicksorts to degrade to quadratic performance, and is typicallyfaster than traditional (one-pivot) Quicksort implementations.\n\n要は知らなかったではすまされないということですね…\n\nプリミティブ型のソートの計算時間が$O(n^2)$になるのは天文学的な確率というか、現実的にはJavaを意図的に攻撃するような場合にしか起きないのですが、例えばCodeforcesにはHackという、他人のソースコードが正解できないようなテストケースを考えて提出できる仕組みがあり、このHackでは狙われる場合があります。Codeforcesユーザの中ではこれをAnti Quick SortとかQuick Sort Killerとかいうそうで、そういうテストケースのジェネレータを公開している人もいます: https://codeforces.com/blog/entry/4827\n\n現実のアプリケーションを作っている現場では、俗に「いじわるテスト」などと称して、ある種のストレステストを行うことがありますが、このときにAnti Quick Sort / Quick Sort Killerを試してみても良いかもしれません。\n","coediting":false,"comments_count":0,"created_at":"2020-12-05T13:32:18+09:00","group":null,"id":"a36d0e54e4d1636ed7a0","likes_count":1,"private":false,"reactions_count":0,"tags":[{"name":"Java","versions":[]}],"title":"プリミティブ型のソートでは最悪計算時間に注意する","updated_at":"2020-12-05T21:55:35+09:00","url":"https://qiita.com/neko_the_shadow/items/a36d0e54e4d1636ed7a0","user":{"description":"IT業界の片隅でひっそり生きるシステムエンジニアです(´・ω・｀)","facebook_id":"","followees_count":0,"followers_count":36,"github_login_name":null,"id":"neko_the_shadow","items_count":197,"linkedin_id":"","location":"神奈川県川崎市","name":"","organization":"","permanent_id":105859,"profile_image_url":"https://qiita-image-store.s3.amazonaws.com/0/105859/profile-images/1473709753","team_only":false,"twitter_screen_name":"neko_the_shadow","website_url":"https://nekotheshadow.github.io/"},"page_views_count":null,"team_membership":null}