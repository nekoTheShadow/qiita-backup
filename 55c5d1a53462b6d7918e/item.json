{"rendered_body":"\n<h1>\n<span id=\"事象\" class=\"fragment\"></span><a href=\"#%E4%BA%8B%E8%B1%A1\"><i class=\"fa fa-link\"></i></a>事象</h1>\n\n<p>文字列定数(<code>public static final String</code>)ばかりが定義されたクラス<code>Const.java</code>と、その定数を利用する<code>Main.java</code>があるとします。</p>\n\n<div class=\"code-frame\" data-lang=\"java\">\n<div class=\"code-lang\"><span class=\"bold\">Const.java</span></div>\n<div class=\"highlight\"><pre><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Const</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"nc\">String</span> <span class=\"no\">VALUE</span> <span class=\"o\">=</span> <span class=\"s\">\"BEFORE\"</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n</pre></div>\n</div>\n\n<div class=\"code-frame\" data-lang=\"java\">\n<div class=\"code-lang\"><span class=\"bold\">Main.java</span></div>\n<div class=\"highlight\"><pre><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Main</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"nc\">Const</span><span class=\"o\">.</span><span class=\"na\">VALUE</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre></div>\n</div>\n\n<p>このふたつのjavaファイルをコンパイルし、実行すると、文字列定数<code>Const.VALUE</code>の値<code>BEFORE</code>が出力されます。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>C:\\qiita&gt; javac Const.java Main.java\n\nC:\\qiita&gt; java Main\n</pre></div></div>\n\n<p>ここで、文字列定数<code>Const.VALUE</code>の値が変更になったとします。</p>\n\n<div class=\"code-frame\" data-lang=\"java\">\n<div class=\"code-lang\"><span class=\"bold\">Const.java</span></div>\n<div class=\"highlight\"><pre><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Const</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"nc\">String</span> <span class=\"no\">VALUE</span> <span class=\"o\">=</span> <span class=\"s\">\"AFTER\"</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n</pre></div>\n</div>\n\n<p><code>Const.java</code>を編集後、<code>Const.java</code>だけを再コンパイルし、ふたたび<code>Main</code>を実行したところ、画面には<code>Const.VALUE</code>の現在の値である<code>AFTER</code>ではなく、<code>BEFORE</code>が表示されました。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>C:\\qiita&gt; del Const.class\n\nC:\\qiita&gt; javac Const.java\n\nC:\\qiita&gt; java Main\nBEFORE\n</pre></div></div>\n\n<h1>\n<span id=\"調査\" class=\"fragment\"></span><a href=\"#%E8%AA%BF%E6%9F%BB\"><i class=\"fa fa-link\"></i></a>調査</h1>\n\n<p><code>javap</code>コマンドで<code>Main.class</code>を逆アセンブルすると、<code>Main.class</code>には<code>BEFORE</code>という値が埋め込まれていることがわかります。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>C:\\qiita&gt; javap -c Main.class\nCompiled from \"Main.java\"\npublic class Main {\n  public Main();\n    Code:\n       0: aload_0\n       1: invokespecial #1                  // Method java/lang/Object.\"&lt;init&gt;\":()V\n       4: return\n\n  public static void main(java.lang.String[]);\n    Code:\n       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;\n       3: ldc           #4                  // String BEFORE\n       5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n       8: return\n}\n</pre></div></div>\n\n<p>コンパイラはコンパイル時に<code>Main.java</code>内の<code>Const.VALUE</code>を<code>BEFORE</code>という値に置き換えています。<code>Main.class</code>は<code>Const.class</code>をすでに参照していないため、<code>Const.VALUE</code>の値が変わっても、その変更が<code>Main.class</code>にまで伝播しませんでした。</p>\n\n<p>ちなみに<code>Main.class</code>は<code>Const.class</code>を参照していないため、<code>Const.class</code>を削除してしまっても、<code>Main.class</code>は正常に動作します。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>C:\\qiita&gt; del Const.class\n\nC:\\qiita&gt; java Main\nBEFORE\n</pre></div></div>\n\n<h1>\n<span id=\"原因\" class=\"fragment\"></span><a href=\"#%E5%8E%9F%E5%9B%A0\"><i class=\"fa fa-link\"></i></a>原因</h1>\n\n<p>なぜ文字列定数が埋め込まれてしまったのかというと、これはJavaの仕様に起因します。<a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-13.html#jls-13.1\" rel=\"nofollow noopener\" target=\"_blank\">\"Java Language Specs - 13.1. The Form of a Binary\"</a> には次の通り記述されています。</p>\n\n<blockquote>\n<p>A reference to a field that is a constant variable (§4.12.4) must be resolved at compile time to the value V denoted by the constant variable's initializer.<br>\nIf such a field is static, then no reference to the field should be present in the code in a binary file, including the class or interface which declared the field. Such a field must always appear to have been initialized (§12.4.2); the default initial value for the field (if different than V) must never be observed.</p>\n</blockquote>\n\n<p><a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.12.4\" rel=\"nofollow noopener\" target=\"_blank\">\"Java Language Specs - 13.1. The Form of a Binary\"</a>には以下のとおり記述されており、文字列定数(<code>public static final String</code>)も埋め込みの対象であることがわかります。</p>\n\n<blockquote>\n<p>A constant variable is a final variable of primitive type or type String that is initialized with a constant expression (§15.28).</p>\n</blockquote>\n\n<h1>\n<span id=\"対策\" class=\"fragment\"></span><a href=\"#%E5%AF%BE%E7%AD%96\"><i class=\"fa fa-link\"></i></a>対策</h1>\n\n<p>文字列定数だけでなく、<code>public static final</code>として宣言された定数の値が変更になった場合、関連するソースコードはすべてコンパイルしなおすべきです。</p>\n\n<p>また上記のような問題をはらんでいることからも<code>public static final String</code>の乱用は危険です。定数を表現したい場合は<code>enum</code>を利用することも検討しましょう。</p>\n","body":"# 事象\n\n文字列定数(`public static final String`)ばかりが定義されたクラス`Const.java`と、その定数を利用する`Main.java`があるとします。\n\n```java:Const.java\npublic class Const {\n    public static final String VALUE = \"BEFORE\";\n}\n```\n\n```java:Main.java\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(Const.VALUE);\n    }\n}\n```\n\nこのふたつのjavaファイルをコンパイルし、実行すると、文字列定数`Const.VALUE`の値`BEFORE`が出力されます。\n\n```\nC:\\qiita> javac Const.java Main.java\n\nC:\\qiita> java Main\n```\n\nここで、文字列定数`Const.VALUE`の値が変更になったとします。\n\n```java:Const.java\npublic class Const {\n    public static final String VALUE = \"AFTER\";\n}\n```\n\n`Const.java`を編集後、`Const.java`だけを再コンパイルし、ふたたび`Main`を実行したところ、画面には`Const.VALUE`の現在の値である`AFTER`ではなく、`BEFORE`が表示されました。\n\n```\nC:\\qiita> del Const.class\n\nC:\\qiita> javac Const.java\n\nC:\\qiita> java Main\nBEFORE\n```\n\n# 調査\n\n`javap`コマンドで`Main.class`を逆アセンブルすると、`Main.class`には`BEFORE`という値が埋め込まれていることがわかります。\n\n```\nC:\\qiita> javap -c Main.class\nCompiled from \"Main.java\"\npublic class Main {\n  public Main();\n    Code:\n       0: aload_0\n       1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n       4: return\n\n  public static void main(java.lang.String[]);\n    Code:\n       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;\n       3: ldc           #4                  // String BEFORE\n       5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n       8: return\n}\n```\n\nコンパイラはコンパイル時に`Main.java`内の`Const.VALUE`を`BEFORE`という値に置き換えています。`Main.class`は`Const.class`をすでに参照していないため、`Const.VALUE`の値が変わっても、その変更が`Main.class`にまで伝播しませんでした。\n\nちなみに`Main.class`は`Const.class`を参照していないため、`Const.class`を削除してしまっても、`Main.class`は正常に動作します。\n\n```\nC:\\qiita> del Const.class\n\nC:\\qiita> java Main\nBEFORE\n```\n\n# 原因\n\nなぜ文字列定数が埋め込まれてしまったのかというと、これはJavaの仕様に起因します。[\"Java Language Specs - 13.1. The Form of a Binary\"](https://docs.oracle.com/javase/specs/jls/se8/html/jls-13.html#jls-13.1) には次の通り記述されています。\n\n> A reference to a field that is a constant variable (§4.12.4) must be resolved at compile time to the value V denoted by the constant variable's initializer.\n> If such a field is static, then no reference to the field should be present in the code in a binary file, including the class or interface which declared the field. Such a field must always appear to have been initialized (§12.4.2); the default initial value for the field (if different than V) must never be observed.\n\n\n[\"Java Language Specs - 13.1. The Form of a Binary\"](https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.12.4)には以下のとおり記述されており、文字列定数(`public static final String`)も埋め込みの対象であることがわかります。\n\n> A constant variable is a final variable of primitive type or type String that is initialized with a constant expression (§15.28).\n\n# 対策\n\n文字列定数だけでなく、`public static final`として宣言された定数の値が変更になった場合、関連するソースコードはすべてコンパイルしなおすべきです。\n\nまた上記のような問題をはらんでいることからも`public static final String`の乱用は危険です。定数を表現したい場合は`enum`を利用することも検討しましょう。\n","coediting":false,"comments_count":0,"created_at":"2020-04-12T20:41:49+09:00","group":null,"id":"55c5d1a53462b6d7918e","likes_count":1,"private":false,"reactions_count":0,"tags":[{"name":"Java","versions":[]}],"title":"public static final Stringとして宣言された文字列定数が埋め込まれる","updated_at":"2020-04-12T20:44:40+09:00","url":"https://qiita.com/neko_the_shadow/items/55c5d1a53462b6d7918e","user":{"description":"IT業界の片隅でひっそり生きるシステムエンジニアです(´・ω・｀)","facebook_id":"","followees_count":0,"followers_count":33,"github_login_name":null,"id":"neko_the_shadow","items_count":169,"linkedin_id":"","location":"神奈川県川崎市","name":"","organization":"","permanent_id":105859,"profile_image_url":"https://qiita-image-store.s3.amazonaws.com/0/105859/profile-images/1473709753","team_only":false,"twitter_screen_name":"neko_the_shadow","website_url":"https://nekotheshadow.github.io/"},"page_views_count":null}