{"rendered_body":"<div class=\"code-frame\" data-lang=\"rb\"><div class=\"highlight\"><pre><span class=\"n\">numbers</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">]</span>\n<span class=\"n\">numbers</span><span class=\"p\">.</span><span class=\"nf\">index</span><span class=\"p\">{</span><span class=\"o\">|</span><span class=\"n\">val</span><span class=\"o\">|</span> <span class=\"n\">val</span> <span class=\"o\">%</span> <span class=\"mi\">2</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">}</span> <span class=\"c1\">#=&gt; 2</span>\n</pre></div></div>\n\n<p><strong>配列の要素を先頭から見ていき、条件に一致する最初の要素の位置がほしい</strong>ということがよくあります。例として整数が格納された配列のうち、偶数となる最初の要素の位置を求めることを考えましょう。Rubyだと上記のようなワンライナーにより求めることができますが、Pythonではどのように書くべきでしょうか?</p>\n\n<div class=\"code-frame\" data-lang=\"py\"><div class=\"highlight\"><pre><span class=\"n\">numbers</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">]</span>\n<span class=\"nb\">min</span><span class=\"p\">((</span><span class=\"n\">i</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">numbers</span><span class=\"p\">))</span> <span class=\"k\">if</span> <span class=\"n\">numbers</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">%</span> <span class=\"mi\">2</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">),</span> <span class=\"n\">default</span><span class=\"o\">=-</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"c1\">#=&gt; 2\n</span></pre></div></div>\n\n<p>与えられた条件を満たす要素のうち、添え字が最も小さいものを返すイメージですね。なお<strong>組み込み関数<code>min</code>は与えられたイテレータが空のとき、例外を投げます。</strong>上記の例でいえば配列<code>numbers</code>の中に偶数がない場合、<code>i for i in range(len(numbers)) if numbers[i] % 2 == 0</code>が空になり、例外扱いとなります。ただし<strong>キーワード引数<code>default</code>を指定すると、イテーレタが空でも例外にはならず、代わりに<code>default</code>に指定した値を返します。</strong>要するに<code>numbers</code>に偶数が存在する場合は最初の偶数の要素の位置、存在しない場合は<code>-1</code>を返すわけです。</p>\n\n<p>ちなみに内包記法を使わないとなると次のようになりますが、Pythonらしいかどうかといわれると首をひねらざるを得ない見た目になってしまいます。そもそも可読性が高いとも思いません。またPythonの無名関数は特有の癖があるため、あまり使いたくないというのが本音だったりします。</p>\n\n<div class=\"code-frame\" data-lang=\"py\"><div class=\"highlight\"><pre><span class=\"n\">numbers</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">]</span>\n<span class=\"nb\">min</span><span class=\"p\">(</span><span class=\"nb\">filter</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">i</span> <span class=\"p\">:</span> <span class=\"n\">numbers</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">%</span> <span class=\"mi\">2</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">numbers</span><span class=\"p\">))),</span> <span class=\"n\">default</span><span class=\"o\">=-</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"c1\">#=&gt; 2\n</span></pre></div></div>\n\n<p>余談: 最初にあげたRubyの例ですが、次のように書くこともできます。</p>\n\n<div class=\"code-frame\" data-lang=\"rb\"><div class=\"highlight\"><pre><span class=\"n\">numbers</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">]</span>\n<span class=\"n\">numbers</span><span class=\"p\">.</span><span class=\"nf\">index</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"ss\">:even?</span><span class=\"p\">)</span> <span class=\"c1\">#=&gt; 2</span>\n</pre></div></div>\n","body":"\n```rb\nnumbers = [3, 5, 4, 2, 1]\nnumbers.index{|val| val % 2 == 0} #=> 2\n```\n\n__配列の要素を先頭から見ていき、条件に一致する最初の要素の位置がほしい__ということがよくあります。例として整数が格納された配列のうち、偶数となる最初の要素の位置を求めることを考えましょう。Rubyだと上記のようなワンライナーにより求めることができますが、Pythonではどのように書くべきでしょうか?\n\n```py\nnumbers = [3, 5, 4, 2, 1]\nmin((i for i in range(len(numbers)) if numbers[i] % 2 == 0), default=-1) #=> 2\n```\n\n与えられた条件を満たす要素のうち、添え字が最も小さいものを返すイメージですね。なお__組み込み関数`min`は与えられたイテレータが空のとき、例外を投げます。__上記の例でいえば配列`numbers`の中に偶数がない場合、`i for i in range(len(numbers)) if numbers[i] % 2 == 0`が空になり、例外扱いとなります。ただし__キーワード引数`default`を指定すると、イテーレタが空でも例外にはならず、代わりに`default`に指定した値を返します。__要するに`numbers`に偶数が存在する場合は最初の偶数の要素の位置、存在しない場合は`-1`を返すわけです。\n\nちなみに内包記法を使わないとなると次のようになりますが、Pythonらしいかどうかといわれると首をひねらざるを得ない見た目になってしまいます。そもそも可読性が高いとも思いません。またPythonの無名関数は特有の癖があるため、あまり使いたくないというのが本音だったりします。\n\n```py\nnumbers = [3, 5, 4, 2, 1]\nmin(filter(lambda i : numbers[i] % 2 == 0, range(len(numbers))), default=-1) #=> 2\n```\n\n余談: 最初にあげたRubyの例ですが、次のように書くこともできます。\n\n```rb\nnumbers = [3, 5, 4, 2, 1]\nnumbers.index(&:even?) #=> 2\n```\n\n","coediting":false,"comments_count":1,"created_at":"2017-03-07T01:13:06+09:00","group":null,"id":"76e517efbb510f735782","likes_count":1,"private":false,"reactions_count":0,"tags":[{"name":"Ruby","versions":[]},{"name":"Python3","versions":[]}],"title":"「配列の要素のうち、条件に一致する最初の要素の位置」をワンライナーで求めたい(Python3)","updated_at":"2017-03-07T01:13:06+09:00","url":"https://qiita.com/neko_the_shadow/items/76e517efbb510f735782","user":{"description":"IT業界の片隅でひっそり生きるシステムエンジニアです(´・ω・｀)","facebook_id":"","followees_count":0,"followers_count":32,"github_login_name":null,"id":"neko_the_shadow","items_count":163,"linkedin_id":"","location":"神奈川県川崎市","name":"","organization":"","permanent_id":105859,"profile_image_url":"https://qiita-image-store.s3.amazonaws.com/0/105859/profile-images/1473709753","team_only":false,"twitter_screen_name":"neko_the_shadow","website_url":"https://nekotheshadow.github.io/"},"page_views_count":null}