{"rendered_body":"<p>サイズ$n$の順列をすべて生成する処理をC#で実装する機会があったので、そのメモになります。RubyやPythonだと順列の列挙は標準ライブラリに用意されており、ふだんはそういう「出来合い」のものを使うことが多いので、自力で実装するのに思ったよりも時間がかかってしまった(´・ω・｀)</p>\n\n<div class=\"code-frame\" data-lang=\"csharp\"><div class=\"highlight\"><pre class=\"with-code\"><code><span class=\"k\">using</span> <span class=\"nn\">System</span><span class=\"p\">;</span>\n<span class=\"k\">using</span> <span class=\"nn\">System.Collections.Generic</span><span class=\"p\">;</span>\n<span class=\"k\">using</span> <span class=\"nn\">System.Linq</span><span class=\"p\">;</span>\n\n<span class=\"k\">namespace</span> <span class=\"nn\">permutations</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">class</span> <span class=\"nc\">Program</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">static</span> <span class=\"n\">List</span><span class=\"p\">&lt;</span><span class=\"n\">List</span><span class=\"p\">&lt;</span><span class=\"n\">T</span><span class=\"p\">&gt;&gt;</span> <span class=\"n\">Permutations</span><span class=\"p\">&lt;</span><span class=\"n\">T</span><span class=\"p\">&gt;(</span><span class=\"n\">List</span><span class=\"p\">&lt;</span><span class=\"n\">T</span><span class=\"p\">&gt;</span> <span class=\"n\">src</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"p\">)</span>\n        <span class=\"p\">{</span>\n            <span class=\"c1\">// nは1以上かつsrcの長さよりも短い必要がある。</span>\n            <span class=\"kt\">int</span> <span class=\"n\">len</span> <span class=\"p\">=</span> <span class=\"n\">src</span><span class=\"p\">.</span><span class=\"n\">Count</span><span class=\"p\">;</span>\n            <span class=\"k\">if</span> <span class=\"p\">(!(</span><span class=\"m\">0</span> <span class=\"p\">&lt;</span> <span class=\"n\">n</span> <span class=\"p\">&amp;&amp;</span> <span class=\"n\">n</span> <span class=\"p\">&lt;=</span> <span class=\"n\">len</span><span class=\"p\">))</span>\n            <span class=\"p\">{</span>\n                <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"nf\">ArgumentOutOfRangeException</span><span class=\"p\">();</span>\n            <span class=\"p\">}</span>\n\n            <span class=\"kt\">var</span> <span class=\"n\">permutations</span> <span class=\"p\">=</span> <span class=\"k\">new</span> <span class=\"n\">List</span><span class=\"p\">&lt;</span><span class=\"n\">List</span><span class=\"p\">&lt;</span><span class=\"n\">T</span><span class=\"p\">&gt;&gt;();</span>\n            <span class=\"kt\">var</span> <span class=\"n\">queue</span> <span class=\"p\">=</span> <span class=\"k\">new</span> <span class=\"n\">Queue</span><span class=\"p\">&lt;</span><span class=\"n\">List</span><span class=\"p\">&lt;</span><span class=\"kt\">int</span><span class=\"p\">&gt;&gt;(</span><span class=\"n\">Enumerable</span><span class=\"p\">.</span><span class=\"nf\">Range</span><span class=\"p\">(</span><span class=\"m\">0</span><span class=\"p\">,</span> <span class=\"n\">len</span><span class=\"p\">).</span><span class=\"nf\">Select</span><span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"p\">=&gt;</span> <span class=\"k\">new</span> <span class=\"n\">List</span><span class=\"p\">&lt;</span><span class=\"kt\">int</span><span class=\"p\">&gt;()</span> <span class=\"p\">{</span> <span class=\"n\">i</span> <span class=\"p\">}));</span>\n            <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">queue</span><span class=\"p\">.</span><span class=\"nf\">Any</span><span class=\"p\">())</span>\n            <span class=\"p\">{</span>\n                <span class=\"kt\">var</span> <span class=\"n\">indexes</span> <span class=\"p\">=</span> <span class=\"n\">queue</span><span class=\"p\">.</span><span class=\"nf\">Dequeue</span><span class=\"p\">();</span>\n\n                <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">indexes</span><span class=\"p\">.</span><span class=\"n\">Count</span> <span class=\"p\">==</span> <span class=\"n\">n</span><span class=\"p\">)</span>\n                <span class=\"p\">{</span>\n                    <span class=\"n\">permutations</span><span class=\"p\">.</span><span class=\"nf\">Add</span><span class=\"p\">(</span><span class=\"n\">indexes</span><span class=\"p\">.</span><span class=\"nf\">Select</span><span class=\"p\">(</span><span class=\"n\">index</span> <span class=\"p\">=&gt;</span> <span class=\"n\">src</span><span class=\"p\">[</span><span class=\"n\">index</span><span class=\"p\">]).</span><span class=\"nf\">ToList</span><span class=\"p\">());</span>\n                    <span class=\"k\">continue</span><span class=\"p\">;</span>\n                <span class=\"p\">}</span>\n\n                <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">index</span> <span class=\"p\">=</span> <span class=\"m\">0</span><span class=\"p\">;</span> <span class=\"n\">index</span> <span class=\"p\">&lt;</span> <span class=\"n\">len</span><span class=\"p\">;</span> <span class=\"n\">index</span><span class=\"p\">++)</span>\n                <span class=\"p\">{</span>\n                    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">indexes</span><span class=\"p\">.</span><span class=\"nf\">Contains</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">))</span>\n                    <span class=\"p\">{</span>\n                        <span class=\"k\">continue</span><span class=\"p\">;</span>\n                    <span class=\"p\">}</span>\n\n                    <span class=\"kt\">var</span> <span class=\"n\">newIndexes</span> <span class=\"p\">=</span> <span class=\"k\">new</span> <span class=\"n\">List</span><span class=\"p\">&lt;</span><span class=\"kt\">int</span><span class=\"p\">&gt;(</span><span class=\"n\">indexes</span><span class=\"p\">);</span>\n                    <span class=\"n\">newIndexes</span><span class=\"p\">.</span><span class=\"nf\">Add</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">);</span>\n                    <span class=\"n\">queue</span><span class=\"p\">.</span><span class=\"nf\">Enqueue</span><span class=\"p\">(</span><span class=\"n\">newIndexes</span><span class=\"p\">);</span>\n                <span class=\"p\">}</span>\n            <span class=\"p\">}</span>\n\n            <span class=\"k\">return</span> <span class=\"n\">permutations</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<ul>\n<li>インターネットの広大な海で調べてみると、再帰を利用して実装している例が多かったのですが、今回はQueueを使った幅優先探索にしてみました。再帰は実装がシンプルになる反面、深くなるとStack Over Flowなどの制御が難しくなるため、個人的にはStackやQueueを使うほうが個人的には好みです。</li>\n<li>生成した順列をすべてリストに格納するため、順列の数が多くなると、それだけメモリの消費量が多くなります。つまり順列の数が多くなることが明らかな場合、上記のような実装では注意が必要です。本来ならば<code>yield return</code>やイテレータなどを利用し、メモリの消費量を制限すべきですが、自分が使う分には問題ないので、よしとします(´・ω・｀)</li>\n</ul>\n\n<p>最後に使用方法を2つ示して終わりにしたいと思います。まずひとつめ。</p>\n\n<div class=\"code-frame\" data-lang=\"csharp\"><div class=\"highlight\"><pre class=\"with-code\"><code><span class=\"kt\">var</span> <span class=\"n\">src</span> <span class=\"p\">=</span> <span class=\"k\">new</span> <span class=\"n\">List</span><span class=\"p\">&lt;</span><span class=\"kt\">string</span><span class=\"p\">&gt;()</span> <span class=\"p\">{</span> <span class=\"s\">\"A\"</span><span class=\"p\">,</span> <span class=\"s\">\"B\"</span><span class=\"p\">,</span> <span class=\"s\">\"C\"</span><span class=\"p\">,</span> <span class=\"s\">\"D\"</span><span class=\"p\">,</span> <span class=\"s\">\"E\"</span> <span class=\"p\">};</span>\n<span class=\"kt\">var</span> <span class=\"n\">permutations</span> <span class=\"p\">=</span> <span class=\"nf\">Permutations</span><span class=\"p\">(</span><span class=\"n\">src</span><span class=\"p\">,</span> <span class=\"m\">3</span><span class=\"p\">);</span>\n<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"p\">=</span> <span class=\"m\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"p\">&lt;</span> <span class=\"n\">permutations</span><span class=\"p\">.</span><span class=\"n\">Count</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"p\">+=</span> <span class=\"m\">5</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"p\">=</span> <span class=\"n\">Math</span><span class=\"p\">.</span><span class=\"nf\">Min</span><span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"p\">+</span> <span class=\"m\">4</span><span class=\"p\">,</span> <span class=\"n\">permutations</span><span class=\"p\">.</span><span class=\"n\">Count</span><span class=\"p\">);</span>\n    <span class=\"kt\">var</span> <span class=\"n\">tokens</span> <span class=\"p\">=</span> <span class=\"n\">permutations</span><span class=\"p\">.</span><span class=\"nf\">GetRange</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">j</span> <span class=\"p\">-</span> <span class=\"n\">i</span> <span class=\"p\">+</span> <span class=\"m\">1</span><span class=\"p\">).</span><span class=\"nf\">Select</span><span class=\"p\">(</span><span class=\"n\">permutation</span> <span class=\"p\">=&gt;</span> <span class=\"s\">\"[\"</span> <span class=\"p\">+</span> <span class=\"kt\">string</span><span class=\"p\">.</span><span class=\"nf\">Join</span><span class=\"p\">(</span><span class=\"s\">\",\"</span><span class=\"p\">,</span> <span class=\"n\">permutation</span><span class=\"p\">)</span> <span class=\"p\">+</span> <span class=\"s\">\"]\"</span><span class=\"p\">);</span>\n    <span class=\"kt\">var</span> <span class=\"n\">line</span> <span class=\"p\">=</span> <span class=\"kt\">string</span><span class=\"p\">.</span><span class=\"nf\">Join</span><span class=\"p\">(</span><span class=\"s\">\" \"</span><span class=\"p\">,</span> <span class=\"n\">tokens</span><span class=\"p\">);</span>\n    <span class=\"n\">Console</span><span class=\"p\">.</span><span class=\"nf\">WriteLine</span><span class=\"p\">(</span><span class=\"n\">line</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>これを実行すると、以下のような値が標準出力に出力されます。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre class=\"with-code\"><code>[A,B,C] [A,B,D] [A,B,E] [A,C,B] [A,C,D]\n[A,C,E] [A,D,B] [A,D,C] [A,D,E] [A,E,B]\n[A,E,C] [A,E,D] [B,A,C] [B,A,D] [B,A,E]\n[B,C,A] [B,C,D] [B,C,E] [B,D,A] [B,D,C]\n[B,D,E] [B,E,A] [B,E,C] [B,E,D] [C,A,B]\n[C,A,D] [C,A,E] [C,B,A] [C,B,D] [C,B,E]\n[C,D,A] [C,D,B] [C,D,E] [C,E,A] [C,E,B]\n[C,E,D] [D,A,B] [D,A,C] [D,A,E] [D,B,A]\n[D,B,C] [D,B,E] [D,C,A] [D,C,B] [D,C,E]\n[D,E,A] [D,E,B] [D,E,C] [E,A,B] [E,A,C]\n[E,A,D] [E,B,A] [E,B,C] [E,B,D] [E,C,A]\n[E,C,B] [E,C,D] [E,D,A] [E,D,B] [E,D,C]\n</code></pre></div></div>\n\n<p>2つ目のサンプルはもうちょっとシンプルです。</p>\n\n<div class=\"code-frame\" data-lang=\"csharp\"><div class=\"highlight\"><pre class=\"with-code\"><code><span class=\"kt\">var</span> <span class=\"n\">src</span> <span class=\"p\">=</span> <span class=\"k\">new</span> <span class=\"n\">List</span><span class=\"p\">&lt;</span><span class=\"kt\">int</span><span class=\"p\">&gt;()</span> <span class=\"p\">{</span> <span class=\"m\">1</span><span class=\"p\">,</span> <span class=\"m\">2</span><span class=\"p\">,</span> <span class=\"m\">3</span><span class=\"p\">,</span> <span class=\"m\">4</span> <span class=\"p\">};</span>\n<span class=\"k\">foreach</span> <span class=\"p\">(</span><span class=\"kt\">var</span> <span class=\"n\">permutation</span> <span class=\"k\">in</span> <span class=\"nf\">Permutations</span><span class=\"p\">(</span><span class=\"n\">src</span><span class=\"p\">,</span> <span class=\"m\">2</span><span class=\"p\">))</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">Console</span><span class=\"p\">.</span><span class=\"nf\">WriteLine</span><span class=\"p\">(</span><span class=\"kt\">string</span><span class=\"p\">.</span><span class=\"nf\">Join</span><span class=\"p\">(</span><span class=\"s\">\",\"</span><span class=\"p\">,</span> <span class=\"n\">permutation</span><span class=\"p\">));</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>この実行結果は次の通りです。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre class=\"with-code\"><code>1,2\n1,3\n1,4\n2,1\n2,3\n2,4\n3,1\n3,2\n3,4\n4,1\n4,2\n4,3\n</code></pre></div></div>\n","body":"サイズ$n$の順列をすべて生成する処理をC#で実装する機会があったので、そのメモになります。RubyやPythonだと順列の列挙は標準ライブラリに用意されており、ふだんはそういう「出来合い」のものを使うことが多いので、自力で実装するのに思ったよりも時間がかかってしまった(´・ω・｀)\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace permutations\n{\n    class Program\n    {\n        static List<List<T>> Permutations<T>(List<T> src, int n)\n        {\n            // nは1以上かつsrcの長さよりも短い必要がある。\n            int len = src.Count;\n            if (!(0 < n && n <= len))\n            {\n                throw new ArgumentOutOfRangeException();\n            }\n\n            var permutations = new List<List<T>>();\n            var queue = new Queue<List<int>>(Enumerable.Range(0, len).Select(i => new List<int>() { i }));\n            while (queue.Any())\n            {\n                var indexes = queue.Dequeue();\n\n                if (indexes.Count == n)\n                {\n                    permutations.Add(indexes.Select(index => src[index]).ToList());\n                    continue;\n                }\n                \n                for (int index = 0; index < len; index++)\n                {\n                    if (indexes.Contains(index))\n                    {\n                        continue;\n                    }\n\n                    var newIndexes = new List<int>(indexes);\n                    newIndexes.Add(index);\n                    queue.Enqueue(newIndexes);\n                }\n            }\n\n            return permutations;\n        }\n    }\n}\n```\n\n- インターネットの広大な海で調べてみると、再帰を利用して実装している例が多かったのですが、今回はQueueを使った幅優先探索にしてみました。再帰は実装がシンプルになる反面、深くなるとStack Over Flowなどの制御が難しくなるため、個人的にはStackやQueueを使うほうが個人的には好みです。\n- 生成した順列をすべてリストに格納するため、順列の数が多くなると、それだけメモリの消費量が多くなります。つまり順列の数が多くなることが明らかな場合、上記のような実装では注意が必要です。本来ならば`yield return`やイテレータなどを利用し、メモリの消費量を制限すべきですが、自分が使う分には問題ないので、よしとします(´・ω・｀)\n\n最後に使用方法を2つ示して終わりにしたいと思います。まずひとつめ。\n\n```csharp\nvar src = new List<string>() { \"A\", \"B\", \"C\", \"D\", \"E\" };\nvar permutations = Permutations(src, 3);\nfor (int i = 0; i < permutations.Count; i += 5)\n{\n    int j = Math.Min(i + 4, permutations.Count);\n    var tokens = permutations.GetRange(i, j - i + 1).Select(permutation => \"[\" + string.Join(\",\", permutation) + \"]\");\n    var line = string.Join(\" \", tokens);\n    Console.WriteLine(line);\n}\n```\n\nこれを実行すると、以下のような値が標準出力に出力されます。\n\n```\n[A,B,C] [A,B,D] [A,B,E] [A,C,B] [A,C,D]\n[A,C,E] [A,D,B] [A,D,C] [A,D,E] [A,E,B]\n[A,E,C] [A,E,D] [B,A,C] [B,A,D] [B,A,E]\n[B,C,A] [B,C,D] [B,C,E] [B,D,A] [B,D,C]\n[B,D,E] [B,E,A] [B,E,C] [B,E,D] [C,A,B]\n[C,A,D] [C,A,E] [C,B,A] [C,B,D] [C,B,E]\n[C,D,A] [C,D,B] [C,D,E] [C,E,A] [C,E,B]\n[C,E,D] [D,A,B] [D,A,C] [D,A,E] [D,B,A]\n[D,B,C] [D,B,E] [D,C,A] [D,C,B] [D,C,E]\n[D,E,A] [D,E,B] [D,E,C] [E,A,B] [E,A,C]\n[E,A,D] [E,B,A] [E,B,C] [E,B,D] [E,C,A]\n[E,C,B] [E,C,D] [E,D,A] [E,D,B] [E,D,C]\n```\n\n2つ目のサンプルはもうちょっとシンプルです。\n\n```csharp\nvar src = new List<int>() { 1, 2, 3, 4 };\nforeach (var permutation in Permutations(src, 2))\n{\n    Console.WriteLine(string.Join(\",\", permutation));\n}\n```\nこの実行結果は次の通りです。\n\n```\n1,2\n1,3\n1,4\n2,1\n2,3\n2,4\n3,1\n3,2\n3,4\n4,1\n4,2\n4,3\n```\n","coediting":false,"comments_count":1,"created_at":"2018-11-20T23:49:27+09:00","group":null,"id":"e6a931b8a9193b47fcd3","likes_count":2,"private":false,"reactions_count":0,"tags":[{"name":"C#","versions":[]}],"title":"C#でサイズnの順列をすべて生成したい。","updated_at":"2018-11-20T23:49:27+09:00","url":"https://qiita.com/neko_the_shadow/items/e6a931b8a9193b47fcd3","user":{"description":"IT業界の片隅でひっそり生きるシステムエンジニアです(´・ω・｀)","facebook_id":"","followees_count":0,"followers_count":36,"github_login_name":null,"id":"neko_the_shadow","items_count":191,"linkedin_id":"","location":"神奈川県川崎市","name":"","organization":"","permanent_id":105859,"profile_image_url":"https://qiita-image-store.s3.amazonaws.com/0/105859/profile-images/1473709753","team_only":false,"twitter_screen_name":"neko_the_shadow","website_url":"https://nekotheshadow.github.io/"},"page_views_count":null,"team_membership":null}