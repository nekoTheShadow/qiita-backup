{"rendered_body":"<p>プログラム設計書を書く――というかソースコードからプログラム設計書を起こす機会があったのですが、その設計書が「作成したJavaクラスに親クラス名すべてと実装しているインターフェイスすべてを併記しなさい」というものでした。これを馬鹿正直に手で作るのは面倒。そこで<strong>「クラス名から親クラスとインターフェイスを再帰的に求める」</strong>というプログラムを書くことにしました。以下はそのサンプルになります。</p>\n\n<div class=\"code-frame\" data-lang=\"java\"><div class=\"highlight\"><pre>\n\n<span class=\"kn\">import</span> <span class=\"nn\">java.util.ArrayList</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">java.util.List</span><span class=\"o\">;</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Main</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"nc\">ClassNotFoundException</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// クラス名からクラスオブジェクトを生成する。</span>\n        <span class=\"nc\">Class</span><span class=\"o\">&lt;?&gt;</span> <span class=\"n\">pivotClass</span> <span class=\"o\">=</span> <span class=\"nc\">Class</span><span class=\"o\">.</span><span class=\"na\">forName</span><span class=\"o\">(</span><span class=\"s\">\"java.util.ArrayList\"</span><span class=\"o\">);</span>\n\n        <span class=\"c1\">// スーパークラスを再帰的にたどる。</span>\n        <span class=\"nc\">List</span><span class=\"o\">&lt;</span><span class=\"nc\">Class</span><span class=\"o\">&lt;?&gt;&gt;</span> <span class=\"n\">classes</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">ArrayList</span><span class=\"o\">&lt;&gt;();</span>\n        <span class=\"nc\">Class</span><span class=\"o\">&lt;?&gt;</span> <span class=\"n\">superClass</span> <span class=\"o\">=</span> <span class=\"n\">pivotClass</span><span class=\"o\">;</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">superClass</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">classes</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">superClass</span><span class=\"o\">);</span>\n            <span class=\"n\">superClass</span> <span class=\"o\">=</span> <span class=\"n\">superClass</span><span class=\"o\">.</span><span class=\"na\">getSuperclass</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"c1\">// 再帰的に取得したスーパークラスの一覧を取得する。</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"nc\">Class</span><span class=\"o\">&lt;?&gt;</span> <span class=\"n\">clazz</span> <span class=\"o\">:</span> <span class=\"n\">classes</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">clazz</span><span class=\"o\">.</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n        <span class=\"o\">}</span>\n        <span class=\"cm\">/*　java.util.ArrayList\n          　java.util.AbstractList\n          　java.util.AbstractCollection\n            java.lang.Object */</span>        \n\n        <span class=\"c1\">// 実装しているインターフェイスの一覧を取得&amp;出力する。</span>\n        <span class=\"nc\">Class</span><span class=\"o\">&lt;?&gt;[]</span> <span class=\"n\">interfaces</span> <span class=\"o\">=</span> <span class=\"n\">pivotClass</span><span class=\"o\">.</span><span class=\"na\">getInterfaces</span><span class=\"o\">();</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"nc\">Class</span><span class=\"o\">&lt;?&gt;</span> <span class=\"n\">interfaze</span> <span class=\"o\">:</span> <span class=\"n\">interfaces</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">interfaze</span><span class=\"o\">.</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n        <span class=\"o\">}</span>\n        <span class=\"cm\">/* java.util.List\n           java.util.RandomAccess\n           java.lang.Cloneable\n           java.io.Serializable */</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n</pre></div></div>\n\n<p>「クラスそのものがクラスとして扱える」というのは少し奇妙ですが、慣れると便利ですね。メタプログラミング万歳(´・ω・｀)</p>\n","body":"\nプログラム設計書を書く――というかソースコードからプログラム設計書を起こす機会があったのですが、その設計書が「作成したJavaクラスに親クラス名すべてと実装しているインターフェイスすべてを併記しなさい」というものでした。これを馬鹿正直に手で作るのは面倒。そこで__「クラス名から親クラスとインターフェイスを再帰的に求める」__というプログラムを書くことにしました。以下はそのサンプルになります。\n\n```java\n\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) throws ClassNotFoundException {\n        // クラス名からクラスオブジェクトを生成する。\n        Class<?> pivotClass = Class.forName(\"java.util.ArrayList\");\n        \n        // スーパークラスを再帰的にたどる。\n        List<Class<?>> classes = new ArrayList<>();\n        Class<?> superClass = pivotClass;\n        while (superClass != null) {\n            classes.add(superClass);\n            superClass = superClass.getSuperclass();\n        }\n        \n        // 再帰的に取得したスーパークラスの一覧を取得する。\n        for (Class<?> clazz : classes) {\n            System.out.println(clazz.getName());\n        }\n        /*　java.util.ArrayList\n          　java.util.AbstractList\n          　java.util.AbstractCollection\n            java.lang.Object */        \n        \n        // 実装しているインターフェイスの一覧を取得&出力する。\n        Class<?>[] interfaces = pivotClass.getInterfaces();\n        for (Class<?> interfaze : interfaces) {\n            System.out.println(interfaze.getName());\n        }\n        /* java.util.List\n           java.util.RandomAccess\n           java.lang.Cloneable\n           java.io.Serializable */\n    }\n}\n\n```\n\n「クラスそのものがクラスとして扱える」というのは少し奇妙ですが、慣れると便利ですね。メタプログラミング万歳(´・ω・｀)\n","coediting":false,"comments_count":0,"created_at":"2017-02-25T23:22:14+09:00","group":null,"id":"eb28da0f3514bc8373d3","likes_count":2,"private":false,"reactions_count":0,"tags":[{"name":"Java","versions":[]}],"title":"とあるクラスのスーパークラスとインターフェイスを再帰的に取得したい","updated_at":"2017-02-25T23:22:14+09:00","url":"https://qiita.com/neko_the_shadow/items/eb28da0f3514bc8373d3","user":{"description":"IT業界の片隅でひっそり生きるシステムエンジニアです(´・ω・｀)","facebook_id":"","followees_count":0,"followers_count":33,"github_login_name":null,"id":"neko_the_shadow","items_count":169,"linkedin_id":"","location":"神奈川県川崎市","name":"","organization":"","permanent_id":105859,"profile_image_url":"https://qiita-image-store.s3.amazonaws.com/0/105859/profile-images/1473709753","team_only":false,"twitter_screen_name":"neko_the_shadow","website_url":"https://nekotheshadow.github.io/"},"page_views_count":null}