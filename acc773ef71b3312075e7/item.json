{"rendered_body":"<p><strong>注意: 本記事のSQLはPostgreSQLの次のバージョンで動作確認を行っています: <code>psql (PostgreSQL) 10.5 (Ubuntu 10.5-0ubuntu0.18.04)</code></strong></p>\n\n<p>元ネタ: <a href=\"https://qiita.com/tbpgr/items/427d35f981cd9675efb9\" id=\"reference-b7d5f987fe6ed5275605\">ずんだの表見出し++問題 Ruby 編</a></p>\n\n<p>計算資源が乏しかった時代の名残なのか、正規化という考え方を知らなかった人が設計したのか、正確なところはわからないのですが、交差テーブルを使わずに、デリミタ区切りのリストを使うテーブル設計がなされていることがあります。なおDB&amp;SQL設計の名著<a href=\"https://www.oreilly.co.jp/books/9784873115894/\" rel=\"nofollow noopener\" target=\"_blank\">『SQLアンチパターン』</a>では、このパターンを「ジェイウォーク(信号無視)」として、なるべく避けることを推奨しています。洋の東西を超えて、やらかしがちなテーブル設計なのかもしれません。</p>\n\n<div class=\"code-frame\" data-lang=\"sql\"><div class=\"highlight\"><pre><code><span class=\"k\">create</span> <span class=\"k\">table</span> <span class=\"n\">columns</span> <span class=\"p\">(</span>\n  <span class=\"k\">no</span>    <span class=\"nb\">integer</span> <span class=\"k\">not</span> <span class=\"k\">null</span> <span class=\"k\">primary</span> <span class=\"k\">key</span><span class=\"p\">,</span>\n  <span class=\"n\">cells</span> <span class=\"nb\">text</span> \n<span class=\"p\">);</span>\n\n<span class=\"k\">insert</span> <span class=\"k\">into</span> <span class=\"n\">columns</span> <span class=\"k\">values</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s1\">'0|col1|col2|col3'</span><span class=\"p\">);</span>\n<span class=\"k\">insert</span> <span class=\"k\">into</span> <span class=\"n\">columns</span> <span class=\"k\">values</span> <span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"s1\">'1|col1|col2|col3'</span><span class=\"p\">);</span>\n<span class=\"k\">insert</span> <span class=\"k\">into</span> <span class=\"n\">columns</span> <span class=\"k\">values</span> <span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"s1\">'2|col1|col2|col3'</span><span class=\"p\">);</span>\n<span class=\"k\">insert</span> <span class=\"k\">into</span> <span class=\"n\">columns</span> <span class=\"k\">values</span> <span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"s1\">'3|col1|col2|col3'</span><span class=\"p\">);</span>\n<span class=\"k\">insert</span> <span class=\"k\">into</span> <span class=\"n\">columns</span> <span class=\"k\">values</span> <span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"s1\">'4|col1|col2|col3'</span><span class=\"p\">);</span>\n</code></pre></div></div>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre><code>select * from columns;\n\n no |      cells\n----+------------------\n  1 | 0|col1|col2|col3\n  2 | 1|col1|col2|col3\n  3 | 2|col1|col2|col3\n  4 | 3|col1|col2|col3\n  5 | 4|col1|col2|col3\n(5 rows)\n\n</code></pre></div></div>\n\n<p>テーブルがこういう設計になっていると、UPDATEはもちろんのことSELECTでもつらい場合があるので、許されるならば正規化されたVIEWを作成したいところです。方法はいくつかあると思いますが、標準的なSQLに準拠するとなると、再帰クエリと文字列関数を組み合わせるのがよさそうです。</p>\n\n<div class=\"code-frame\" data-lang=\"sql\"><div class=\"highlight\"><pre><code><span class=\"k\">create</span> <span class=\"k\">or</span> <span class=\"k\">replace</span> <span class=\"k\">view</span> <span class=\"n\">cells</span> <span class=\"p\">(</span><span class=\"k\">no</span><span class=\"p\">,</span> <span class=\"k\">index</span><span class=\"p\">,</span> <span class=\"n\">cell</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"p\">(</span>\n  <span class=\"k\">with</span> <span class=\"k\">recursive</span> <span class=\"n\">t</span> <span class=\"p\">(</span><span class=\"k\">no</span><span class=\"p\">,</span> <span class=\"k\">index</span><span class=\"p\">,</span> <span class=\"n\">head</span><span class=\"p\">,</span> <span class=\"n\">tail</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"p\">(</span>\n      <span class=\"k\">select</span>\n        <span class=\"k\">no</span><span class=\"p\">,</span>\n        <span class=\"mi\">0</span><span class=\"p\">,</span>\n        <span class=\"k\">null</span><span class=\"p\">,</span>\n        <span class=\"n\">cells</span> <span class=\"o\">||</span> <span class=\"s1\">'|'</span>\n      <span class=\"k\">from</span> <span class=\"n\">columns</span>\n    <span class=\"k\">union</span> <span class=\"k\">all</span>\n      <span class=\"k\">select</span>\n        <span class=\"k\">no</span><span class=\"p\">,</span>\n        <span class=\"k\">index</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n        <span class=\"k\">substring</span><span class=\"p\">(</span><span class=\"n\">tail</span> <span class=\"k\">from</span> <span class=\"mi\">1</span> <span class=\"k\">for</span> <span class=\"k\">position</span><span class=\"p\">(</span><span class=\"s1\">'|'</span> <span class=\"k\">in</span> <span class=\"n\">tail</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">),</span>\n        <span class=\"k\">substring</span><span class=\"p\">(</span><span class=\"n\">tail</span> <span class=\"k\">from</span> <span class=\"k\">position</span><span class=\"p\">(</span><span class=\"s1\">'|'</span> <span class=\"k\">in</span> <span class=\"n\">tail</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n      <span class=\"k\">from</span> <span class=\"n\">t</span>\n      <span class=\"k\">where</span> <span class=\"k\">length</span><span class=\"p\">(</span><span class=\"n\">tail</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"p\">)</span>\n  <span class=\"k\">select</span> <span class=\"k\">no</span><span class=\"p\">,</span> <span class=\"k\">index</span><span class=\"p\">,</span> <span class=\"n\">head</span> <span class=\"k\">from</span> <span class=\"n\">t</span> <span class=\"k\">where</span> <span class=\"k\">index</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span>\n<span class=\"p\">);</span>\n</code></pre></div></div>\n\n<p>作成したcellsというVIEWの中身を見てみると、正規化されていることがわかります。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre><code>select * from cells order by no, index;\n\n no | index | cell\n----+-------+------\n  1 |     1 | 0\n  1 |     2 | col1\n  1 |     3 | col2\n  1 |     4 | col3\n  2 |     1 | 1\n  2 |     2 | col1\n  2 |     3 | col2\n  2 |     4 | col3\n  3 |     1 | 2\n  3 |     2 | col1\n  3 |     3 | col2\n  3 |     4 | col3\n  4 |     1 | 3\n  4 |     2 | col1\n  4 |     3 | col2\n  4 |     4 | col3\n  5 |     1 | 4\n  5 |     2 | col1\n  5 |     3 | col2\n  5 |     4 | col3\n(20 rows)\n</code></pre></div></div>\n\n<p>あとは次のようなクエリで「ずんだの表見出し++問題」を解くことができるはずです。</p>\n\n<div class=\"code-frame\" data-lang=\"sql\"><div class=\"highlight\"><pre><code><span class=\"k\">select</span>\n  <span class=\"n\">string_agg</span><span class=\"p\">(</span>\n    <span class=\"k\">case</span> <span class=\"k\">when</span> <span class=\"k\">index</span> <span class=\"o\">=</span> <span class=\"mi\">1</span> <span class=\"k\">then</span> <span class=\"p\">(</span><span class=\"n\">cell</span><span class=\"p\">::</span><span class=\"nb\">integer</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)::</span><span class=\"nb\">text</span> <span class=\"k\">else</span> <span class=\"n\">cell</span> <span class=\"k\">end</span><span class=\"p\">,</span>\n    <span class=\"s1\">'|'</span>\n  <span class=\"p\">)</span>\n<span class=\"k\">from</span> <span class=\"n\">cells</span>\n<span class=\"k\">group</span> <span class=\"k\">by</span> <span class=\"k\">no</span>\n<span class=\"k\">order</span> <span class=\"k\">by</span> <span class=\"k\">no</span><span class=\"p\">;</span>\n</code></pre></div></div>\n\n<p>結果は次の通りです。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre><code>    string_agg\n------------------\n 1|col1|col2|col3\n 2|col1|col2|col3\n 3|col1|col2|col3\n 4|col1|col2|col3\n 5|col1|col2|col3\n(5 rows)\n</code></pre></div></div>\n\n<hr>\n\n<p>ここからは完全に余談(´・ω・｀) PostgreSQLでは珍しく配列がサポートされています。cellsというVIEWを作る際、上記の例では文字列関数を複雑に組み合わせていましたが、配列を利用するとかなり直感的に書き直すことができます。</p>\n\n<div class=\"code-frame\" data-lang=\"sql\"><div class=\"highlight\"><pre><code><span class=\"k\">create</span> <span class=\"k\">or</span> <span class=\"k\">replace</span> <span class=\"k\">view</span> <span class=\"n\">cells</span> <span class=\"p\">(</span><span class=\"k\">no</span><span class=\"p\">,</span> <span class=\"k\">index</span><span class=\"p\">,</span> <span class=\"n\">cell</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"p\">(</span>\n  <span class=\"k\">with</span> <span class=\"k\">recursive</span> <span class=\"n\">t</span> <span class=\"p\">(</span><span class=\"k\">no</span><span class=\"p\">,</span> <span class=\"k\">index</span><span class=\"p\">,</span> <span class=\"n\">head</span><span class=\"p\">,</span> <span class=\"n\">tail</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"p\">(</span>\n      <span class=\"k\">select</span> \n        <span class=\"k\">no</span><span class=\"p\">,</span>\n        <span class=\"mi\">0</span><span class=\"p\">,</span>\n        <span class=\"k\">null</span><span class=\"p\">,</span>\n        <span class=\"n\">string_to_array</span><span class=\"p\">(</span><span class=\"n\">cells</span><span class=\"p\">,</span> <span class=\"s1\">'|'</span><span class=\"p\">)</span>\n      <span class=\"k\">from</span> <span class=\"n\">columns</span>\n    <span class=\"k\">union</span> <span class=\"k\">all</span>\n      <span class=\"k\">select</span>\n        <span class=\"k\">no</span><span class=\"p\">,</span>\n        <span class=\"k\">index</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n        <span class=\"n\">tail</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span>\n        <span class=\"n\">tail</span><span class=\"p\">[</span><span class=\"mi\">2</span> <span class=\"p\">:</span> <span class=\"n\">array_length</span><span class=\"p\">(</span><span class=\"n\">tail</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)]</span>\n      <span class=\"k\">from</span> <span class=\"n\">t</span>\n      <span class=\"k\">where</span> <span class=\"n\">array_length</span><span class=\"p\">(</span><span class=\"n\">tail</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"p\">)</span>\n  <span class=\"k\">select</span> <span class=\"k\">no</span><span class=\"p\">,</span> <span class=\"k\">index</span><span class=\"p\">,</span> <span class=\"n\">head</span> <span class=\"k\">from</span> <span class=\"n\">t</span> <span class=\"k\">where</span> <span class=\"k\">index</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span>\n<span class=\"p\">);</span>\n</code></pre></div></div>\n\n<p>こうして作られたVIEWの中身を確認すると、文字列関数を組み合わせていたものと同じ結果が得られます。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre><code>select * from cells order by no, index;\n\n no | index | cell\n----+-------+------\n  1 |     1 | 0\n  1 |     2 | col1\n  1 |     3 | col2\n  1 |     4 | col3\n  2 |     1 | 1\n  2 |     2 | col1\n  2 |     3 | col2\n  2 |     4 | col3\n  3 |     1 | 2\n  3 |     2 | col1\n  3 |     3 | col2\n  3 |     4 | col3\n  4 |     1 | 3\n  4 |     2 | col1\n  4 |     3 | col2\n  4 |     4 | col3\n  5 |     1 | 4\n  5 |     2 | col1\n  5 |     3 | col2\n  5 |     4 | col3\n(20 rows)\n</code></pre></div></div>\n\n<p>そもそも配列を利用すればVIEWなどを使わずとも「ずんだの表見出し++問題」を解くことができます。</p>\n\n<div class=\"code-frame\" data-lang=\"sql\"><div class=\"highlight\"><pre><code><span class=\"k\">with</span> <span class=\"n\">t</span> <span class=\"p\">(</span><span class=\"k\">no</span><span class=\"p\">,</span> <span class=\"n\">cells</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"p\">(</span>\n  <span class=\"k\">select</span>\n    <span class=\"k\">no</span><span class=\"p\">,</span>\n    <span class=\"n\">string_to_array</span><span class=\"p\">(</span><span class=\"n\">cells</span><span class=\"p\">,</span> <span class=\"s1\">'|'</span><span class=\"p\">)</span>\n  <span class=\"k\">from</span> <span class=\"n\">columns</span>\n<span class=\"p\">)</span>\n<span class=\"k\">select</span>\n  <span class=\"n\">array_to_string</span><span class=\"p\">((</span><span class=\"n\">cells</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]::</span><span class=\"nb\">integer</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)::</span><span class=\"nb\">text</span> <span class=\"o\">||</span> <span class=\"n\">cells</span><span class=\"p\">[</span><span class=\"mi\">2</span> <span class=\"p\">:</span> <span class=\"n\">array_length</span><span class=\"p\">(</span><span class=\"n\">cells</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)],</span> <span class=\"s1\">'|'</span><span class=\"p\">)</span>\n<span class=\"k\">from</span> <span class=\"n\">t</span>\n<span class=\"k\">order</span> <span class=\"k\">by</span> <span class=\"k\">no</span><span class=\"p\">;</span>\n</code></pre></div></div>\n\n<p>この実行結果が以下。配列を使わない場合とまったく同じ結果が得られていることが分かります。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre><code> array_to_string\n------------------\n 1|col1|col2|col3\n 2|col1|col2|col3\n 3|col1|col2|col3\n 4|col1|col2|col3\n 5|col1|col2|col3\n(5 rows)\n</code></pre></div></div>\n","body":"__注意: 本記事のSQLはPostgreSQLの次のバージョンで動作確認を行っています: `psql (PostgreSQL) 10.5 (Ubuntu 10.5-0ubuntu0.18.04)`__\n\n元ネタ: [ずんだの表見出し++問題 Ruby 編](https://qiita.com/tbpgr/items/427d35f981cd9675efb9)\n\n計算資源が乏しかった時代の名残なのか、正規化という考え方を知らなかった人が設計したのか、正確なところはわからないのですが、交差テーブルを使わずに、デリミタ区切りのリストを使うテーブル設計がなされていることがあります。なおDB&SQL設計の名著[『SQLアンチパターン』](https://www.oreilly.co.jp/books/9784873115894/)では、このパターンを「ジェイウォーク(信号無視)」として、なるべく避けることを推奨しています。洋の東西を超えて、やらかしがちなテーブル設計なのかもしれません。\n\n```sql\ncreate table columns (\n  no    integer not null primary key,\n  cells text \n);\n\ninsert into columns values (1, '0|col1|col2|col3');\ninsert into columns values (2, '1|col1|col2|col3');\ninsert into columns values (3, '2|col1|col2|col3');\ninsert into columns values (4, '3|col1|col2|col3');\ninsert into columns values (5, '4|col1|col2|col3');\n```\n\n```\nselect * from columns;\n\n no |      cells\n----+------------------\n  1 | 0|col1|col2|col3\n  2 | 1|col1|col2|col3\n  3 | 2|col1|col2|col3\n  4 | 3|col1|col2|col3\n  5 | 4|col1|col2|col3\n(5 rows)\n\n```\n\nテーブルがこういう設計になっていると、UPDATEはもちろんのことSELECTでもつらい場合があるので、許されるならば正規化されたVIEWを作成したいところです。方法はいくつかあると思いますが、標準的なSQLに準拠するとなると、再帰クエリと文字列関数を組み合わせるのがよさそうです。\n\n```sql\ncreate or replace view cells (no, index, cell) as (\n  with recursive t (no, index, head, tail) as (\n      select\n        no,\n        0,\n        null,\n        cells || '|'\n      from columns\n    union all\n      select\n        no,\n        index + 1,\n        substring(tail from 1 for position('|' in tail) - 1),\n        substring(tail from position('|' in tail) + 1)\n      from t\n      where length(tail) > 0\n  )\n  select no, index, head from t where index > 0\n);\n```\n\n作成したcellsというVIEWの中身を見てみると、正規化されていることがわかります。\n\n```\nselect * from cells order by no, index;\n\n no | index | cell\n----+-------+------\n  1 |     1 | 0\n  1 |     2 | col1\n  1 |     3 | col2\n  1 |     4 | col3\n  2 |     1 | 1\n  2 |     2 | col1\n  2 |     3 | col2\n  2 |     4 | col3\n  3 |     1 | 2\n  3 |     2 | col1\n  3 |     3 | col2\n  3 |     4 | col3\n  4 |     1 | 3\n  4 |     2 | col1\n  4 |     3 | col2\n  4 |     4 | col3\n  5 |     1 | 4\n  5 |     2 | col1\n  5 |     3 | col2\n  5 |     4 | col3\n(20 rows)\n```\n\nあとは次のようなクエリで「ずんだの表見出し++問題」を解くことができるはずです。\n\n```sql\nselect\n  string_agg(\n    case when index = 1 then (cell::integer + 1)::text else cell end,\n    '|'\n  )\nfrom cells\ngroup by no\norder by no;\n```\n\n結果は次の通りです。\n\n```\n    string_agg\n------------------\n 1|col1|col2|col3\n 2|col1|col2|col3\n 3|col1|col2|col3\n 4|col1|col2|col3\n 5|col1|col2|col3\n(5 rows)\n```\n\n*** \n\nここからは完全に余談(´・ω・｀) PostgreSQLでは珍しく配列がサポートされています。cellsというVIEWを作る際、上記の例では文字列関数を複雑に組み合わせていましたが、配列を利用するとかなり直感的に書き直すことができます。\n\n```sql\ncreate or replace view cells (no, index, cell) as (\n  with recursive t (no, index, head, tail) as (\n      select \n        no,\n        0,\n        null,\n        string_to_array(cells, '|')\n      from columns\n    union all\n      select\n        no,\n        index + 1,\n        tail[1],\n        tail[2 : array_length(tail, 1)]\n      from t\n      where array_length(tail, 1) > 0\n  )\n  select no, index, head from t where index > 0\n);\n```\n\nこうして作られたVIEWの中身を確認すると、文字列関数を組み合わせていたものと同じ結果が得られます。\n\n```\nselect * from cells order by no, index;\n\n no | index | cell\n----+-------+------\n  1 |     1 | 0\n  1 |     2 | col1\n  1 |     3 | col2\n  1 |     4 | col3\n  2 |     1 | 1\n  2 |     2 | col1\n  2 |     3 | col2\n  2 |     4 | col3\n  3 |     1 | 2\n  3 |     2 | col1\n  3 |     3 | col2\n  3 |     4 | col3\n  4 |     1 | 3\n  4 |     2 | col1\n  4 |     3 | col2\n  4 |     4 | col3\n  5 |     1 | 4\n  5 |     2 | col1\n  5 |     3 | col2\n  5 |     4 | col3\n(20 rows)\n```\n\nそもそも配列を利用すればVIEWなどを使わずとも「ずんだの表見出し++問題」を解くことができます。\n\n```sql\nwith t (no, cells) as (\n  select\n    no,\n    string_to_array(cells, '|')\n  from columns\n)\nselect\n  array_to_string((cells[1]::integer + 1)::text || cells[2 : array_length(cells, 1)], '|')\nfrom t\norder by no;\n```\n\nこの実行結果が以下。配列を使わない場合とまったく同じ結果が得られていることが分かります。\n\n```\n array_to_string\n------------------\n 1|col1|col2|col3\n 2|col1|col2|col3\n 3|col1|col2|col3\n 4|col1|col2|col3\n 5|col1|col2|col3\n(5 rows)\n```\n","coediting":false,"comments_count":0,"created_at":"2018-10-24T01:15:19+09:00","group":null,"id":"acc773ef71b3312075e7","likes_count":3,"private":false,"reactions_count":0,"tags":[{"name":"SQL","versions":[]}],"title":"ずんだの表見出し++問題 SQL 編","updated_at":"2018-10-24T01:15:19+09:00","url":"https://qiita.com/neko_the_shadow/items/acc773ef71b3312075e7","user":{"description":"IT業界の片隅でひっそり生きるシステムエンジニアです(´・ω・｀)","facebook_id":"","followees_count":0,"followers_count":36,"github_login_name":null,"id":"neko_the_shadow","items_count":191,"linkedin_id":"","location":"神奈川県川崎市","name":"","organization":"","permanent_id":105859,"profile_image_url":"https://qiita-image-store.s3.amazonaws.com/0/105859/profile-images/1473709753","team_only":false,"twitter_screen_name":"neko_the_shadow","website_url":"https://nekotheshadow.github.io/"},"page_views_count":null,"team_membership":null}