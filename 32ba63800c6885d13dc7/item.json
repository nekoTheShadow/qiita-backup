{"rendered_body":"<p data-sourcepos=\"1:1-1:134\">お仕事の話ですが、次のような要求をJava Parserを用いて実現したので、メモとして残しておきます。</p>\n<ul data-sourcepos=\"3:1-5:0\">\n<li data-sourcepos=\"3:1-3:87\">javaファイルに定義されているクラスとメソッドを一覧化したい</li>\n<li data-sourcepos=\"4:1-5:0\">あわせてそのメソッドが呼び出しているメソッドをメソッドごとに一覧化したい</li>\n</ul>\n<p data-sourcepos=\"6:1-6:324\">以下はjava.util.Properties.javaを対象のソースコードとして、上記の要求を満たすサンプルプログラムです。<a href=\"https://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/util/Properties.java\" rel=\"nofollow noopener\" target=\"_blank\">なお、Properties.javaはopenjdk-jdk11より拝借しています。</a></p>\n<div class=\"code-frame\" data-lang=\"java\" data-sourcepos=\"8:1-33:3\"><div class=\"highlight\"><pre><code><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"nc\">IOException</span> <span class=\"o\">{</span>\n\t<span class=\"nc\">CompilationUnit</span> <span class=\"n\">compilationUnit</span> <span class=\"o\">=</span> <span class=\"nc\">StaticJavaParser</span><span class=\"o\">.</span><span class=\"na\">parse</span><span class=\"o\">(</span><span class=\"nc\">Paths</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"s\">\"Properties.java\"</span><span class=\"o\">));</span>\n\t<span class=\"n\">compilationUnit</span><span class=\"o\">.</span><span class=\"na\">accept</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">ClassOrInterfaceDeclarationVisitor</span><span class=\"o\">(),</span> <span class=\"kc\">null</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">static</span> <span class=\"kd\">class</span> <span class=\"nc\">ClassOrInterfaceDeclarationVisitor</span> <span class=\"kd\">extends</span> <span class=\"nc\">VoidVisitorAdapter</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"o\">{</span>\n\t<span class=\"nd\">@Override</span>\n\t<span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">visit</span><span class=\"o\">(</span><span class=\"nc\">ClassOrInterfaceDeclaration</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"nc\">Void</span> <span class=\"n\">arg</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t<span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">.</span><span class=\"na\">getFullyQualifiedName</span><span class=\"o\">().</span><span class=\"na\">get</span><span class=\"o\">());</span>\n\t\t<span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"nc\">MethodDeclaration</span> <span class=\"n\">md</span> <span class=\"o\">:</span> <span class=\"n\">n</span><span class=\"o\">.</span><span class=\"na\">getMethods</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"\\t\"</span> <span class=\"o\">+</span> <span class=\"n\">md</span><span class=\"o\">.</span><span class=\"na\">getDeclarationAsString</span><span class=\"o\">(</span><span class=\"kc\">true</span><span class=\"o\">,</span> <span class=\"kc\">true</span><span class=\"o\">,</span> <span class=\"kc\">true</span><span class=\"o\">));</span>\n\t\t\t<span class=\"n\">md</span><span class=\"o\">.</span><span class=\"na\">accept</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">MethodCallExprVisitor</span><span class=\"o\">(),</span> <span class=\"kc\">null</span><span class=\"o\">);</span>\n\t\t<span class=\"o\">}</span>\n\t\t<span class=\"kd\">super</span><span class=\"o\">.</span><span class=\"na\">visit</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">arg</span><span class=\"o\">);</span>\n\t<span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">static</span> <span class=\"kd\">class</span> <span class=\"nc\">MethodCallExprVisitor</span> <span class=\"kd\">extends</span> <span class=\"nc\">VoidVisitorAdapter</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"o\">{</span>\n\t<span class=\"nd\">@Override</span>\n\t<span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">visit</span><span class=\"o\">(</span><span class=\"nc\">MethodCallExpr</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"nc\">Void</span> <span class=\"n\">arg</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t<span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"\\t\\t\"</span> <span class=\"o\">+</span> <span class=\"n\">n</span><span class=\"o\">);</span>\n\t\t<span class=\"kd\">super</span><span class=\"o\">.</span><span class=\"na\">visit</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">arg</span><span class=\"o\">);</span>\n\t<span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p data-sourcepos=\"35:1-35:102\">これを実行すると、以下のような結果がコンソールに出力されるはずです。</p>\n<details>\n<summary>長いのでおりたたみ</summary>\n<div class=\"code-frame\" data-lang=\"text\" data-sourcepos=\"40:1-305:3\"><div class=\"highlight\"><pre><code>java.util.Properties\n\tpublic synchronized Object setProperty(String key, String value)\n\t\tput(key, value)\n\tpublic synchronized void load(Reader reader) throws IOException\n\t\tObjects.requireNonNull(reader, \"reader parameter is null\")\n\t\tload0(new LineReader(reader))\n\tpublic synchronized void load(InputStream inStream) throws IOException\n\t\tObjects.requireNonNull(inStream, \"inStream parameter is null\")\n\t\tload0(new LineReader(inStream))\n\tprivate void load0(LineReader lr) throws IOException\n\t\tloadConvert(lr.lineBuf, 0, keyLen, convtBuf)\n\t\tloadConvert(lr.lineBuf, valueStart, limit - valueStart, convtBuf)\n\t\tput(key, value)\n\t\tlr.readLine()\n\tprivate String loadConvert(char[] in, int off, int len, char[] convtBuf)\n\tprivate String saveConvert(String theString, boolean escapeSpace, boolean escapeUnicode)\n\t\ttheString.length()\n\t\ttheString.charAt(x)\n\t\toutBuffer.append('\\\\')\n\t\toutBuffer.append('\\\\')\n\t\toutBuffer.append(aChar)\n\t\toutBuffer.append('\\\\')\n\t\toutBuffer.append(' ')\n\t\toutBuffer.append('\\\\')\n\t\toutBuffer.append('t')\n\t\toutBuffer.append('\\\\')\n\t\toutBuffer.append('n')\n\t\toutBuffer.append('\\\\')\n\t\toutBuffer.append('r')\n\t\toutBuffer.append('\\\\')\n\t\toutBuffer.append('f')\n\t\toutBuffer.append('\\\\')\n\t\toutBuffer.append(aChar)\n\t\toutBuffer.append(aChar)\n\t\toutBuffer.append('\\\\')\n\t\toutBuffer.append('u')\n\t\toutBuffer.append(toHex((aChar &gt;&gt; 12) &amp; 0xF))\n\t\ttoHex((aChar &gt;&gt; 12) &amp; 0xF)\n\t\toutBuffer.append(toHex((aChar &gt;&gt; 8) &amp; 0xF))\n\t\ttoHex((aChar &gt;&gt; 8) &amp; 0xF)\n\t\toutBuffer.append(toHex((aChar &gt;&gt; 4) &amp; 0xF))\n\t\ttoHex((aChar &gt;&gt; 4) &amp; 0xF)\n\t\toutBuffer.append(toHex(aChar &amp; 0xF))\n\t\ttoHex(aChar &amp; 0xF)\n\t\toutBuffer.toString()\n\tprivate static void writeComments(BufferedWriter bw, String comments) throws IOException\n\t\tbw.write(\"#\")\n\t\tcomments.length()\n\t\tcomments.charAt(current)\n\t\tbw.write(comments.substring(last, current))\n\t\tcomments.substring(last, current)\n\t\tbw.newLine()\n\t\tcomments.charAt(current + 1)\n\t\tcomments.charAt(current + 1)\n\t\tcomments.charAt(current + 1)\n\t\tbw.write(\"#\")\n\t\ttoHex((c &gt;&gt; 12) &amp; 0xf)\n\t\ttoHex((c &gt;&gt; 8) &amp; 0xf)\n\t\ttoHex((c &gt;&gt; 4) &amp; 0xf)\n\t\ttoHex(c &amp; 0xf)\n\t\tbw.write(new String(uu))\n\t\tbw.write(comments.substring(last, current))\n\t\tcomments.substring(last, current)\n\t\tbw.newLine()\n\tpublic void save(OutputStream out, String comments)\n\t\tstore(out, comments)\n\tpublic void store(Writer writer, String comments) throws IOException\n\t\tstore0((writer instanceof BufferedWriter) ? (BufferedWriter) writer : new BufferedWriter(writer), comments, false)\n\tpublic void store(OutputStream out, String comments) throws IOException\n\t\tstore0(new BufferedWriter(new OutputStreamWriter(out, \"8859_1\")), comments, true)\n\tprivate void store0(BufferedWriter bw, String comments, boolean escUnicode) throws IOException\n\t\twriteComments(bw, comments)\n\t\tbw.write(\"#\" + new Date().toString())\n\t\tnew Date().toString()\n\t\tbw.newLine()\n\t\te.getKey()\n\t\te.getValue()\n\t\tsaveConvert(key, true, escUnicode)\n\t\tsaveConvert(val, false, escUnicode)\n\t\tbw.write(key + \"=\" + val)\n\t\tbw.newLine()\n\t\tentrySet()\n\t\tbw.flush()\n\tpublic synchronized void loadFromXML(InputStream in) throws IOException, InvalidPropertiesFormatException\n\t\tObjects.requireNonNull(in)\n\t\thandler.load(this, in)\n\t\tin.close()\n\tpublic void storeToXML(OutputStream os, String comment) throws IOException\n\t\tstoreToXML(os, comment, \"UTF-8\")\n\tpublic void storeToXML(OutputStream os, String comment, String encoding) throws IOException\n\t\tObjects.requireNonNull(os)\n\t\tObjects.requireNonNull(encoding)\n\t\tCharset.forName(encoding)\n\t\tstoreToXML(os, comment, charset)\n\tpublic void storeToXML(OutputStream os, String comment, Charset charset) throws IOException\n\t\tObjects.requireNonNull(os, \"OutputStream\")\n\t\tObjects.requireNonNull(charset, \"Charset\")\n\t\thandler.store(this, os, comment, charset)\n\tpublic String getProperty(String key)\n\t\tmap.get(key)\n\t\tdefaults.getProperty(key)\n\tpublic String getProperty(String key, String defaultValue)\n\t\tgetProperty(key)\n\tpublic Enumeration&lt;?&gt; propertyNames()\n\t\tenumerate(h)\n\t\th.keys()\n\tpublic Set&lt;String&gt; stringPropertyNames()\n\t\tenumerateStringProperties(h)\n\t\tCollections.unmodifiableSet(h.keySet())\n\t\th.keySet()\n\tpublic void list(PrintStream out)\n\t\tout.println(\"-- listing properties --\")\n\t\tenumerate(h)\n\t\te.getKey()\n\t\te.getValue()\n\t\tval.length()\n\t\tval.substring(0, 37)\n\t\tout.println(key + \"=\" + val)\n\t\th.entrySet()\n\tpublic void list(PrintWriter out)\n\t\tout.println(\"-- listing properties --\")\n\t\tenumerate(h)\n\t\te.getKey()\n\t\te.getValue()\n\t\tval.length()\n\t\tval.substring(0, 37)\n\t\tout.println(key + \"=\" + val)\n\t\th.entrySet()\n\tprivate void enumerate(Map&lt;String, Object&gt; h)\n\t\tdefaults.enumerate(h)\n\t\te.getKey()\n\t\th.put(key, e.getValue())\n\t\te.getValue()\n\t\tentrySet()\n\tprivate void enumerateStringProperties(Map&lt;String, String&gt; h)\n\t\tdefaults.enumerateStringProperties(h)\n\t\te.getKey()\n\t\te.getValue()\n\t\th.put((String) k, (String) v)\n\t\tentrySet()\n\tprivate static char toHex(int nibble)\n\tpublic int size()\n\t\tmap.size()\n\tpublic boolean isEmpty()\n\t\tmap.isEmpty()\n\tpublic Enumeration&lt;Object&gt; keys()\n\t\tCollections.enumeration(map.keySet())\n\t\tmap.keySet()\n\tpublic Enumeration&lt;Object&gt; elements()\n\t\tCollections.enumeration(map.values())\n\t\tmap.values()\n\tpublic boolean contains(Object value)\n\t\tmap.contains(value)\n\tpublic boolean containsValue(Object value)\n\t\tmap.containsValue(value)\n\tpublic boolean containsKey(Object key)\n\t\tmap.containsKey(key)\n\tpublic Object get(Object key)\n\t\tmap.get(key)\n\tpublic synchronized Object put(Object key, Object value)\n\t\tmap.put(key, value)\n\tpublic synchronized Object remove(Object key)\n\t\tmap.remove(key)\n\tpublic synchronized void putAll(Map&lt;?, ?&gt; t)\n\t\tmap.putAll(t)\n\tpublic synchronized void clear()\n\t\tmap.clear()\n\tpublic synchronized String toString()\n\t\tmap.toString()\n\tpublic Set&lt;Object&gt; keySet()\n\t\tCollections.synchronizedSet(map.keySet(), this)\n\t\tmap.keySet()\n\tpublic Collection&lt;Object&gt; values()\n\t\tCollections.synchronizedCollection(map.values(), this)\n\t\tmap.values()\n\tpublic Set&lt;Map.Entry&lt;Object, Object&gt;&gt; entrySet()\n\t\tCollections.synchronizedSet(new EntrySet(map.entrySet()), this)\n\t\tmap.entrySet()\n\tpublic synchronized boolean equals(Object o)\n\t\tmap.equals(o)\n\tpublic synchronized int hashCode()\n\t\tmap.hashCode()\n\tpublic Object getOrDefault(Object key, Object defaultValue)\n\t\tmap.getOrDefault(key, defaultValue)\n\tpublic synchronized void forEach(BiConsumer&lt;? super Object, ? super Object&gt; action)\n\t\tmap.forEach(action)\n\tpublic synchronized void replaceAll(BiFunction&lt;? super Object, ? super Object, ?&gt; function)\n\t\tmap.replaceAll(function)\n\tpublic synchronized Object putIfAbsent(Object key, Object value)\n\t\tmap.putIfAbsent(key, value)\n\tpublic synchronized boolean remove(Object key, Object value)\n\t\tmap.remove(key, value)\n\tpublic synchronized boolean replace(Object key, Object oldValue, Object newValue)\n\t\tmap.replace(key, oldValue, newValue)\n\tpublic synchronized Object replace(Object key, Object value)\n\t\tmap.replace(key, value)\n\tpublic synchronized Object computeIfAbsent(Object key, Function&lt;? super Object, ?&gt; mappingFunction)\n\t\tmap.computeIfAbsent(key, mappingFunction)\n\tpublic synchronized Object computeIfPresent(Object key, BiFunction&lt;? super Object, ? super Object, ?&gt; remappingFunction)\n\t\tmap.computeIfPresent(key, remappingFunction)\n\tpublic synchronized Object compute(Object key, BiFunction&lt;? super Object, ? super Object, ?&gt; remappingFunction)\n\t\tmap.compute(key, remappingFunction)\n\tpublic synchronized Object merge(Object key, Object value, BiFunction&lt;? super Object, ? super Object, ?&gt; remappingFunction)\n\t\tmap.merge(key, value, remappingFunction)\n\tprotected void rehash()\n\tpublic synchronized Object clone()\n\t\tcloneHashtable()\n\t void writeHashtable(ObjectOutputStream s) throws IOException\n\t\tmap.size()\n\t\tentryStack.add(entry.getValue())\n\t\tentry.getValue()\n\t\tentryStack.add(entry.getKey())\n\t\tentry.getKey()\n\t\tmap.entrySet()\n\t\tentryStack.size()\n\t\tdefaultWriteHashtable(s, length, loadFactor)\n\t\ts.writeInt(length)\n\t\ts.writeInt(count)\n\t\ts.writeObject(entryStack.get(i))\n\t\tentryStack.get(i)\n\t\tentryStack.size()\n\t void readHashtable(ObjectInputStream s) throws IOException, ClassNotFoundException\n\t\ts.defaultReadObject()\n\t\ts.readInt()\n\t\ts.readInt()\n\t\tSharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Map.Entry[].class, HashMap.tableSizeFor((int) (elements / 0.75)))\n\t\tHashMap.tableSizeFor((int) (elements / 0.75))\n\t\tSharedSecrets.getJavaObjectInputStreamAccess()\n\t\ts.readObject()\n\t\ts.readObject()\n\t\tmap.put(key, value)\njava.util.Properties.LineReader\n\t int readLine() throws IOException\n\t\tinStream.read(inByteBuf)\n\t\treader.read(inCharBuf)\n\t\tinStream.read(inByteBuf)\n\t\treader.read(inCharBuf)\n\t\tSystem.arraycopy(lineBuf, 0, buf, 0, lineBuf.length)\njava.util.Properties.EntrySet\n\tpublic int size()\n\t\tentrySet.size()\n\tpublic boolean isEmpty()\n\t\tentrySet.isEmpty()\n\tpublic boolean contains(Object o)\n\t\tentrySet.contains(o)\n\tpublic Object[] toArray()\n\t\tentrySet.toArray()\n\tpublic T[] toArray(T[] a)\n\t\tentrySet.toArray(a)\n\tpublic void clear()\n\t\tentrySet.clear()\n\tpublic boolean remove(Object o)\n\t\tentrySet.remove(o)\n\tpublic boolean add(Map.Entry&lt;Object, Object&gt; e)\n\tpublic boolean addAll(Collection&lt;? extends Map.Entry&lt;Object, Object&gt;&gt; c)\n\tpublic boolean containsAll(Collection&lt;?&gt; c)\n\t\tentrySet.containsAll(c)\n\tpublic boolean removeAll(Collection&lt;?&gt; c)\n\t\tentrySet.removeAll(c)\n\tpublic boolean retainAll(Collection&lt;?&gt; c)\n\t\tentrySet.retainAll(c)\n\tpublic Iterator&lt;Map.Entry&lt;Object, Object&gt;&gt; iterator()\n\t\tentrySet.iterator()\n\n</code></pre></div></div>\n</details>\n<p data-sourcepos=\"308:1-308:115\">サンプリングでチェックしてみましょう。storeToXMLメソッドの実装は以下の通りです。</p>\n<div class=\"code-frame\" data-lang=\"java\" data-sourcepos=\"310:1-323:3\"><div class=\"highlight\"><pre><code><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">storeToXML</span><span class=\"o\">(</span><span class=\"nc\">OutputStream</span> <span class=\"n\">os</span><span class=\"o\">,</span> <span class=\"nc\">String</span> <span class=\"n\">comment</span><span class=\"o\">,</span> <span class=\"nc\">String</span> <span class=\"n\">encoding</span><span class=\"o\">)</span>\n    <span class=\"kd\">throws</span> <span class=\"nc\">IOException</span> <span class=\"o\">{</span>\n    <span class=\"nc\">Objects</span><span class=\"o\">.</span><span class=\"na\">requireNonNull</span><span class=\"o\">(</span><span class=\"n\">os</span><span class=\"o\">);</span>\n    <span class=\"nc\">Objects</span><span class=\"o\">.</span><span class=\"na\">requireNonNull</span><span class=\"o\">(</span><span class=\"n\">encoding</span><span class=\"o\">);</span>\n\n    <span class=\"k\">try</span> <span class=\"o\">{</span>\n        <span class=\"nc\">Charset</span> <span class=\"n\">charset</span> <span class=\"o\">=</span> <span class=\"nc\">Charset</span><span class=\"o\">.</span><span class=\"na\">forName</span><span class=\"o\">(</span><span class=\"n\">encoding</span><span class=\"o\">);</span>\n        <span class=\"n\">storeToXML</span><span class=\"o\">(</span><span class=\"n\">os</span><span class=\"o\">,</span> <span class=\"n\">comment</span><span class=\"o\">,</span> <span class=\"n\">charset</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">IllegalCharsetNameException</span> <span class=\"o\">|</span> <span class=\"nc\">UnsupportedCharsetException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"nf\">UnsupportedEncodingException</span><span class=\"o\">(</span><span class=\"n\">encoding</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p data-sourcepos=\"325:1-325:60\">これに対応する解析結果は以下の通りです。</p>\n<div class=\"code-frame\" data-lang=\"text\" data-sourcepos=\"327:1-333:3\"><div class=\"highlight\"><pre><code>public void storeToXML(OutputStream os, String comment, String encoding) throws IOException\n\tObjects.requireNonNull(os)\n\tObjects.requireNonNull(encoding)\n\tCharset.forName(encoding)\n\tstoreToXML(os, comment, charset)\n</code></pre></div></div>\n<p data-sourcepos=\"335:1-335:48\">ただしく解析できていそうですね。</p>\n<p data-sourcepos=\"337:1-337:26\"><strong>環境 : pom.xml抜粋</strong></p>\n<div class=\"code-frame\" data-lang=\"xml\" data-sourcepos=\"339:1-351:3\"><div class=\"highlight\"><pre><code><span class=\"nt\">&lt;properties&gt;</span>\n  <span class=\"nt\">&lt;maven.compiler.target&gt;</span>11<span class=\"nt\">&lt;/maven.compiler.target&gt;</span>\n  <span class=\"nt\">&lt;maven.compiler.source&gt;</span>11<span class=\"nt\">&lt;/maven.compiler.source&gt;</span>\n<span class=\"nt\">&lt;/properties&gt;</span>\n<span class=\"nt\">&lt;dependencies&gt;</span>\n  <span class=\"nt\">&lt;dependency&gt;</span>\n    <span class=\"nt\">&lt;groupId&gt;</span>com.github.javaparser<span class=\"nt\">&lt;/groupId&gt;</span>\n    <span class=\"nt\">&lt;artifactId&gt;</span>javaparser-core<span class=\"nt\">&lt;/artifactId&gt;</span>\n    <span class=\"nt\">&lt;version&gt;</span>3.25.4<span class=\"nt\">&lt;/version&gt;</span>\n  <span class=\"nt\">&lt;/dependency&gt;</span>\n<span class=\"nt\">&lt;/dependencies&gt;</span>\n</code></pre></div></div>\n","body":"お仕事の話ですが、次のような要求をJava Parserを用いて実現したので、メモとして残しておきます。\n\n- javaファイルに定義されているクラスとメソッドを一覧化したい\n- あわせてそのメソッドが呼び出しているメソッドをメソッドごとに一覧化したい\n\n以下はjava.util.Properties.javaを対象のソースコードとして、上記の要求を満たすサンプルプログラムです。[なお、Properties.javaはopenjdk-jdk11より拝借しています。](https://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/util/Properties.java)\n\n```java\npublic static void main(String[] args) throws IOException {\n\tCompilationUnit compilationUnit = StaticJavaParser.parse(Paths.get(\"Properties.java\"));\n\tcompilationUnit.accept(new ClassOrInterfaceDeclarationVisitor(), null);\n}\n\nstatic class ClassOrInterfaceDeclarationVisitor extends VoidVisitorAdapter<Void> {\n\t@Override\n\tpublic void visit(ClassOrInterfaceDeclaration n, Void arg) {\n\t\tSystem.out.println(n.getFullyQualifiedName().get());\n\t\tfor (MethodDeclaration md : n.getMethods()) {\n\t\t\tSystem.out.println(\"\\t\" + md.getDeclarationAsString(true, true, true));\n\t\t\tmd.accept(new MethodCallExprVisitor(), null);\n\t\t}\n\t\tsuper.visit(n, arg);\n\t}\n}\n\nstatic class MethodCallExprVisitor extends VoidVisitorAdapter<Void> {\n\t@Override\n\tpublic void visit(MethodCallExpr n, Void arg) {\n\t\tSystem.out.println(\"\\t\\t\" + n);\n\t\tsuper.visit(n, arg);\n\t}\n}\n```\n\nこれを実行すると、以下のような結果がコンソールに出力されるはずです。\n\n<details>\n<summary>長いのでおりたたみ</summary>\n\n```\njava.util.Properties\n\tpublic synchronized Object setProperty(String key, String value)\n\t\tput(key, value)\n\tpublic synchronized void load(Reader reader) throws IOException\n\t\tObjects.requireNonNull(reader, \"reader parameter is null\")\n\t\tload0(new LineReader(reader))\n\tpublic synchronized void load(InputStream inStream) throws IOException\n\t\tObjects.requireNonNull(inStream, \"inStream parameter is null\")\n\t\tload0(new LineReader(inStream))\n\tprivate void load0(LineReader lr) throws IOException\n\t\tloadConvert(lr.lineBuf, 0, keyLen, convtBuf)\n\t\tloadConvert(lr.lineBuf, valueStart, limit - valueStart, convtBuf)\n\t\tput(key, value)\n\t\tlr.readLine()\n\tprivate String loadConvert(char[] in, int off, int len, char[] convtBuf)\n\tprivate String saveConvert(String theString, boolean escapeSpace, boolean escapeUnicode)\n\t\ttheString.length()\n\t\ttheString.charAt(x)\n\t\toutBuffer.append('\\\\')\n\t\toutBuffer.append('\\\\')\n\t\toutBuffer.append(aChar)\n\t\toutBuffer.append('\\\\')\n\t\toutBuffer.append(' ')\n\t\toutBuffer.append('\\\\')\n\t\toutBuffer.append('t')\n\t\toutBuffer.append('\\\\')\n\t\toutBuffer.append('n')\n\t\toutBuffer.append('\\\\')\n\t\toutBuffer.append('r')\n\t\toutBuffer.append('\\\\')\n\t\toutBuffer.append('f')\n\t\toutBuffer.append('\\\\')\n\t\toutBuffer.append(aChar)\n\t\toutBuffer.append(aChar)\n\t\toutBuffer.append('\\\\')\n\t\toutBuffer.append('u')\n\t\toutBuffer.append(toHex((aChar >> 12) & 0xF))\n\t\ttoHex((aChar >> 12) & 0xF)\n\t\toutBuffer.append(toHex((aChar >> 8) & 0xF))\n\t\ttoHex((aChar >> 8) & 0xF)\n\t\toutBuffer.append(toHex((aChar >> 4) & 0xF))\n\t\ttoHex((aChar >> 4) & 0xF)\n\t\toutBuffer.append(toHex(aChar & 0xF))\n\t\ttoHex(aChar & 0xF)\n\t\toutBuffer.toString()\n\tprivate static void writeComments(BufferedWriter bw, String comments) throws IOException\n\t\tbw.write(\"#\")\n\t\tcomments.length()\n\t\tcomments.charAt(current)\n\t\tbw.write(comments.substring(last, current))\n\t\tcomments.substring(last, current)\n\t\tbw.newLine()\n\t\tcomments.charAt(current + 1)\n\t\tcomments.charAt(current + 1)\n\t\tcomments.charAt(current + 1)\n\t\tbw.write(\"#\")\n\t\ttoHex((c >> 12) & 0xf)\n\t\ttoHex((c >> 8) & 0xf)\n\t\ttoHex((c >> 4) & 0xf)\n\t\ttoHex(c & 0xf)\n\t\tbw.write(new String(uu))\n\t\tbw.write(comments.substring(last, current))\n\t\tcomments.substring(last, current)\n\t\tbw.newLine()\n\tpublic void save(OutputStream out, String comments)\n\t\tstore(out, comments)\n\tpublic void store(Writer writer, String comments) throws IOException\n\t\tstore0((writer instanceof BufferedWriter) ? (BufferedWriter) writer : new BufferedWriter(writer), comments, false)\n\tpublic void store(OutputStream out, String comments) throws IOException\n\t\tstore0(new BufferedWriter(new OutputStreamWriter(out, \"8859_1\")), comments, true)\n\tprivate void store0(BufferedWriter bw, String comments, boolean escUnicode) throws IOException\n\t\twriteComments(bw, comments)\n\t\tbw.write(\"#\" + new Date().toString())\n\t\tnew Date().toString()\n\t\tbw.newLine()\n\t\te.getKey()\n\t\te.getValue()\n\t\tsaveConvert(key, true, escUnicode)\n\t\tsaveConvert(val, false, escUnicode)\n\t\tbw.write(key + \"=\" + val)\n\t\tbw.newLine()\n\t\tentrySet()\n\t\tbw.flush()\n\tpublic synchronized void loadFromXML(InputStream in) throws IOException, InvalidPropertiesFormatException\n\t\tObjects.requireNonNull(in)\n\t\thandler.load(this, in)\n\t\tin.close()\n\tpublic void storeToXML(OutputStream os, String comment) throws IOException\n\t\tstoreToXML(os, comment, \"UTF-8\")\n\tpublic void storeToXML(OutputStream os, String comment, String encoding) throws IOException\n\t\tObjects.requireNonNull(os)\n\t\tObjects.requireNonNull(encoding)\n\t\tCharset.forName(encoding)\n\t\tstoreToXML(os, comment, charset)\n\tpublic void storeToXML(OutputStream os, String comment, Charset charset) throws IOException\n\t\tObjects.requireNonNull(os, \"OutputStream\")\n\t\tObjects.requireNonNull(charset, \"Charset\")\n\t\thandler.store(this, os, comment, charset)\n\tpublic String getProperty(String key)\n\t\tmap.get(key)\n\t\tdefaults.getProperty(key)\n\tpublic String getProperty(String key, String defaultValue)\n\t\tgetProperty(key)\n\tpublic Enumeration<?> propertyNames()\n\t\tenumerate(h)\n\t\th.keys()\n\tpublic Set<String> stringPropertyNames()\n\t\tenumerateStringProperties(h)\n\t\tCollections.unmodifiableSet(h.keySet())\n\t\th.keySet()\n\tpublic void list(PrintStream out)\n\t\tout.println(\"-- listing properties --\")\n\t\tenumerate(h)\n\t\te.getKey()\n\t\te.getValue()\n\t\tval.length()\n\t\tval.substring(0, 37)\n\t\tout.println(key + \"=\" + val)\n\t\th.entrySet()\n\tpublic void list(PrintWriter out)\n\t\tout.println(\"-- listing properties --\")\n\t\tenumerate(h)\n\t\te.getKey()\n\t\te.getValue()\n\t\tval.length()\n\t\tval.substring(0, 37)\n\t\tout.println(key + \"=\" + val)\n\t\th.entrySet()\n\tprivate void enumerate(Map<String, Object> h)\n\t\tdefaults.enumerate(h)\n\t\te.getKey()\n\t\th.put(key, e.getValue())\n\t\te.getValue()\n\t\tentrySet()\n\tprivate void enumerateStringProperties(Map<String, String> h)\n\t\tdefaults.enumerateStringProperties(h)\n\t\te.getKey()\n\t\te.getValue()\n\t\th.put((String) k, (String) v)\n\t\tentrySet()\n\tprivate static char toHex(int nibble)\n\tpublic int size()\n\t\tmap.size()\n\tpublic boolean isEmpty()\n\t\tmap.isEmpty()\n\tpublic Enumeration<Object> keys()\n\t\tCollections.enumeration(map.keySet())\n\t\tmap.keySet()\n\tpublic Enumeration<Object> elements()\n\t\tCollections.enumeration(map.values())\n\t\tmap.values()\n\tpublic boolean contains(Object value)\n\t\tmap.contains(value)\n\tpublic boolean containsValue(Object value)\n\t\tmap.containsValue(value)\n\tpublic boolean containsKey(Object key)\n\t\tmap.containsKey(key)\n\tpublic Object get(Object key)\n\t\tmap.get(key)\n\tpublic synchronized Object put(Object key, Object value)\n\t\tmap.put(key, value)\n\tpublic synchronized Object remove(Object key)\n\t\tmap.remove(key)\n\tpublic synchronized void putAll(Map<?, ?> t)\n\t\tmap.putAll(t)\n\tpublic synchronized void clear()\n\t\tmap.clear()\n\tpublic synchronized String toString()\n\t\tmap.toString()\n\tpublic Set<Object> keySet()\n\t\tCollections.synchronizedSet(map.keySet(), this)\n\t\tmap.keySet()\n\tpublic Collection<Object> values()\n\t\tCollections.synchronizedCollection(map.values(), this)\n\t\tmap.values()\n\tpublic Set<Map.Entry<Object, Object>> entrySet()\n\t\tCollections.synchronizedSet(new EntrySet(map.entrySet()), this)\n\t\tmap.entrySet()\n\tpublic synchronized boolean equals(Object o)\n\t\tmap.equals(o)\n\tpublic synchronized int hashCode()\n\t\tmap.hashCode()\n\tpublic Object getOrDefault(Object key, Object defaultValue)\n\t\tmap.getOrDefault(key, defaultValue)\n\tpublic synchronized void forEach(BiConsumer<? super Object, ? super Object> action)\n\t\tmap.forEach(action)\n\tpublic synchronized void replaceAll(BiFunction<? super Object, ? super Object, ?> function)\n\t\tmap.replaceAll(function)\n\tpublic synchronized Object putIfAbsent(Object key, Object value)\n\t\tmap.putIfAbsent(key, value)\n\tpublic synchronized boolean remove(Object key, Object value)\n\t\tmap.remove(key, value)\n\tpublic synchronized boolean replace(Object key, Object oldValue, Object newValue)\n\t\tmap.replace(key, oldValue, newValue)\n\tpublic synchronized Object replace(Object key, Object value)\n\t\tmap.replace(key, value)\n\tpublic synchronized Object computeIfAbsent(Object key, Function<? super Object, ?> mappingFunction)\n\t\tmap.computeIfAbsent(key, mappingFunction)\n\tpublic synchronized Object computeIfPresent(Object key, BiFunction<? super Object, ? super Object, ?> remappingFunction)\n\t\tmap.computeIfPresent(key, remappingFunction)\n\tpublic synchronized Object compute(Object key, BiFunction<? super Object, ? super Object, ?> remappingFunction)\n\t\tmap.compute(key, remappingFunction)\n\tpublic synchronized Object merge(Object key, Object value, BiFunction<? super Object, ? super Object, ?> remappingFunction)\n\t\tmap.merge(key, value, remappingFunction)\n\tprotected void rehash()\n\tpublic synchronized Object clone()\n\t\tcloneHashtable()\n\t void writeHashtable(ObjectOutputStream s) throws IOException\n\t\tmap.size()\n\t\tentryStack.add(entry.getValue())\n\t\tentry.getValue()\n\t\tentryStack.add(entry.getKey())\n\t\tentry.getKey()\n\t\tmap.entrySet()\n\t\tentryStack.size()\n\t\tdefaultWriteHashtable(s, length, loadFactor)\n\t\ts.writeInt(length)\n\t\ts.writeInt(count)\n\t\ts.writeObject(entryStack.get(i))\n\t\tentryStack.get(i)\n\t\tentryStack.size()\n\t void readHashtable(ObjectInputStream s) throws IOException, ClassNotFoundException\n\t\ts.defaultReadObject()\n\t\ts.readInt()\n\t\ts.readInt()\n\t\tSharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Map.Entry[].class, HashMap.tableSizeFor((int) (elements / 0.75)))\n\t\tHashMap.tableSizeFor((int) (elements / 0.75))\n\t\tSharedSecrets.getJavaObjectInputStreamAccess()\n\t\ts.readObject()\n\t\ts.readObject()\n\t\tmap.put(key, value)\njava.util.Properties.LineReader\n\t int readLine() throws IOException\n\t\tinStream.read(inByteBuf)\n\t\treader.read(inCharBuf)\n\t\tinStream.read(inByteBuf)\n\t\treader.read(inCharBuf)\n\t\tSystem.arraycopy(lineBuf, 0, buf, 0, lineBuf.length)\njava.util.Properties.EntrySet\n\tpublic int size()\n\t\tentrySet.size()\n\tpublic boolean isEmpty()\n\t\tentrySet.isEmpty()\n\tpublic boolean contains(Object o)\n\t\tentrySet.contains(o)\n\tpublic Object[] toArray()\n\t\tentrySet.toArray()\n\tpublic T[] toArray(T[] a)\n\t\tentrySet.toArray(a)\n\tpublic void clear()\n\t\tentrySet.clear()\n\tpublic boolean remove(Object o)\n\t\tentrySet.remove(o)\n\tpublic boolean add(Map.Entry<Object, Object> e)\n\tpublic boolean addAll(Collection<? extends Map.Entry<Object, Object>> c)\n\tpublic boolean containsAll(Collection<?> c)\n\t\tentrySet.containsAll(c)\n\tpublic boolean removeAll(Collection<?> c)\n\t\tentrySet.removeAll(c)\n\tpublic boolean retainAll(Collection<?> c)\n\t\tentrySet.retainAll(c)\n\tpublic Iterator<Map.Entry<Object, Object>> iterator()\n\t\tentrySet.iterator()\n\n```\n</details>\n\nサンプリングでチェックしてみましょう。storeToXMLメソッドの実装は以下の通りです。\n\n```java\npublic void storeToXML(OutputStream os, String comment, String encoding)\n    throws IOException {\n    Objects.requireNonNull(os);\n    Objects.requireNonNull(encoding);\n\n    try {\n        Charset charset = Charset.forName(encoding);\n        storeToXML(os, comment, charset);\n    } catch (IllegalCharsetNameException | UnsupportedCharsetException e) {\n        throw new UnsupportedEncodingException(encoding);\n    }\n}\n```\n\nこれに対応する解析結果は以下の通りです。\n\n```\npublic void storeToXML(OutputStream os, String comment, String encoding) throws IOException\n\tObjects.requireNonNull(os)\n\tObjects.requireNonNull(encoding)\n\tCharset.forName(encoding)\n\tstoreToXML(os, comment, charset)\n```\n\nただしく解析できていそうですね。\n\n**環境 : pom.xml抜粋**\n\n```xml\n<properties>\n  <maven.compiler.target>11</maven.compiler.target>\n  <maven.compiler.source>11</maven.compiler.source>\n</properties>\n<dependencies>\n  <dependency>\n    <groupId>com.github.javaparser</groupId>\n    <artifactId>javaparser-core</artifactId>\n    <version>3.25.4</version>\n  </dependency>\n</dependencies>\n```\n","coediting":false,"comments_count":0,"created_at":"2023-08-17T22:38:40+09:00","group":null,"id":"32ba63800c6885d13dc7","likes_count":1,"private":false,"reactions_count":0,"stocks_count":1,"tags":[{"name":"Java","versions":[]}],"title":"ソースコード上のクラスとメソッドを一覧化したい & メソッドが呼び出しているメソッドを一覧化したい (Java Parser)","updated_at":"2023-08-25T23:23:58+09:00","url":"https://qiita.com/neko_the_shadow/items/32ba63800c6885d13dc7","user":{"description":"IT業界の片隅でひっそり生きるシステムエンジニアです(´・ω・｀)","facebook_id":"","followees_count":0,"followers_count":38,"github_login_name":"nekoTheShadow","id":"neko_the_shadow","items_count":224,"linkedin_id":"","location":"神奈川県川崎市","name":"","organization":"","permanent_id":105859,"profile_image_url":"https://qiita-image-store.s3.amazonaws.com/0/105859/profile-images/1473709753","team_only":false,"twitter_screen_name":"neko_the_shadow","website_url":"https://github.com/nekoTheShadow"},"page_views_count":438,"team_membership":null,"organization_url_name":null,"slide":false}