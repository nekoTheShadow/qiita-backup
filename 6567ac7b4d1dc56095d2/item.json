{"rendered_body":"<p><strong><em>以下の内容はRuby2.2.3/Windows10で検証したものです。したがって違うバージョンやOSではまったく違う挙動を示す可能性があります。また既知の内容であればすみません……。</em></strong></p>\n\n<h1>\n<span id=\"今北産業\" class=\"fragment\"></span><a href=\"#%E4%BB%8A%E5%8C%97%E7%94%A3%E6%A5%AD\"><i class=\"fa fa-link\"></i></a>今北産業</h1>\n\n<p>以下のようなコードはエラーも警告もでないので、個人的にはとても気を付けております。</p>\n\n<div class=\"code-frame\" data-lang=\"rb\"><div class=\"highlight\"><pre><code><span class=\"c1\"># 上限が文字列でもエラーにならない!</span>\n<span class=\"n\">g</span> <span class=\"o\">=</span> <span class=\"no\">Prime</span><span class=\"o\">::</span><span class=\"no\">EratosthenesGenerator</span><span class=\"p\">.</span><span class=\"nf\">new</span>\n<span class=\"n\">g</span><span class=\"p\">.</span><span class=\"nf\">upper_bound</span> <span class=\"o\">=</span> <span class=\"s2\">\"foo\"</span>\n\n<span class=\"c1\"># Prime#eachがジェネレータの上限を置き換えている!</span>\n<span class=\"no\">Prime</span><span class=\"p\">.</span><span class=\"nf\">each</span><span class=\"p\">(</span><span class=\"s2\">\"hoge\"</span><span class=\"p\">,</span> <span class=\"n\">g</span><span class=\"p\">)</span>\n<span class=\"nb\">p</span> <span class=\"n\">g</span><span class=\"p\">.</span><span class=\"nf\">upper_bound</span> <span class=\"c1\">#=&gt; \"hoge\"</span>\n\n<span class=\"c1\"># 上限が文字列にも関わらず普通に素数が生成できている!</span>\n<span class=\"n\">arr</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n<span class=\"mi\">10</span><span class=\"p\">.</span><span class=\"nf\">times</span><span class=\"p\">{</span><span class=\"n\">arr</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">g</span><span class=\"p\">.</span><span class=\"nf\">next</span><span class=\"p\">}</span>\n<span class=\"nb\">p</span> <span class=\"n\">arr</span> <span class=\"c1\">#=&gt; [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]</span>\n\n<span class=\"c1\"># 上限を数字に変えてみたものの、上限以上の素数を生成している!</span>\n<span class=\"n\">g</span><span class=\"p\">.</span><span class=\"nf\">upper_bound</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>\n<span class=\"n\">arr</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n<span class=\"mi\">10</span><span class=\"p\">.</span><span class=\"nf\">times</span><span class=\"p\">{</span><span class=\"n\">arr</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">g</span><span class=\"p\">.</span><span class=\"nf\">next</span><span class=\"p\">}</span>\n<span class=\"nb\">p</span> <span class=\"n\">arr</span> <span class=\"c1\">#=&gt; [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]</span>\n<span class=\"nb\">p</span> <span class=\"n\">g</span><span class=\"p\">.</span><span class=\"nf\">upper_bound</span> <span class=\"c1\">#=&gt; 10</span>\n\n<span class=\"c1\"># Prime#eachを利用してもダメでした……</span>\n<span class=\"n\">primes</span> <span class=\"o\">=</span> <span class=\"no\">Prime</span><span class=\"p\">.</span><span class=\"nf\">each</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"n\">arr</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n<span class=\"mi\">10</span><span class=\"p\">.</span><span class=\"nf\">times</span><span class=\"p\">{</span><span class=\"n\">arr</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">primes</span><span class=\"p\">.</span><span class=\"nf\">next</span><span class=\"p\">}</span>\n<span class=\"nb\">p</span> <span class=\"n\">arr</span> <span class=\"c1\">#=&gt; [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]</span>\n</code></pre></div></div>\n\n<h1>\n<span id=\"primeeachは不用意に使わない\" class=\"fragment\"></span><a href=\"#primeeach%E3%81%AF%E4%B8%8D%E7%94%A8%E6%84%8F%E3%81%AB%E4%BD%BF%E3%82%8F%E3%81%AA%E3%81%84\"><i class=\"fa fa-link\"></i></a><code>Prime#each</code>は不用意に使わない</h1>\n\n<p>正直なところ使われる機会は多くないと思いますが、<code>Prime::PseudoPrimeGenerator</code>クラスには<code>upper_bound</code>および<code>upper_bound=</code>というメソッドが定義されており、素数の生成上限を取得設定することができます。実際的な素数生成にあたって利用する<code>Prime::EratosthenesGenerator</code>クラスなどは<code>Prime::PseudoPrimeGenerator</code>クラスのインスタンスなので、当然<code>upper_bound=</code>を呼び出して生成上限を設定することができます。</p>\n\n<div class=\"code-frame\" data-lang=\"rb\"><div class=\"highlight\"><pre><code><span class=\"nb\">require</span> <span class=\"s2\">\"prime\"</span>\n\n<span class=\"n\">g</span> <span class=\"o\">=</span> <span class=\"no\">Prime</span><span class=\"o\">::</span><span class=\"no\">EratosthenesGenerator</span><span class=\"p\">.</span><span class=\"nf\">new</span>\n<span class=\"n\">g</span><span class=\"p\">.</span><span class=\"nf\">upper_bound</span> <span class=\"o\">=</span> <span class=\"mi\">20</span>\n<span class=\"nb\">p</span> <span class=\"n\">g</span><span class=\"p\">.</span><span class=\"nf\">each</span><span class=\"p\">.</span><span class=\"nf\">to_a</span> <span class=\"c1\">#=&gt; [2, 3, 5, 7, 11, 13, 17, 19]</span>\n\n<span class=\"c1\"># 上限を設定しない場合 = upper_boundにnilを指定する場合</span>\n<span class=\"c1\"># 素数を無限に生成し続けるので、処理が終わらない</span>\n<span class=\"n\">g</span><span class=\"p\">.</span><span class=\"nf\">upper_bound</span> <span class=\"o\">=</span> <span class=\"kp\">nil</span>\n<span class=\"nb\">p</span> <span class=\"n\">g</span><span class=\"p\">.</span><span class=\"nf\">each</span><span class=\"p\">.</span><span class=\"nf\">to_a</span>\n</code></pre></div></div>\n\n<p>さてとりわけよく使われる<code>Prime#each</code>メソッドは生成上限とジェネレータの種類を指定して素数生成することができますが、このときジェネレータにも上限が設定されていた場合どうなるでしょうか?</p>\n\n<div class=\"code-frame\" data-lang=\"rb\"><div class=\"highlight\"><pre><code><span class=\"n\">g</span> <span class=\"o\">=</span> <span class=\"no\">Prime</span><span class=\"o\">::</span><span class=\"no\">EratosthenesGenerator</span><span class=\"p\">.</span><span class=\"nf\">new</span>\n<span class=\"n\">g</span><span class=\"p\">.</span><span class=\"nf\">upper_bound</span> <span class=\"o\">=</span> <span class=\"mi\">20</span>\n\n<span class=\"nb\">p</span> <span class=\"no\">Prime</span><span class=\"p\">.</span><span class=\"nf\">each</span><span class=\"p\">(</span><span class=\"mi\">30</span><span class=\"p\">,</span> <span class=\"n\">g</span><span class=\"p\">).</span><span class=\"nf\">to_a</span> <span class=\"c1\">#=&gt; [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]</span>\n<span class=\"nb\">p</span> <span class=\"n\">g</span><span class=\"p\">.</span><span class=\"nf\">upper_bound</span> <span class=\"c1\">#=&gt; 30</span>\n</code></pre></div></div>\n\n<p><strong>端的にいうと<code>Prime#each</code>はとくに警告などなくジェネレータ側の上限を書き換えてしまいます。</strong>ライブラリのソースコードを見たところ、内部的には<code>Prime#each</code>はそのジェネレータに対して<code>upper_bound=</code>を呼び出したのち、<code>Prime::PseudoPrimeGenerator#each</code>を利用して素数を生成するので、書き換えられてしまうということでした。</p>\n\n<h1>\n<span id=\"upper_boundは不用意に使わない\" class=\"fragment\"></span><a href=\"#upper_bound%E3%81%AF%E4%B8%8D%E7%94%A8%E6%84%8F%E3%81%AB%E4%BD%BF%E3%82%8F%E3%81%AA%E3%81%84\"><i class=\"fa fa-link\"></i></a><code>upper_bound=</code>は不用意に使わない</h1>\n\n<p><code>Prime#each</code>が<code>upper_bound=</code>を呼び出すので書き換えられてしまうと述べましたが、この<code>upper_bound=</code>もまた曲者で、とくに入力バリデーションのようなことは行いません。<strong>つまり与えられたデータが数値なのかどうかを判定せず、そのまま保持してしまうのです。</strong></p>\n\n<div class=\"code-frame\" data-lang=\"rb\"><div class=\"highlight\"><pre><code><span class=\"n\">g</span> <span class=\"o\">=</span> <span class=\"no\">Prime</span><span class=\"o\">::</span><span class=\"no\">EratosthenesGenerator</span><span class=\"p\">.</span><span class=\"nf\">new</span>\n\n<span class=\"n\">g</span><span class=\"p\">.</span><span class=\"nf\">upper_bound</span> <span class=\"o\">=</span> <span class=\"kp\">false</span> <span class=\"c1\"># 問題なく代入できる</span>\n<span class=\"nb\">p</span> <span class=\"n\">g</span><span class=\"p\">.</span><span class=\"nf\">each</span><span class=\"p\">.</span><span class=\"nf\">to_a</span> <span class=\"c1\"># 処理が終わらない</span>\n\n<span class=\"n\">g</span><span class=\"p\">.</span><span class=\"nf\">upper_bound</span> <span class=\"o\">=</span> <span class=\"s2\">\"123\"</span>\n<span class=\"nb\">p</span> <span class=\"n\">g</span><span class=\"p\">.</span><span class=\"nf\">each</span><span class=\"p\">.</span><span class=\"nf\">to_a</span> <span class=\"c1\"># エラー</span>\n</code></pre></div></div>\n\n<p><code>Prime::PseudoPrimeGenerator#each</code>は<code>upper_bound=</code>で与えられたデータ(より正確には上限値を保持するインスタンス変数<code>@ubound</code>の中身)が真なら上限まで素数を生成し、偽なら無限に素数を生成します。このため<code>g.upper_bound = false</code>とした場合、内部的には<code>nil</code>と同じ扱いになって処理が止まらなくなります。もっともこれは想定される挙動なのですが。また文字列を与えたときは上限を超えているかいないかの判定がうまくいかなくなり、エラーとなるわけです。</p>\n\n<h1>\n<span id=\"primepseudoprimegeneratornextは不用意に使わない\" class=\"fragment\"></span><a href=\"#primepseudoprimegeneratornext%E3%81%AF%E4%B8%8D%E7%94%A8%E6%84%8F%E3%81%AB%E4%BD%BF%E3%82%8F%E3%81%AA%E3%81%84\"><i class=\"fa fa-link\"></i></a><code>PrimePseudoPrimeGenerator#next</code>は不用意に使わない</h1>\n\n<p><code>Prime::PseudoPrimeGenerator#each</code>やそれを内部的に呼び出す<code>Prime#each</code>を利用する場合は<code>@ubound</code>に妙なものが設定されていてもそれらしく動くので、問題ないといえば問題ないのですが、それ以外の方法――具体的には<code>Prime::PseudoPrimeGenerator#succ</code>もしくは<code>Prime::PrimePseudoGenerator#next</code>を利用して素数生成を行う場合は注意する必要があります。<strong>たとえば以下の例では設定したはずの上限を超えて素数を生成してしまっています。</strong></p>\n\n<div class=\"code-frame\" data-lang=\"rb\"><div class=\"highlight\"><pre><code><span class=\"n\">g</span> <span class=\"o\">=</span> <span class=\"no\">Prime</span><span class=\"o\">::</span><span class=\"no\">EratosthenesGenerator</span><span class=\"p\">.</span><span class=\"nf\">new</span>\n<span class=\"n\">g</span><span class=\"p\">.</span><span class=\"nf\">upper_bound</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>\n<span class=\"nb\">p</span> <span class=\"n\">g</span><span class=\"p\">.</span><span class=\"nf\">each</span><span class=\"p\">.</span><span class=\"nf\">to_a</span> <span class=\"c1\">#=&gt; [2, 3, 5, 7] : これは正しい</span>\n\n<span class=\"n\">arr</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n<span class=\"mi\">5</span><span class=\"p\">.</span><span class=\"nf\">times</span><span class=\"p\">{</span><span class=\"n\">arr</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">g</span><span class=\"p\">.</span><span class=\"nf\">next</span><span class=\"p\">}</span>\n<span class=\"nb\">p</span> <span class=\"n\">arr</span> <span class=\"c1\">#=&gt; [2, 3, 5, 7, 11]</span>\n<span class=\"nb\">p</span> <span class=\"n\">g</span><span class=\"p\">.</span><span class=\"nf\">upper_bound</span> <span class=\"c1\">#=&gt; 10</span>\n</code></pre></div></div>\n\n<p><code>Prime#each</code>は書き換えた上限まで素数を生成するという方法でしたが、今回の場合は上限値はまったく変わらないにもかかわらず、それ以上の素数を作ってしまっています。なぜこのようなことが起きるのでしょう? やはりライブラリのソースコードを見たところ、<code>next</code>や<code>succ</code>は<code>each</code>と違い、上限判定を行っていないためにこのような挙動を示すようです。<strong>したがって<code>@ubound</code>が数字であろうとなかろうと素数が生成できてしまいまいます。</strong></p>\n\n<div class=\"code-frame\" data-lang=\"rb\"><div class=\"highlight\"><pre><code><span class=\"n\">g</span> <span class=\"o\">=</span> <span class=\"no\">Prime</span><span class=\"o\">::</span><span class=\"no\">EratosthenesGenerator</span><span class=\"p\">.</span><span class=\"nf\">new</span>\n<span class=\"n\">g</span><span class=\"p\">.</span><span class=\"nf\">upper_bound</span> <span class=\"o\">=</span> <span class=\"s2\">\"hoge\"</span>\n\n<span class=\"n\">arr</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n<span class=\"mi\">5</span><span class=\"p\">.</span><span class=\"nf\">times</span><span class=\"p\">{</span><span class=\"n\">arr</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">g</span><span class=\"p\">.</span><span class=\"nf\">next</span><span class=\"p\">}</span>\n<span class=\"nb\">p</span> <span class=\"n\">arr</span> <span class=\"c1\">#=&gt; [2, 3, 5, 7, 11]</span>\n<span class=\"nb\">p</span> <span class=\"n\">g</span><span class=\"p\">.</span><span class=\"nf\">upper_bound</span> <span class=\"c1\">#=&gt; \"hoge\"</span>\n</code></pre></div></div>\n\n<h1>\n<span id=\"primenextは不用意に使わない\" class=\"fragment\"></span><a href=\"#primenext%E3%81%AF%E4%B8%8D%E7%94%A8%E6%84%8F%E3%81%AB%E4%BD%BF%E3%82%8F%E3%81%AA%E3%81%84\"><i class=\"fa fa-link\"></i></a><code>Prime#next</code>は不用意に使わない</h1>\n\n<p>ここまでの流れでもうお分かりかもしれませんが、<code>Prime#next</code>は<code>Prime::PseudoPrimeGenerator#next</code>を呼び出すだけです。したがって上限判定が行われることはなく、指定した上限以上の素数が生成できてしまいます。</p>\n\n<div class=\"code-frame\" data-lang=\"rb\"><div class=\"highlight\"><pre><code><span class=\"n\">primes</span> <span class=\"o\">=</span> <span class=\"no\">Prime</span><span class=\"p\">.</span><span class=\"nf\">each</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"n\">arr</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n<span class=\"mi\">5</span><span class=\"p\">.</span><span class=\"nf\">times</span><span class=\"p\">{</span><span class=\"n\">arr</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">primes</span><span class=\"p\">.</span><span class=\"nf\">next</span><span class=\"p\">}</span>\n<span class=\"nb\">p</span> <span class=\"n\">arr</span> <span class=\"c1\">#=&gt; [2, 3, 5, 7, 11]</span>\n</code></pre></div></div>\n\n<p><code>Prime#each</code>はブロックがあたえられた場合は生成した素数をそのままブロックに流し込むので、大きな問題にはなりづらいと思いますが、与えない場合は<code>next</code>や<code>succ</code>を使って無限に素数を生成することができてしまいます。</p>\n\n<h1>\n<span id=\"まとめ\" class=\"fragment\"></span><a href=\"#%E3%81%BE%E3%81%A8%E3%82%81\"><i class=\"fa fa-link\"></i></a>まとめ</h1>\n\n<p>RubyのPrimeライブラリは高速で便利な一方、仕様が妙に複雑で、ともすれば予期せぬ動作を引き起こす可能性があります。とりわけ<code>next</code>を利用した場合、生成上限を定めていてもそれを無視して素数を無限に作り続けるという仕様は「極悪」で、セキュリティ上の問題になりかねません。Primeライブラリを使う場合はちょっとだけ注意を払うべきかもしれません。</p>\n","body":"___以下の内容はRuby2.2.3/Windows10で検証したものです。したがって違うバージョンやOSではまったく違う挙動を示す可能性があります。また既知の内容であればすみません……。___\n\n# 今北産業\n\n以下のようなコードはエラーも警告もでないので、個人的にはとても気を付けております。\n\n```rb\n# 上限が文字列でもエラーにならない!\ng = Prime::EratosthenesGenerator.new\ng.upper_bound = \"foo\"\n\n# Prime#eachがジェネレータの上限を置き換えている!\nPrime.each(\"hoge\", g)\np g.upper_bound #=> \"hoge\"\n\n# 上限が文字列にも関わらず普通に素数が生成できている!\narr = []\n10.times{arr << g.next}\np arr #=> [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n\n# 上限を数字に変えてみたものの、上限以上の素数を生成している!\ng.upper_bound = 10\narr = []\n10.times{arr << g.next}\np arr #=> [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\np g.upper_bound #=> 10\n\n# Prime#eachを利用してもダメでした……\nprimes = Prime.each(10)\narr = []\n10.times{arr << primes.next}\np arr #=> [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n```\n\n# `Prime#each`は不用意に使わない\n\n正直なところ使われる機会は多くないと思いますが、`Prime::PseudoPrimeGenerator`クラスには`upper_bound`および`upper_bound=`というメソッドが定義されており、素数の生成上限を取得設定することができます。実際的な素数生成にあたって利用する`Prime::EratosthenesGenerator`クラスなどは`Prime::PseudoPrimeGenerator`クラスのインスタンスなので、当然`upper_bound=`を呼び出して生成上限を設定することができます。\n\n```rb\nrequire \"prime\"\n\ng = Prime::EratosthenesGenerator.new\ng.upper_bound = 20\np g.each.to_a #=> [2, 3, 5, 7, 11, 13, 17, 19]\n\n# 上限を設定しない場合 = upper_boundにnilを指定する場合\n# 素数を無限に生成し続けるので、処理が終わらない\ng.upper_bound = nil\np g.each.to_a\n```\nさてとりわけよく使われる`Prime#each`メソッドは生成上限とジェネレータの種類を指定して素数生成することができますが、このときジェネレータにも上限が設定されていた場合どうなるでしょうか?\n\n```rb\ng = Prime::EratosthenesGenerator.new\ng.upper_bound = 20\n\np Prime.each(30, g).to_a #=> [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\np g.upper_bound #=> 30\n```\n\n__端的にいうと`Prime#each`はとくに警告などなくジェネレータ側の上限を書き換えてしまいます。__ライブラリのソースコードを見たところ、内部的には`Prime#each`はそのジェネレータに対して`upper_bound=`を呼び出したのち、`Prime::PseudoPrimeGenerator#each`を利用して素数を生成するので、書き換えられてしまうということでした。\n\n# `upper_bound=`は不用意に使わない\n\n`Prime#each`が`upper_bound=`を呼び出すので書き換えられてしまうと述べましたが、この`upper_bound=`もまた曲者で、とくに入力バリデーションのようなことは行いません。__つまり与えられたデータが数値なのかどうかを判定せず、そのまま保持してしまうのです。__\n\n```rb\ng = Prime::EratosthenesGenerator.new\n\ng.upper_bound = false # 問題なく代入できる\np g.each.to_a # 処理が終わらない\n\ng.upper_bound = \"123\"\np g.each.to_a # エラー\n```\n\n`Prime::PseudoPrimeGenerator#each`は`upper_bound=`で与えられたデータ(より正確には上限値を保持するインスタンス変数`@ubound`の中身)が真なら上限まで素数を生成し、偽なら無限に素数を生成します。このため`g.upper_bound = false`とした場合、内部的には`nil`と同じ扱いになって処理が止まらなくなります。もっともこれは想定される挙動なのですが。また文字列を与えたときは上限を超えているかいないかの判定がうまくいかなくなり、エラーとなるわけです。\n\n# `PrimePseudoPrimeGenerator#next`は不用意に使わない\n\n`Prime::PseudoPrimeGenerator#each`やそれを内部的に呼び出す`Prime#each`を利用する場合は`@ubound`に妙なものが設定されていてもそれらしく動くので、問題ないといえば問題ないのですが、それ以外の方法――具体的には`Prime::PseudoPrimeGenerator#succ`もしくは`Prime::PrimePseudoGenerator#next`を利用して素数生成を行う場合は注意する必要があります。__たとえば以下の例では設定したはずの上限を超えて素数を生成してしまっています。__\n\n```rb\ng = Prime::EratosthenesGenerator.new\ng.upper_bound = 10\np g.each.to_a #=> [2, 3, 5, 7] : これは正しい\n\narr = []\n5.times{arr << g.next}\np arr #=> [2, 3, 5, 7, 11]\np g.upper_bound #=> 10\n```\n\n`Prime#each`は書き換えた上限まで素数を生成するという方法でしたが、今回の場合は上限値はまったく変わらないにもかかわらず、それ以上の素数を作ってしまっています。なぜこのようなことが起きるのでしょう? やはりライブラリのソースコードを見たところ、`next`や`succ`は`each`と違い、上限判定を行っていないためにこのような挙動を示すようです。__したがって`@ubound`が数字であろうとなかろうと素数が生成できてしまいまいます。__\n\n```rb\ng = Prime::EratosthenesGenerator.new\ng.upper_bound = \"hoge\"\n\narr = []\n5.times{arr << g.next}\np arr #=> [2, 3, 5, 7, 11]\np g.upper_bound #=> \"hoge\"\n```\n\n# `Prime#next`は不用意に使わない\n\nここまでの流れでもうお分かりかもしれませんが、`Prime#next`は`Prime::PseudoPrimeGenerator#next`を呼び出すだけです。したがって上限判定が行われることはなく、指定した上限以上の素数が生成できてしまいます。\n\n```rb\nprimes = Prime.each(10)\narr = []\n5.times{arr << primes.next}\np arr #=> [2, 3, 5, 7, 11]\n```\n\n`Prime#each`はブロックがあたえられた場合は生成した素数をそのままブロックに流し込むので、大きな問題にはなりづらいと思いますが、与えない場合は`next`や`succ`を使って無限に素数を生成することができてしまいます。\n\n# まとめ\n\nRubyのPrimeライブラリは高速で便利な一方、仕様が妙に複雑で、ともすれば予期せぬ動作を引き起こす可能性があります。とりわけ`next`を利用した場合、生成上限を定めていてもそれを無視して素数を無限に作り続けるという仕様は「極悪」で、セキュリティ上の問題になりかねません。Primeライブラリを使う場合はちょっとだけ注意を払うべきかもしれません。\n\n\n","coediting":false,"comments_count":0,"created_at":"2015-12-16T22:59:33+09:00","group":null,"id":"6567ac7b4d1dc56095d2","likes_count":2,"private":false,"reactions_count":0,"stocks_count":2,"tags":[{"name":"Ruby","versions":[]}],"title":"RubyのPrimeライブラリを利用する際に注意したいこと","updated_at":"2015-12-16T22:59:33+09:00","url":"https://qiita.com/neko_the_shadow/items/6567ac7b4d1dc56095d2","user":{"description":"IT業界の片隅でひっそり生きるシステムエンジニアです(´・ω・｀)","facebook_id":"","followees_count":0,"followers_count":35,"github_login_name":null,"id":"neko_the_shadow","items_count":207,"linkedin_id":"","location":"神奈川県川崎市","name":"","organization":"","permanent_id":105859,"profile_image_url":"https://qiita-image-store.s3.amazonaws.com/0/105859/profile-images/1473709753","team_only":false,"twitter_screen_name":"neko_the_shadow","website_url":"https://nekotheshadow.github.io/"},"page_views_count":965,"team_membership":null}