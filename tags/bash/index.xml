<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Bash on Qiita Backup</title><link>https://nekotheshadow.github.io/qiita-backup/tags/bash/</link><description>Recent content in Bash on Qiita Backup</description><generator>Hugo -- gohugo.io</generator><language>ja</language><lastBuildDate>Wed, 05 Dec 2018 14:07:30 +0900</lastBuildDate><atom:link href="https://nekotheshadow.github.io/qiita-backup/tags/bash/index.xml" rel="self" type="application/rss+xml"/><item><title>合成数列の和 Advent Calendar 2018 bash 編</title><link>https://nekotheshadow.github.io/qiita-backup/blog/b5bd9930c00325f0e4ca/</link><pubDate>Wed, 05 Dec 2018 14:07:30 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/b5bd9930c00325f0e4ca/</guid><description>注意: 「合成数列の和 Advent Calendar 2018」の9日目の記事になります。 詳細な問題内容はアドベントカレンダーの該当記事に譲るとして、ごく簡単にまとめてお</description></item><item><title>ずんだのハロウィン問題 bash編</title><link>https://nekotheshadow.github.io/qiita-backup/blog/784bb2d24f3fa01d294a/</link><pubDate>Thu, 01 Nov 2018 00:01:21 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/784bb2d24f3fa01d294a/</guid><description>もとねた: 「ずんだのハロウィン問題 Ruby編」 1行野郎は男の浪漫&amp;ndash;ということで、保守性や可読性を無視して、上記記事の条件を満たす</description></item><item><title>上限を設けずに整数列を生成したい</title><link>https://nekotheshadow.github.io/qiita-backup/blog/00574464fb8f6b698deb/</link><pubDate>Sat, 09 Jun 2018 18:41:53 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/00574464fb8f6b698deb/</guid><description>整数の列を生成するにあたって、基本的にはseqコマンドでことたりるのですが、欠点がないわけではありません。とりわけ整数列の生成にあたって上限</description></item><item><title>AWKのrandが同じ乱数列を生成してしまう</title><link>https://nekotheshadow.github.io/qiita-backup/blog/f4f3d339d1919240b6ee/</link><pubDate>Sun, 22 Apr 2018 19:53:24 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/f4f3d339d1919240b6ee/</guid><description>awk(gawk)には乱数を生成する組み込み関数としてrandが用意されているのですが、たとえば以下のようなソースコードで検証ができるように</description></item><item><title>trapがどんどん上書きされてしまう</title><link>https://nekotheshadow.github.io/qiita-backup/blog/74af8ad58284e1aa1378/</link><pubDate>Thu, 01 Mar 2018 23:01:14 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/74af8ad58284e1aa1378/</guid><description>受け取ったシグナルに合わせて、指定した処理を実行してくれるtrap、とても便利ですよね(´・ω・｀) 個人的には「作成した一時ファイルを終了後</description></item><item><title>AWKで素数列挙(エラトステネスのふるい・疑似素数による試し割り)</title><link>https://nekotheshadow.github.io/qiita-backup/blog/0f1ac17986f1122b1b13/</link><pubDate>Thu, 23 Nov 2017 20:12:35 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/0f1ac17986f1122b1b13/</guid><description>需要あるのかしら(´・ω・｀) まずはエラトステネスのふるい。 BEGIN { upper_bound = 100 for (i = 2; i &amp;lt;= upper_bound; i++) is_prime[i] = 1; for (i = 2; i &amp;lt;= sqrt(upper_bound); i++) { if (!is_prime[i]) continue; for (j = i * 2; j &amp;lt;= upper_bound; j += i)</description></item><item><title>デリミタを指定しつつ、複数の要素を結合したい。</title><link>https://nekotheshadow.github.io/qiita-backup/blog/6a5da10d45912ccf7b15/</link><pubDate>Mon, 20 Nov 2017 23:32:53 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/6a5da10d45912ccf7b15/</guid><description>多くの現代的なプログラミング言語ではリストや配列の要素をデリミタを指定しつつ結合するメソッド・関数が用意されています。このような機能のメソッ</description></item><item><title>ファイルの中間行を行数を指定して抜き出したい</title><link>https://nekotheshadow.github.io/qiita-backup/blog/68ef9e7766001a221701/</link><pubDate>Tue, 07 Nov 2017 23:28:02 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/68ef9e7766001a221701/</guid><description>たとえば「このファイルの10行目から20行目までを見たい!」というように、ファイルの中間行を行数を指定して抜き出したいという場合、awkの組</description></item><item><title> iconvに関する自分用覚書(基本文法/ 利用できる文字コードを調べたい/変換エラーの文字を無視・置換したい)</title><link>https://nekotheshadow.github.io/qiita-backup/blog/fb12ef59e4c19d06f160/</link><pubDate>Thu, 24 Aug 2017 00:11:26 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/fb12ef59e4c19d06f160/</guid><description>日本社会で働くプログラマ、もとい非英語圏のプログラマにとって避けて通れないものが文字コード。とりわけ日本企業向けの受託開発を主とするSIer</description></item><item><title>grepでバックスラッシュを含む行を検索したい</title><link>https://nekotheshadow.github.io/qiita-backup/blog/7e7dcae7dde8b8c3bb9f/</link><pubDate>Tue, 15 Aug 2017 22:48:04 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/7e7dcae7dde8b8c3bb9f/</guid><description>grepでバックスラッシュ(\)を検索する機会があったのですが、意外にも「はまった」のでメモとして対応策を残しておきたいと思います。 まず文字</description></item><item><title>「bash -x sample.sh」のデバッグ情報は標準エラー出力に出力されている</title><link>https://nekotheshadow.github.io/qiita-backup/blog/d6e4bb22f146f1101c65/</link><pubDate>Wed, 19 Jul 2017 22:27:06 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/d6e4bb22f146f1101c65/</guid><description>シェルスクリプト内で実行されたコマンドとその結果をすべて出力してくれるのがbashの-xオプション。「わざわざロギングをコーディングするほど</description></item><item><title>| while read のwhileループ脱出にはbreakではなくexitを利用する(+それに関連するTips)</title><link>https://nekotheshadow.github.io/qiita-backup/blog/39d35d09dd58c26002bb/</link><pubDate>Sat, 13 May 2017 23:22:32 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/39d35d09dd58c26002bb/</guid><description>| while readはbashプログラミングにおいてもっとも使われるイディオムのひとつですが、**このwhileループを脱出する際はbreakではな</description></item><item><title>CodeIQ「スーパー素数」問題に参加しました。</title><link>https://nekotheshadow.github.io/qiita-backup/blog/e0e24bc7afdfa965f6aa/</link><pubDate>Fri, 10 Feb 2017 01:07:02 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/e0e24bc7afdfa965f6aa/</guid><description>CodeIQ「スーパー素数」問題の公開期間が終了したということで、自分の答案を公開したいと思います。 利用した言語はBash――なのですが、実</description></item><item><title>while-readの区切り文字を空白以外に設定したい</title><link>https://nekotheshadow.github.io/qiita-backup/blog/6757d3d77deb6da9389f/</link><pubDate>Sat, 17 Dec 2016 11:23:45 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/6757d3d77deb6da9389f/</guid><description>シェルスクリプトにおいて、要素の区切りは「空白文字」に設定することが一般的です。ただし現実問題として「空白文字」が要素のひとつとして扱わねば</description></item><item><title>配列の最小値を求める</title><link>https://nekotheshadow.github.io/qiita-backup/blog/0ab9fc8bbe8dacd4bddf/</link><pubDate>Wed, 07 Dec 2016 00:25:19 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/0ab9fc8bbe8dacd4bddf/</guid><description>正の整数が格納された配列があり、その最小値を求めることを考えます。まずawk厨のわたしとしては、awkを利用する方法が思いつきます。 numbers=(34 65 112 98</description></item><item><title>文字列を1文字ずつに分解する</title><link>https://nekotheshadow.github.io/qiita-backup/blog/1d869474086c64a93ba0/</link><pubDate>Tue, 06 Dec 2016 01:20:45 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/1d869474086c64a93ba0/</guid><description>bashやshellsciriptにおいて、文字列を1文字ずつに分解するとき、個人的にまず思いつくのはawkを利用する方法です。 echo &amp;#39;helloworld&amp;#39; | awk -v FS=&amp;#39;&amp;#39;</description></item><item><title>ディレクトリ構造を無視して圧縮する場合はzipコマンドの-jオプションを使う</title><link>https://nekotheshadow.github.io/qiita-backup/blog/895dcd423082c38366cf/</link><pubDate>Wed, 23 Nov 2016 23:53:09 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/895dcd423082c38366cf/</guid><description>たとえばディレクトリ/foo/barの直下にa.xml/b.xml/c.xmlという3つのxmlファイルがあり、この3つだけをおさめたzip</description></item><item><title>ディレクトリの中身の有無によって条件分岐をしたい</title><link>https://nekotheshadow.github.io/qiita-backup/blog/5d6c5f3e5ff35ab34298/</link><pubDate>Sun, 20 Nov 2016 22:39:55 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/5d6c5f3e5ff35ab34298/</guid><description>ディレクトリが空ディレクトリかどうかによって条件分岐を行いたいということがよくあると思います。たとえば「対象のディレクトリがファイルやディレ</description></item></channel></rss>