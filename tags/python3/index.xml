<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python3 on Qiita Backup</title><link>https://nekotheshadow.github.io/qiita-backup/tags/python3/</link><description>Recent content in Python3 on Qiita Backup</description><generator>Hugo -- gohugo.io</generator><language>ja</language><lastBuildDate>Mon, 17 Jan 2022 00:47:38 +0900</lastBuildDate><atom:link href="https://nekotheshadow.github.io/qiita-backup/tags/python3/index.xml" rel="self" type="application/rss+xml"/><item><title>ファイルツリーを走査する際に特定のディレクトリの配下は無視したい</title><link>https://nekotheshadow.github.io/qiita-backup/blog/04807fc32d9b89cf47cd/</link><pubDate>Mon, 17 Jan 2022 00:47:38 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/04807fc32d9b89cf47cd/</guid><description>python3でファイルツリーをトラバースしたい場合、標準ライブラリとしてはos.walkが用意されているのですが、このAPIは指定したディ</description></item><item><title>open(0)とすると標準入力に対応するファイルオブジェクトが取得できる</title><link>https://nekotheshadow.github.io/qiita-backup/blog/521d1361820c42547741/</link><pubDate>Sun, 07 Feb 2021 13:34:16 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/521d1361820c42547741/</guid><description>Python3で標準入力から入力を読む方法はいくつかありますが、組み込み関数のopenを使って、open(0)とすると標準入力に対応するファ</description></item><item><title>gmusicapiの認証サンプル</title><link>https://nekotheshadow.github.io/qiita-backup/blog/2ab0e7137bf703ff0d21/</link><pubDate>Sun, 01 Dec 2019 23:25:37 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/2ab0e7137bf703ff0d21/</guid><description>完全に自分用の技術メモ(´・ω・｀) gmusicapiはPythonからGoogle Play Musicを操作するGoogle非公認のライブラリです</description></item><item><title>AtCoder Beginner Contest 124 の参戦記録</title><link>https://nekotheshadow.github.io/qiita-backup/blog/8320829ac908ce963319/</link><pubDate>Sun, 14 Apr 2019 18:00:46 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/8320829ac908ce963319/</guid><description>AtCoder Beginner Contest 124に参戦したので、提出時にどのようなことを考えていたのかと実際の提出コードをまとめておきたいと思います。利用した言語はPython</description></item><item><title>再帰の最大回数を確認する/設定する</title><link>https://nekotheshadow.github.io/qiita-backup/blog/8128a6a46acecf1cba46/</link><pubDate>Tue, 05 Mar 2019 23:20:50 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/8128a6a46acecf1cba46/</guid><description>再帰の最大回数を確認したい場合はsys.getrecursionlimit、設定したい場合はsys.setrecursionlimitをそれ</description></item><item><title>itertools.groupbyは事前にソートしておく必要がある &amp; n番目の要素を取得する関数がほしい場合はoperator.itemgetterが便利</title><link>https://nekotheshadow.github.io/qiita-backup/blog/8c3ce77899abdf274a3e/</link><pubDate>Tue, 25 Dec 2018 18:09:40 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/8c3ce77899abdf274a3e/</guid><description>受信したメールの受信日付、送信元Adress、件名が以下のような形式でリストに格納されているとします。 received_mails = [ (&amp;#34;2018-01-01&amp;#34;, &amp;#34;alice@example.com&amp;#34;, &amp;#34;subject1&amp;#34;), (&amp;#34;2018-02-02&amp;#34;, &amp;#34;bob@example.com&amp;#34; , &amp;#34;subject2&amp;#34;), (&amp;#34;2018-03-03&amp;#34;, &amp;#34;chris@example.com&amp;#34;, &amp;#34;subject3&amp;#34;), (&amp;#34;2018-04-04&amp;#34;, &amp;#34;alice@example.com&amp;#34;, &amp;#34;subject4&amp;#34;), (&amp;#34;2018-05-05&amp;#34;, &amp;#34;bob@example.com&amp;#34; ,</description></item><item><title>ずんだの菱形アルファベット問題 Python3 &amp; SQL編</title><link>https://nekotheshadow.github.io/qiita-backup/blog/532f7a48cf384b3f23bf/</link><pubDate>Tue, 06 Nov 2018 23:40:38 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/532f7a48cf384b3f23bf/</guid><description>もとねた: ずんだの菱形アルファベット問題 Ruby編 Python3で、まずは「ふつう」に回答してみました。もとねたでは実行時引数を読み込んでい</description></item><item><title>Python3で整数の最大値や小数の無限大を扱いたい</title><link>https://nekotheshadow.github.io/qiita-backup/blog/bc4a399b9e4a298d28c6/</link><pubDate>Sun, 04 Mar 2018 23:36:31 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/bc4a399b9e4a298d28c6/</guid><description>Python3で整数型の最大値はsys.maxsizeとして定義されています(URL: https://docs.python.jp/3/library/sys.html#sys.maxsize )。たとえばC言語風のforループがサポートされてい</description></item><item><title>WebDriverでアクセスしたWebサイトのソースコードを取り出したい</title><link>https://nekotheshadow.github.io/qiita-backup/blog/ac70d89bc7797e554967/</link><pubDate>Sun, 25 Feb 2018 22:41:22 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/ac70d89bc7797e554967/</guid><description>WebDriverでアクセスしたWebサイトのソースコード(html)を取り出したいという場合は、webdriverのpage_source</description></item><item><title>CodeIQ「進捗ジエンドマーク」に参加しました。</title><link>https://nekotheshadow.github.io/qiita-backup/blog/52b82ff046aab8e2dc96/</link><pubDate>Sun, 25 Feb 2018 22:17:24 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/52b82ff046aab8e2dc96/</guid><description>CodeIQ「進捗ジエンドマーク」の公開期限が終了したということで、自分の解答をさらしてみたいと思います(´・ω・｀) なおCodeIQはその</description></item><item><title>実行しているファイルが格納されているディレクトリのパスを取得したい。</title><link>https://nekotheshadow.github.io/qiita-backup/blog/09ff3a423954a2adfe18/</link><pubDate>Tue, 25 Jul 2017 23:10:23 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/09ff3a423954a2adfe18/</guid><description>タイトル通り、実行したファイルが格納されているディレクトリのパスを取得したいという場合、Python3ではどのように書くべきでしょうか? まず</description></item><item><title>「配列の要素のうち、条件に一致する最初の要素の位置」をワンライナーで求めたい(Python3)</title><link>https://nekotheshadow.github.io/qiita-backup/blog/76e517efbb510f735782/</link><pubDate>Tue, 07 Mar 2017 01:13:06 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/76e517efbb510f735782/</guid><description>numbers = [3, 5, 4, 2, 1] numbers.index{|val| val % 2 == 0} #=&amp;gt; 2 配列の要素を先頭から見ていき、条件に一致する最初の要素の位置がほしいということがよくあります。例として整数が格</description></item><item><title>CodeIQ「『キャリー・オーバー』問題」に参加しました。</title><link>https://nekotheshadow.github.io/qiita-backup/blog/dd98aa7669e8aadc4cbf/</link><pubDate>Tue, 24 Jan 2017 23:27:21 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/dd98aa7669e8aadc4cbf/</guid><description>CodeIQ「『キャリー・オーバー』問題」の掲載期間が終わったということで、自分の提出コードを公開します。なおほかの方の解答はTogette</description></item><item><title>CodeIQ　「『スパイラル・ウォーク』問題」に参加しました。</title><link>https://nekotheshadow.github.io/qiita-backup/blog/0adf3d3e9da58f0e6bb3/</link><pubDate>Fri, 23 Dec 2016 01:53:05 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/0adf3d3e9da58f0e6bb3/</guid><description>CodeIQ 「『スパイラル・ウォーク』問題」の掲載期間が終わったということで、自分の提出コードを公開したいと思います。詳しい問題内容と解説は後日Cod</description></item><item><title>ループ中にdefaultdictの未定義領域にアクセスすると例外</title><link>https://nekotheshadow.github.io/qiita-backup/blog/2d9ab4d77d0d56e5a9a7/</link><pubDate>Tue, 13 Dec 2016 00:10:54 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/2d9ab4d77d0d56e5a9a7/</guid><description>突然ですが次のコードは例外をスローします。なぜでしょうか? import collections ht = collections.defaultdict(int) ht[0] = ht[1] = 1 x = 2 for ky in ht: if ht[ky + 1] == 0: do_something() #=&amp;gt; RuntimeError: dictionary changed size during iteration Python3ではル</description></item><item><title>CodeIQ「『ディビジョン・サム』問題」に参加しました。</title><link>https://nekotheshadow.github.io/qiita-backup/blog/aaf73e7515571c787698/</link><pubDate>Thu, 01 Dec 2016 23:41:52 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/aaf73e7515571c787698/</guid><description>CodeIQ「『ディビジョン・サム』問題」の掲載期限が終了したということで、自分の提出コードを公開します。ほかの解答者のコードはTogett</description></item><item><title>CodeIQ「『トライアングル・メイズ』問題」に参加しました。</title><link>https://nekotheshadow.github.io/qiita-backup/blog/952a0c103a0bfc432963/</link><pubDate>Sat, 01 Oct 2016 09:01:17 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/952a0c103a0bfc432963/</guid><description>CodeIQ「『トライアングル・メイズ』問題」の掲載期間が終了したということで、自分が提出したコード(Python3)を公開します。ほかの解</description></item><item><title>「モンティ・ホール問題」の簡単なシミュレーションプログラムを書いてみる</title><link>https://nekotheshadow.github.io/qiita-backup/blog/0720fa0fe41260dbbf8c/</link><pubDate>Fri, 26 Aug 2016 00:19:19 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/0720fa0fe41260dbbf8c/</guid><description>モンティ・ホール問題は「主観的な答えと確率論にのっとった答えが一致しない」という不思議な問題です。今回はこの「モンティ・ホール問題」の簡単な</description></item><item><title>ストゥージソートをPython3で実装(バブルソート&amp;クイックソート)</title><link>https://nekotheshadow.github.io/qiita-backup/blog/c3d37e32c99a43c87b3d/</link><pubDate>Sun, 31 Jul 2016 21:58:56 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/c3d37e32c99a43c87b3d/</guid><description>ストゥージソート(stooge sort)というソートがあるそうです。このソートアルゴリズムはとても効率の悪いソートアルゴリズムらしく、バブル</description></item><item><title>Python3のスクリプトでjsonをPOSTする</title><link>https://nekotheshadow.github.io/qiita-backup/blog/324976c7b54623e82b26/</link><pubDate>Thu, 28 Jul 2016 21:03:11 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/324976c7b54623e82b26/</guid><description>ちょっとしたPython3スクリプトでjsonをPOSTしたいということがよくあると思います(適当)。 まずはサンプルコード。 import urllib.request, json if __name__ == &amp;#39;__main__&amp;#39;: url</description></item><item><title>Python3で素数の無限ジェネレータ</title><link>https://nekotheshadow.github.io/qiita-backup/blog/4de8cc0fb0967a1aae68/</link><pubDate>Wed, 27 Jul 2016 22:57:49 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/4de8cc0fb0967a1aae68/</guid><description>先日次のような記事を書きました: 「Pythonで素数列挙と素数判定」。これを公開したのち、ふと「素数の無限ジェネレータ」をPython3を作</description></item><item><title>Pythonで素数列挙と素数判定</title><link>https://nekotheshadow.github.io/qiita-backup/blog/4ebad619564a48f5a97f/</link><pubDate>Mon, 25 Jul 2016 22:49:41 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/4ebad619564a48f5a97f/</guid><description>たまに自分で使うので、Qiitaに投稿しておきます(´・ω・`) primes(x)はx未満の素数をリストに格納するメソッドです。アルゴリズム</description></item><item><title>__len__の戻り値に気を付ける</title><link>https://nekotheshadow.github.io/qiita-backup/blog/5c68112ce16e459ef72b/</link><pubDate>Sun, 24 Jul 2016 00:22:18 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/5c68112ce16e459ef72b/</guid><description>自作のクラスに__len__をオーバーライドし、呼び出したところ、次のようなエラーが発生。 OverflowError: cannot fit &amp;#39;int&amp;#39; into an index-sized integer 原因は__len__の仕様にありま</description></item><item><title>数独ソルバーをPython3で実装</title><link>https://nekotheshadow.github.io/qiita-backup/blog/a7b6f1e050627d862591/</link><pubDate>Sat, 23 Jul 2016 23:06:08 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/a7b6f1e050627d862591/</guid><description>先日ネットサーフィン中に次のような記事を見つけました: 「数学のエキスパートが3ヶ月かけて作成した「世界一難しい数独」」。事実かどうかはともか</description></item><item><title>CodeIQ「『マイナー・ゲーム』問題」に挑戦しました。</title><link>https://nekotheshadow.github.io/qiita-backup/blog/3ac942c2c5b7251ea973/</link><pubDate>Thu, 16 Jun 2016 19:58:24 +0900</pubDate><guid>https://nekotheshadow.github.io/qiita-backup/blog/3ac942c2c5b7251ea973/</guid><description>CodeIQ「『マイナー・ゲーム』問題」の掲載期間が終わったということで、自分の提出コードを公開しておきます。なお詳しい問題の概要や解法は広</description></item></channel></rss>