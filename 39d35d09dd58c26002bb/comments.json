[{"body":"> | while read のwhileループ脱出にはbreakではなくexitを利用する\n\nケース・バイ・ケースです。`exit` を利用すると断定する必要はありません。どちらかと言えば `exit` を使う必要はなく、通常は `break` で十分で、エラーを返したい場合があるなら `exit` を使うぐらいの扱いです。多重ループを抜けたい場合は `break [ネスト数]` を実行します。\n\nエラー返す場合以外でも以下の例ように `|` でつないだコマンドの中で `while` ループとその他の処理をしている場合に、その他の処理をスキップしたいのであれば `exit` を使うのが楽だと思いますが「このような場合に使う」のであって常に `exit` である必要はありません。\n\n```sh\nseq 10 | (\n  while read n; do\n    echo \"$n\"\n    [ \"$n\" -eq 5 ] && exit 0\n  done\n  echo END # この処理をスキップしたい\n)\n```\n\n> whileがサブシェルになる影響\n\nこの記事は bash の記事なので問題はないのですが、厳密にはシェル依存であると補足します。したがってシェルによってはパイプでつないだ最後のコマンドがサブシェルにならず、`exit` を使うと**シェル自体が終了**します。例えば macOS で zsh を使っている場合などでそうなります。\n\n```console\n$ dash -c 'seq 5 | while read line; do exit 1; done; echo END'\nEND\n\n$ bash -c 'seq 5 | while read line; do exit 1; done; echo END'\nEND\n\n$ ksh -c 'seq 5 | while read line; do exit 1; done; echo END'\n（何も出力されない）\n\n$ zsh -c 'seq 5 | while read line; do exit 1; done; echo END'\n（何も出力されない）\n```\n\nbash の場合でも `lastpipe` を有効にすると、パイプで繋いだ最後のコマンドがサブシェルとならず終了します。\n\n```console\n$ bash -c 'shopt -s lastpipe; seq 5 | while read line; do exit 1; done; echo END'\n（何も出力されない）\n```\n\n移植性をもたせたい場合 `( ... )` で明示的にサブシェルにします。\n\n```console\n$ zsh -c 'seq 5 | ( while read line; do exit 1; done ); echo END'\nEND\n```\n\nbash の記事なので「デフォルトでは必ずサブシェルなので `exit` で良い」というのはそのとおりですが、そもそも `exit` が必要な場合以外は `break` で良いです。\n\n> シェルコマンドは終了ステータスを持ち、whileは通常0を返しますが、\n\n正確には最後に実行したコマンドの終了ステータスを返します。\n\n```console\n$ bash -c 'seq 2 | while read line; do expr +; done; echo $?'\nexpr: syntax error: missing argument after `+'\nexpr: syntax error: missing argument after `+'\n2\n```\n","created_at":"2023-01-13T17:00:26+09:00","id":"3cb63f6106830c4e064e","rendered_body":"<blockquote data-sourcepos=\"1:1-1:80\">\n<p data-sourcepos=\"1:3-1:80\">| while read のwhileループ脱出にはbreakではなくexitを利用する</p>\n</blockquote>\n<p data-sourcepos=\"3:1-3:368\">ケース・バイ・ケースです。<code>exit</code> を利用すると断定する必要はありません。どちらかと言えば <code>exit</code> を使う必要はなく、通常は <code>break</code> で十分で、エラーを返したい場合があるなら <code>exit</code> を使うぐらいの扱いです。多重ループを抜けたい場合は <code>break [ネスト数]</code> を実行します。</p>\n<p data-sourcepos=\"5:1-5:366\">エラー返す場合以外でも以下の例ように <code>|</code> でつないだコマンドの中で <code>while</code> ループとその他の処理をしている場合に、その他の処理をスキップしたいのであれば <code>exit</code> を使うのが楽だと思いますが「このような場合に使う」のであって常に <code>exit</code> である必要はありません。</p>\n<div class=\"code-frame\" data-lang=\"sh\" data-sourcepos=\"7:1-15:3\"><div class=\"highlight\"><pre><code><span class=\"nb\">seq </span>10 | <span class=\"o\">(</span>\n  <span class=\"k\">while </span><span class=\"nb\">read </span>n<span class=\"p\">;</span> <span class=\"k\">do\n    </span><span class=\"nb\">echo</span> <span class=\"s2\">\"</span><span class=\"nv\">$n</span><span class=\"s2\">\"</span>\n    <span class=\"o\">[</span> <span class=\"s2\">\"</span><span class=\"nv\">$n</span><span class=\"s2\">\"</span> <span class=\"nt\">-eq</span> 5 <span class=\"o\">]</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nb\">exit </span>0\n  <span class=\"k\">done\n  </span><span class=\"nb\">echo </span>END <span class=\"c\"># この処理をスキップしたい</span>\n<span class=\"o\">)</span>\n</code></pre></div></div>\n<blockquote data-sourcepos=\"17:1-17:40\">\n<p data-sourcepos=\"17:3-17:40\">whileがサブシェルになる影響</p>\n</blockquote>\n<p data-sourcepos=\"19:1-19:380\">この記事は bash の記事なので問題はないのですが、厳密にはシェル依存であると補足します。したがってシェルによってはパイプでつないだ最後のコマンドがサブシェルにならず、<code>exit</code> を使うと<strong>シェル自体が終了</strong>します。例えば macOS で zsh を使っている場合などでそうなります。</p>\n<div class=\"code-frame\" data-lang=\"console\" data-sourcepos=\"21:1-33:3\"><div class=\"highlight\"><pre><code><span class=\"gp\">$</span><span class=\"w\"> </span>dash <span class=\"nt\">-c</span> <span class=\"s1\">'seq 5 | while read line; do exit 1; done; echo END'</span>\n<span class=\"go\">END\n\n</span><span class=\"gp\">$</span><span class=\"w\"> </span>bash <span class=\"nt\">-c</span> <span class=\"s1\">'seq 5 | while read line; do exit 1; done; echo END'</span>\n<span class=\"go\">END\n\n</span><span class=\"gp\">$</span><span class=\"w\"> </span>ksh <span class=\"nt\">-c</span> <span class=\"s1\">'seq 5 | while read line; do exit 1; done; echo END'</span>\n<span class=\"go\">（何も出力されない）\n\n</span><span class=\"gp\">$</span><span class=\"w\"> </span>zsh <span class=\"nt\">-c</span> <span class=\"s1\">'seq 5 | while read line; do exit 1; done; echo END'</span>\n<span class=\"go\">（何も出力されない）\n</span></code></pre></div></div>\n<p data-sourcepos=\"35:1-35:146\">bash の場合でも <code>lastpipe</code> を有効にすると、パイプで繋いだ最後のコマンドがサブシェルとならず終了します。</p>\n<div class=\"code-frame\" data-lang=\"console\" data-sourcepos=\"37:1-40:3\"><div class=\"highlight\"><pre><code><span class=\"gp\">$</span><span class=\"w\"> </span>bash <span class=\"nt\">-c</span> <span class=\"s1\">'shopt -s lastpipe; seq 5 | while read line; do exit 1; done; echo END'</span>\n<span class=\"go\">（何も出力されない）\n</span></code></pre></div></div>\n<p data-sourcepos=\"42:1-42:89\">移植性をもたせたい場合 <code>( ... )</code> で明示的にサブシェルにします。</p>\n<div class=\"code-frame\" data-lang=\"console\" data-sourcepos=\"44:1-47:3\"><div class=\"highlight\"><pre><code><span class=\"gp\">$</span><span class=\"w\"> </span>zsh <span class=\"nt\">-c</span> <span class=\"s1\">'seq 5 | ( while read line; do exit 1; done ); echo END'</span>\n<span class=\"go\">END\n</span></code></pre></div></div>\n<p data-sourcepos=\"49:1-49:213\">bash の記事なので「デフォルトでは必ずサブシェルなので <code>exit</code> で良い」というのはそのとおりですが、そもそも <code>exit</code> が必要な場合以外は <code>break</code> で良いです。</p>\n<blockquote data-sourcepos=\"51:1-51:95\">\n<p data-sourcepos=\"51:3-51:95\">シェルコマンドは終了ステータスを持ち、whileは通常0を返しますが、</p>\n</blockquote>\n<p data-sourcepos=\"53:1-53:87\">正確には最後に実行したコマンドの終了ステータスを返します。</p>\n<div class=\"code-frame\" data-lang=\"console\" data-sourcepos=\"55:1-60:3\"><div class=\"highlight\"><pre><code><span class=\"gp\">$</span><span class=\"w\"> </span>bash <span class=\"nt\">-c</span> <span class=\"s1\">'seq 2 | while read line; do expr +; done; echo $?'</span>\n<span class=\"go\">expr: syntax error: missing argument after `+'\nexpr: syntax error: missing argument after `+'\n2\n</span></code></pre></div></div>\n","updated_at":"2023-01-13T17:00:26+09:00","user":{"description":"おそらくウェブアプリエンジニア 🐚シェルスクリプトの世界をより便利に発展させるために最新情報や高度な技術の紹介、古い情報や間違った情報の更新や訂正を行っています 📗POSIXやUNIX哲学の解説 🚩どの環境でも動作するシェルスクリプト用の高機能テストフレームワーク<ShellSpec>の開発者 🌈好きなもの：シンプルで無駄のないコードやリファクタリング 💢嫌いなもの：技術的負債やレガシーコード","facebook_id":"","followees_count":5,"followers_count":1053,"github_login_name":"ko1nksm","id":"ko1nksm","items_count":235,"linkedin_id":"","location":"基本的にシェルスクリプト関連の記事を書いています","name":"Koichi Nakashima","organization":"最新記事を知りたい方はフォローが便利だと思います","permanent_id":54918,"profile_image_url":"https://qiita-image-store.s3.amazonaws.com/0/54918/profile-images/1473693528","team_only":false,"twitter_screen_name":"ko1nksm","website_url":"https://blog.nksm.name/"}}]