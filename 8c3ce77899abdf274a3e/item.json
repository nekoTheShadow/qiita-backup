{"rendered_body":"<p>受信したメールの受信日付、送信元Adress、件名が以下のような形式でリストに格納されているとします。</p>\n\n<div class=\"code-frame\" data-lang=\"python\"><div class=\"highlight\"><pre><span class=\"n\">received_mails</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n  <span class=\"p\">(</span><span class=\"s\">\"2018-01-01\"</span><span class=\"p\">,</span> <span class=\"s\">\"alice@example.com\"</span><span class=\"p\">,</span> <span class=\"s\">\"subject1\"</span><span class=\"p\">),</span>\n  <span class=\"p\">(</span><span class=\"s\">\"2018-02-02\"</span><span class=\"p\">,</span> <span class=\"s\">\"bob@example.com\"</span>  <span class=\"p\">,</span> <span class=\"s\">\"subject2\"</span><span class=\"p\">),</span>\n  <span class=\"p\">(</span><span class=\"s\">\"2018-03-03\"</span><span class=\"p\">,</span> <span class=\"s\">\"chris@example.com\"</span><span class=\"p\">,</span> <span class=\"s\">\"subject3\"</span><span class=\"p\">),</span>\n  <span class=\"p\">(</span><span class=\"s\">\"2018-04-04\"</span><span class=\"p\">,</span> <span class=\"s\">\"alice@example.com\"</span><span class=\"p\">,</span> <span class=\"s\">\"subject4\"</span><span class=\"p\">),</span>\n  <span class=\"p\">(</span><span class=\"s\">\"2018-05-05\"</span><span class=\"p\">,</span> <span class=\"s\">\"bob@example.com\"</span>  <span class=\"p\">,</span> <span class=\"s\">\"subject5\"</span><span class=\"p\">),</span>\n<span class=\"p\">]</span>\n</pre></div></div>\n\n<p>受信したメールを送信元Adressによって振り分けたい場合、言い換えればSQLでいうところのGROUP-BYのようなことをしたい場合、pythonでは<code>itertools.groupby</code>が利用できます。</p>\n\n<div class=\"code-frame\" data-lang=\"python\">\n<div class=\"code-lang\"><span class=\"bold\">bad.py</span></div>\n<div class=\"highlight\"><pre><span class=\"k\">def</span> <span class=\"nf\">display_mails</span><span class=\"p\">(</span><span class=\"n\">mails</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"s\">':'</span><span class=\"p\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"s\">f'[DATE=</span><span class=\"si\">{</span><span class=\"n\">mail</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"si\">}</span><span class=\"s\"> ADDRESS=</span><span class=\"si\">{</span><span class=\"n\">mail</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"si\">}</span><span class=\"s\"> SUBJECT=</span><span class=\"si\">{</span><span class=\"n\">mail</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span><span class=\"si\">}</span><span class=\"s\">]'</span> <span class=\"k\">for</span> <span class=\"n\">mail</span> <span class=\"ow\">in</span> <span class=\"n\">mails</span><span class=\"p\">)</span>\n\n<span class=\"k\">for</span> <span class=\"n\">address</span><span class=\"p\">,</span> <span class=\"n\">mails</span> <span class=\"ow\">in</span> <span class=\"n\">itertools</span><span class=\"p\">.</span><span class=\"n\">groupby</span><span class=\"p\">(</span><span class=\"n\">received_mails</span><span class=\"p\">,</span> <span class=\"k\">lambda</span> <span class=\"n\">mail</span> <span class=\"p\">:</span> <span class=\"n\">mail</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]):</span>\n    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">address</span><span class=\"p\">,</span> <span class=\"n\">display_mails</span><span class=\"p\">(</span><span class=\"n\">mails</span><span class=\"p\">))</span>\n</pre></div>\n</div>\n\n<p>この結果は次の通りです。要するに送信元Addressによる振り分けができておらず、想定とは違う結果になっています。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>alice@example.com [DATE=2018-01-01 ADDRESS=alice@example.com SUBJECT=subject1]\nbob@example.com [DATE=2018-02-02 ADDRESS=bob@example.com SUBJECT=subject2]\nchris@example.com [DATE=2018-03-03 ADDRESS=chris@example.com SUBJECT=subject3]\nalice@example.com [DATE=2018-04-04 ADDRESS=alice@example.com SUBJECT=subject4]\nbob@example.com [DATE=2018-05-05 ADDRESS=bob@example.com SUBJECT=subject5]\n</pre></div></div>\n\n<p>そこで<a href=\"https://docs.python.jp/3/library/itertools.html#itertools.groupby\" rel=\"nofollow noopener\" target=\"_blank\"><code>itertools.groupby</code>のドキュメント</a>を読んでみたところ、<code>groupby</code>の対象になるイテレータはソート済みである必要があるとのことでした。</p>\n\n<blockquote>\n<p>同じキーをもつような要素からなる iterable 中のグループに対して、キーとグループを返すようなイテレータを作成します。key は各要素に対するキー値を計算する関数です。キーを指定しない場合や None にした場合、key 関数のデフォルトは恒等関数になり要素をそのまま返します。通常、iterable は同じキー関数でソート済みである必要があります。<br>\ngroupby() の操作は Unix の uniq フィルターと似ています。 key 関数の値が変わるたびに休止または新しいグループを生成します (このために通常同じ key 関数でソートしておく必要があるのです)。この動作は SQL の入力順に関係なく共通の要素を集約する GROUP BY とは違います。</p>\n</blockquote>\n\n<p>今回の例であれば、次のように書き直す必要があるということです。</p>\n\n<div class=\"code-frame\" data-lang=\"python\">\n<div class=\"code-lang\"><span class=\"bold\">good.py</span></div>\n<div class=\"highlight\"><pre><span class=\"n\">get_adress</span> <span class=\"o\">=</span> <span class=\"k\">lambda</span> <span class=\"n\">mail</span> <span class=\"p\">:</span> <span class=\"n\">mail</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n<span class=\"k\">for</span> <span class=\"n\">address</span><span class=\"p\">,</span> <span class=\"n\">mails</span> <span class=\"ow\">in</span> <span class=\"n\">itertools</span><span class=\"p\">.</span><span class=\"n\">groupby</span><span class=\"p\">(</span><span class=\"nb\">sorted</span><span class=\"p\">(</span><span class=\"n\">received_mails</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"o\">=</span><span class=\"n\">get_adress</span><span class=\"p\">),</span> <span class=\"n\">get_adress</span><span class=\"p\">):</span>\n    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">address</span><span class=\"p\">,</span> <span class=\"n\">display_mails</span><span class=\"p\">(</span><span class=\"n\">mails</span><span class=\"p\">))</span>\n</pre></div>\n</div>\n\n<p>この実行結果は以下のようになり、確かに送信元Adressでgroup by処理ができていることがわかります。</p>\n\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>alice@example.com [DATE=2018-01-01 ADDRESS=alice@example.com SUBJECT=subject1]:[DATE=2018-04-04 ADDRESS=alice@example.com SUBJECT=subject4]\nbob@example.com [DATE=2018-02-02 ADDRESS=bob@example.com SUBJECT=subject2]:[DATE=2018-05-05 ADDRESS=bob@example.com SUBJECT=subject5]\nchris@example.com [DATE=2018-03-03 ADDRESS=chris@example.com SUBJECT=subject3]\n</pre></div></div>\n\n<hr>\n\n<p><code>good.py</code>では<code>get_address</code>関数を<code>lambda</code>を利用して定義しました。これは<code>def</code>を使って、以下のように定義することも可能です。</p>\n\n<div class=\"code-frame\" data-lang=\"python\"><div class=\"highlight\"><pre><span class=\"k\">def</span> <span class=\"nf\">get_address</span><span class=\"p\">(</span><span class=\"n\">mail</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">mail</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n</pre></div></div>\n\n<p><code>lambda</code>にしろ<code>def</code>にしろ「リストやタプルのn番目の値を取得する」関数が欲しいわけで、こうした用途においては<code>operator.itemgetter</code>を利用することも可能です。たとえば<code>good.py</code>を<code>operator.itemgetter</code>で書き換えると、次のようになります。</p>\n\n<div class=\"code-frame\" data-lang=\"python\">\n<div class=\"code-lang\"><span class=\"bold\">good.py</span></div>\n<div class=\"highlight\"><pre><span class=\"n\">get_address</span> <span class=\"o\">=</span> <span class=\"n\">operator</span><span class=\"p\">.</span><span class=\"n\">itemgetter</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"k\">for</span> <span class=\"n\">address</span><span class=\"p\">,</span> <span class=\"n\">mails</span> <span class=\"ow\">in</span> <span class=\"n\">itertools</span><span class=\"p\">.</span><span class=\"n\">groupby</span><span class=\"p\">(</span><span class=\"nb\">sorted</span><span class=\"p\">(</span><span class=\"n\">received_mails</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"o\">=</span><span class=\"n\">get_adress</span><span class=\"p\">),</span> <span class=\"n\">get_adress</span><span class=\"p\">):</span>\n    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">address</span><span class=\"p\">,</span> <span class=\"n\">display_mails</span><span class=\"p\">(</span><span class=\"n\">mails</span><span class=\"p\">))</span>\n</pre></div>\n</div>\n\n<p>あるいは他の例を考えてみると、たとえば<code>received_mails</code>から件名だけを取り出して、リストに格納したい場合、以下のような3通りの書き方ができるわけです。</p>\n\n<div class=\"code-frame\" data-lang=\"python\"><div class=\"highlight\"><pre><span class=\"n\">subjects</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">mail</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"k\">for</span> <span class=\"n\">mail</span> <span class=\"ow\">in</span> <span class=\"n\">received_mails</span><span class=\"p\">]</span>\n<span class=\"n\">subjects</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">mail</span> <span class=\"p\">:</span> <span class=\"n\">mail</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"n\">received_mails</span><span class=\"p\">))</span>\n<span class=\"n\">subjects</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"n\">operator</span><span class=\"p\">.</span><span class=\"n\">itemgetter</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">),</span> <span class=\"n\">received_mails</span><span class=\"p\">))</span>\n</pre></div></div>\n","body":"受信したメールの受信日付、送信元Adress、件名が以下のような形式でリストに格納されているとします。\n\n```python\nreceived_mails = [\n  (\"2018-01-01\", \"alice@example.com\", \"subject1\"),\n  (\"2018-02-02\", \"bob@example.com\"  , \"subject2\"),\n  (\"2018-03-03\", \"chris@example.com\", \"subject3\"),\n  (\"2018-04-04\", \"alice@example.com\", \"subject4\"),\n  (\"2018-05-05\", \"bob@example.com\"  , \"subject5\"),\n]\n```\n\n受信したメールを送信元Adressによって振り分けたい場合、言い換えればSQLでいうところのGROUP-BYのようなことをしたい場合、pythonでは`itertools.groupby`が利用できます。\n\n```python:bad.py\ndef display_mails(mails):\n    return ':'.join(f'[DATE={mail[0]} ADDRESS={mail[1]} SUBJECT={mail[2]}]' for mail in mails)\n\nfor address, mails in itertools.groupby(received_mails, lambda mail : mail[1]):\n    print(address, display_mails(mails))\n```\n\nこの結果は次の通りです。要するに送信元Addressによる振り分けができておらず、想定とは違う結果になっています。\n\n```\nalice@example.com [DATE=2018-01-01 ADDRESS=alice@example.com SUBJECT=subject1]\nbob@example.com [DATE=2018-02-02 ADDRESS=bob@example.com SUBJECT=subject2]\nchris@example.com [DATE=2018-03-03 ADDRESS=chris@example.com SUBJECT=subject3]\nalice@example.com [DATE=2018-04-04 ADDRESS=alice@example.com SUBJECT=subject4]\nbob@example.com [DATE=2018-05-05 ADDRESS=bob@example.com SUBJECT=subject5]\n```\n\nそこで[`itertools.groupby`のドキュメント](https://docs.python.jp/3/library/itertools.html#itertools.groupby)を読んでみたところ、`groupby`の対象になるイテレータはソート済みである必要があるとのことでした。\n\n> 同じキーをもつような要素からなる iterable 中のグループに対して、キーとグループを返すようなイテレータを作成します。key は各要素に対するキー値を計算する関数です。キーを指定しない場合や None にした場合、key 関数のデフォルトは恒等関数になり要素をそのまま返します。通常、iterable は同じキー関数でソート済みである必要があります。\n> groupby() の操作は Unix の uniq フィルターと似ています。 key 関数の値が変わるたびに休止または新しいグループを生成します (このために通常同じ key 関数でソートしておく必要があるのです)。この動作は SQL の入力順に関係なく共通の要素を集約する GROUP BY とは違います。\n\n今回の例であれば、次のように書き直す必要があるということです。\n\n```python:good.py\nget_adress = lambda mail : mail[1]\nfor address, mails in itertools.groupby(sorted(received_mails, key=get_adress), get_adress):\n    print(address, display_mails(mails))\n```\n\nこの実行結果は以下のようになり、確かに送信元Adressでgroup by処理ができていることがわかります。\n\n```\nalice@example.com [DATE=2018-01-01 ADDRESS=alice@example.com SUBJECT=subject1]:[DATE=2018-04-04 ADDRESS=alice@example.com SUBJECT=subject4]\nbob@example.com [DATE=2018-02-02 ADDRESS=bob@example.com SUBJECT=subject2]:[DATE=2018-05-05 ADDRESS=bob@example.com SUBJECT=subject5]\nchris@example.com [DATE=2018-03-03 ADDRESS=chris@example.com SUBJECT=subject3]\n```\n\n***\n\n`good.py`では`get_address`関数を`lambda`を利用して定義しました。これは`def`を使って、以下のように定義することも可能です。\n\n```python\ndef get_address(mail):\n    return mail[1]\n```\n\n`lambda`にしろ`def`にしろ「リストやタプルのn番目の値を取得する」関数が欲しいわけで、こうした用途においては`operator.itemgetter`を利用することも可能です。たとえば`good.py`を`operator.itemgetter`で書き換えると、次のようになります。\n\n```python:good.py\nget_address = operator.itemgetter(1)\nfor address, mails in itertools.groupby(sorted(received_mails, key=get_adress), get_adress):\n    print(address, display_mails(mails))\n```\n\nあるいは他の例を考えてみると、たとえば`received_mails`から件名だけを取り出して、リストに格納したい場合、以下のような3通りの書き方ができるわけです。\n\n```python\nsubjects = [mail[2] for mail in received_mails]\nsubjects = list(map(lambda mail : mail[2], received_mails))\nsubjects = list(map(operator.itemgetter(2), received_mails))\n```\n","coediting":false,"comments_count":0,"created_at":"2018-12-25T18:09:40+09:00","group":null,"id":"8c3ce77899abdf274a3e","likes_count":3,"private":false,"reactions_count":0,"tags":[{"name":"Python3","versions":[]}],"title":"itertools.groupbyは事前にソートしておく必要がある & n番目の要素を取得する関数がほしい場合はoperator.itemgetterが便利","updated_at":"2018-12-25T18:09:40+09:00","url":"https://qiita.com/neko_the_shadow/items/8c3ce77899abdf274a3e","user":{"description":"IT業界の片隅でひっそり生きるシステムエンジニアです(´・ω・｀)","facebook_id":"","followees_count":0,"followers_count":32,"github_login_name":null,"id":"neko_the_shadow","items_count":163,"linkedin_id":"","location":"神奈川県川崎市","name":"","organization":"","permanent_id":105859,"profile_image_url":"https://qiita-image-store.s3.amazonaws.com/0/105859/profile-images/1473709753","team_only":false,"twitter_screen_name":"neko_the_shadow","website_url":"https://nekotheshadow.github.io/"},"page_views_count":null}