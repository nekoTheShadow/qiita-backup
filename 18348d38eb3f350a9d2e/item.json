{"rendered_body":"<p><strong>注意:</strong> 以下のクエリはPostgresSQLで動作確認を行っています。</p>\n\n<div class=\"code-frame\" data-lang=\"psql\"><div class=\"highlight\"><pre><code>postgres=# select version();\n                           version\n-------------------------------------------------------------\n PostgreSQL 9.6.1, compiled by Visual C++ build 1800, 64-bit\n(1 行)\n</code></pre></div></div>\n\n<hr>\n\n<p>いつものように仕事をさぼっていたときのこと。「さぼるにしても何かしら手を動かしておかないと周りから怪しまれるな……」なんて考えていたところ、SQLで素数列挙をしてみることを思いつきました。アリバイ工作というか偽装工作にもってこいということで、さっそく取り掛かることに。</p>\n\n<p>まず自分が思いついた方法から。素数とは「1と自分以外の素数を持たない自然数」です。つまり約数の数を数えることにより素数かそうでないかを判定することができます。以下では「割る数」と「割られる数」の組み合わせを直積により求めたあと、「割る数」を約数としてその個数を数え、素数判定を行っています。</p>\n\n<div class=\"code-frame\" data-lang=\"sql\"><div class=\"highlight\"><pre><code><span class=\"k\">with</span> <span class=\"k\">recursive</span> <span class=\"n\">numbers</span> <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"p\">(</span>\n        <span class=\"k\">select</span> <span class=\"mi\">1</span>\n    <span class=\"k\">union</span> <span class=\"k\">all</span>\n        <span class=\"k\">select</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">1</span> <span class=\"k\">from</span> <span class=\"n\">numbers</span> <span class=\"k\">where</span> <span class=\"n\">x</span> <span class=\"o\">&lt;</span> <span class=\"mi\">50</span><span class=\"p\">)</span> <span class=\"c1\">-- 1..50の自然数を生成している。</span>\n<span class=\"k\">select</span> <span class=\"n\">dividends</span><span class=\"p\">.</span><span class=\"n\">x</span> <span class=\"k\">as</span> <span class=\"n\">prime</span>\n<span class=\"k\">from</span> <span class=\"n\">numbers</span> <span class=\"k\">as</span> <span class=\"n\">dividends</span><span class=\"p\">,</span> <span class=\"n\">numbers</span> <span class=\"k\">as</span> <span class=\"n\">divisors</span>\n<span class=\"k\">where</span> <span class=\"n\">divisors</span><span class=\"p\">.</span><span class=\"n\">x</span> <span class=\"o\">&lt;=</span> <span class=\"n\">sqrt</span><span class=\"p\">(</span><span class=\"n\">dividends</span><span class=\"p\">.</span><span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"c1\">-- 試し割り: 平方根以下まで調べれば十分</span>\n<span class=\"k\">and</span> <span class=\"n\">dividends</span><span class=\"p\">.</span><span class=\"n\">x</span> <span class=\"o\">&lt;&gt;</span> <span class=\"mi\">1</span> <span class=\"c1\">-- 定義上1は素数ではない</span>\n<span class=\"k\">group</span> <span class=\"k\">by</span> <span class=\"n\">dividends</span><span class=\"p\">.</span><span class=\"n\">x</span>\n<span class=\"k\">having</span> <span class=\"k\">sum</span><span class=\"p\">(</span><span class=\"k\">case</span> <span class=\"k\">when</span> <span class=\"k\">mod</span><span class=\"p\">(</span><span class=\"n\">dividends</span><span class=\"p\">.</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">divisors</span><span class=\"p\">.</span><span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n                <span class=\"k\">then</span> <span class=\"mi\">1</span>\n                <span class=\"k\">else</span> <span class=\"mi\">0</span> <span class=\"k\">end</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"mi\">1</span> <span class=\"c1\">-- 1以外の約数を持たない</span>\n<span class=\"k\">order</span> <span class=\"k\">by</span> <span class=\"n\">dividends</span><span class=\"p\">.</span><span class=\"n\">x</span><span class=\"p\">;</span>\n\n<span class=\"cm\">/*\n prime\n-------\n     2\n     3\n     5\n     7\n    11\n    13\n    17\n    19\n    23\n    29\n    31\n    37\n    41\n    43\n    47\n*/</span>\n</code></pre></div></div>\n\n<p>さて意外にも早く書きあがってしまったため、同じことをしている人がいないかどうかを調べるべく、ネットサーフィンを始めたところ――<a href=\"http://www.geocities.jp/mickindex/database/db_puzzle_math_a.html#LocalLink-prime\" rel=\"nofollow noopener\" target=\"_blank\">日本でSQLを書くにあたっては避けては通れないミックさんのウェブサイトに到達</a>。そこで示されていた解答がシンプルかつ効率もよさげだったので、自分なりに書き直してみることにしました。</p>\n\n<div class=\"code-frame\" data-lang=\"sql\"><div class=\"highlight\"><pre><code><span class=\"k\">with</span> <span class=\"k\">recursive</span> <span class=\"n\">numbers</span> <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"p\">(</span>\n        <span class=\"k\">select</span> <span class=\"mi\">2</span>\n    <span class=\"k\">union</span> <span class=\"k\">all</span>\n        <span class=\"k\">select</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">1</span> <span class=\"k\">from</span> <span class=\"n\">numbers</span> <span class=\"k\">where</span> <span class=\"n\">x</span> <span class=\"o\">&lt;</span> <span class=\"mi\">50</span><span class=\"p\">)</span> <span class=\"c1\">-- 2..50の自然数を生成している</span>\n<span class=\"k\">select</span> <span class=\"n\">dividends</span><span class=\"p\">.</span><span class=\"n\">x</span> <span class=\"k\">as</span> <span class=\"n\">prime</span>\n<span class=\"k\">from</span> <span class=\"n\">numbers</span> <span class=\"k\">as</span> <span class=\"n\">dividends</span>\n<span class=\"k\">where</span> <span class=\"k\">not</span> <span class=\"k\">exists</span><span class=\"p\">(</span>\n    <span class=\"k\">select</span> <span class=\"o\">*</span> \n    <span class=\"k\">from</span> <span class=\"n\">numbers</span> <span class=\"k\">as</span> <span class=\"n\">divisors</span>\n    <span class=\"k\">where</span> <span class=\"n\">divisors</span><span class=\"p\">.</span><span class=\"n\">x</span> <span class=\"o\">&lt;=</span> <span class=\"n\">sqrt</span><span class=\"p\">(</span><span class=\"n\">dividends</span><span class=\"p\">.</span><span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"c1\">-- 試し割り: 平方根以下まで調べれば十分</span>\n    <span class=\"k\">and</span> <span class=\"k\">mod</span><span class=\"p\">(</span><span class=\"n\">dividends</span><span class=\"p\">.</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">divisors</span><span class=\"p\">.</span><span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"mi\">0</span> <span class=\"p\">)</span>\n<span class=\"k\">order</span> <span class=\"k\">by</span> <span class=\"n\">dividends</span><span class=\"p\">.</span><span class=\"n\">x</span><span class=\"p\">;</span>\n\n<span class=\"cm\">/*\n prime\n-------\n     2\n     3\n     5\n     7\n    11\n    13\n    17\n    19\n    23\n    29\n    31\n    37\n    41\n    43\n    47\n*/</span>\n</code></pre></div></div>\n\n<p>素数判定=約数の個数判定を<code>not exists</code>を利用することにより、読みやすく、かつ効率のいいクエリになっています。まだまだSQLも奥が深いですね。もっとべんきょうせねば(´・ω・｀)</p>\n","body":"__注意:__ 以下のクエリはPostgresSQLで動作確認を行っています。\n\n```psql\npostgres=# select version();\n                           version\n-------------------------------------------------------------\n PostgreSQL 9.6.1, compiled by Visual C++ build 1800, 64-bit\n(1 行)\n```\n***\n\nいつものように仕事をさぼっていたときのこと。「さぼるにしても何かしら手を動かしておかないと周りから怪しまれるな……」なんて考えていたところ、SQLで素数列挙をしてみることを思いつきました。アリバイ工作というか偽装工作にもってこいということで、さっそく取り掛かることに。\n\nまず自分が思いついた方法から。素数とは「1と自分以外の素数を持たない自然数」です。つまり約数の数を数えることにより素数かそうでないかを判定することができます。以下では「割る数」と「割られる数」の組み合わせを直積により求めたあと、「割る数」を約数としてその個数を数え、素数判定を行っています。\n\n```sql\nwith recursive numbers (x) as (\n        select 1\n    union all\n        select x + 1 from numbers where x < 50) -- 1..50の自然数を生成している。\nselect dividends.x as prime\nfrom numbers as dividends, numbers as divisors\nwhere divisors.x <= sqrt(dividends.x) -- 試し割り: 平方根以下まで調べれば十分\nand dividends.x <> 1 -- 定義上1は素数ではない\ngroup by dividends.x\nhaving sum(case when mod(dividends.x, divisors.x) = 0\n                then 1\n                else 0 end) = 1 -- 1以外の約数を持たない\norder by dividends.x;\n\n/*\n prime\n-------\n     2\n     3\n     5\n     7\n    11\n    13\n    17\n    19\n    23\n    29\n    31\n    37\n    41\n    43\n    47\n*/\n```\n\nさて意外にも早く書きあがってしまったため、同じことをしている人がいないかどうかを調べるべく、ネットサーフィンを始めたところ――[日本でSQLを書くにあたっては避けては通れないミックさんのウェブサイトに到達](http://www.geocities.jp/mickindex/database/db_puzzle_math_a.html#LocalLink-prime)。そこで示されていた解答がシンプルかつ効率もよさげだったので、自分なりに書き直してみることにしました。\n\n```sql\nwith recursive numbers (x) as (\n        select 2\n    union all\n        select x + 1 from numbers where x < 50) -- 2..50の自然数を生成している\nselect dividends.x as prime\nfrom numbers as dividends\nwhere not exists(\n    select * \n    from numbers as divisors\n    where divisors.x <= sqrt(dividends.x) -- 試し割り: 平方根以下まで調べれば十分\n    and mod(dividends.x, divisors.x) = 0 )\norder by dividends.x;\n\n/*\n prime\n-------\n     2\n     3\n     5\n     7\n    11\n    13\n    17\n    19\n    23\n    29\n    31\n    37\n    41\n    43\n    47\n*/\n```\n\n素数判定=約数の個数判定を`not exists`を利用することにより、読みやすく、かつ効率のいいクエリになっています。まだまだSQLも奥が深いですね。もっとべんきょうせねば(´・ω・｀)\n","coediting":false,"comments_count":0,"created_at":"2017-01-08T00:01:18+09:00","group":null,"id":"18348d38eb3f350a9d2e","likes_count":3,"private":false,"reactions_count":0,"stocks_count":0,"tags":[{"name":"SQL","versions":[]},{"name":"PostgreSQL","versions":[]}],"title":"SQLで素数列挙を行う","updated_at":"2017-01-08T00:01:44+09:00","url":"https://qiita.com/neko_the_shadow/items/18348d38eb3f350a9d2e","user":{"description":"IT業界の片隅でひっそり生きるシステムエンジニアです(´・ω・｀)","facebook_id":"","followees_count":0,"followers_count":37,"github_login_name":"nekoTheShadow","id":"neko_the_shadow","items_count":218,"linkedin_id":"","location":"神奈川県川崎市","name":"","organization":"","permanent_id":105859,"profile_image_url":"https://qiita-image-store.s3.amazonaws.com/0/105859/profile-images/1473709753","team_only":false,"twitter_screen_name":"neko_the_shadow","website_url":"https://github.com/nekoTheShadow"},"page_views_count":2447,"team_membership":null,"organization_url_name":null,"slide":false}