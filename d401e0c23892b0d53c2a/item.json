{"rendered_body":"<p>注意: 以下のクエリはPostgreSQLにより動作確認を行っています。</p>\n\n<div class=\"code-frame\" data-lang=\"sql\"><div class=\"highlight\"><pre><span class=\"n\">postgres</span><span class=\"o\">=#</span> <span class=\"k\">select</span> <span class=\"k\">version</span><span class=\"p\">();</span>\n                           <span class=\"k\">version</span>\n<span class=\"c1\">-------------------------------------------------------------</span>\n <span class=\"n\">PostgreSQL</span> <span class=\"mi\">9</span><span class=\"p\">.</span><span class=\"mi\">6</span><span class=\"p\">.</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">compiled</span> <span class=\"k\">by</span> <span class=\"n\">Visual</span> <span class=\"k\">C</span><span class=\"o\">++</span> <span class=\"n\">build</span> <span class=\"mi\">1800</span><span class=\"p\">,</span> <span class=\"mi\">64</span><span class=\"o\">-</span><span class=\"nb\">bit</span>\n<span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"err\">行</span><span class=\"p\">)</span>\n</pre></div></div>\n\n<hr>\n\n<p><a href=\"https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.amazonaws.com%2F0%2F105859%2Fa9415d47-f51b-b384-73f1-00da391328aa.png?ixlib=rb-1.2.2&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=a67013dbb542757614d4a96555a25230\" target=\"_blank\" rel=\"nofollow noopener\"><img src=\"https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.amazonaws.com%2F0%2F105859%2Fa9415d47-f51b-b384-73f1-00da391328aa.png?ixlib=rb-1.2.2&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=a67013dbb542757614d4a96555a25230\" alt=\"木構造.PNG\" data-canonical-src=\"https://qiita-image-store.s3.amazonaws.com/0/105859/a9415d47-f51b-b384-73f1-00da391328aa.png\" srcset=\"https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.amazonaws.com%2F0%2F105859%2Fa9415d47-f51b-b384-73f1-00da391328aa.png?ixlib=rb-1.2.2&amp;auto=format&amp;gif-q=60&amp;q=75&amp;w=1400&amp;fit=max&amp;s=1ee8e32ad391b9022682b3580b89959f 1x\" loading=\"lazy\"></a></p>\n\n<p>上のような木構造のデータを次のように表現したとします。</p>\n\n<div class=\"code-frame\" data-lang=\"sql\"><div class=\"highlight\"><pre>     <span class=\"n\">id</span>     <span class=\"o\">|</span>   <span class=\"n\">parent</span>\n<span class=\"c1\">------------+------------</span>\n <span class=\"n\">A</span>          <span class=\"o\">|</span>\n <span class=\"n\">B</span>          <span class=\"o\">|</span> <span class=\"n\">A</span>\n <span class=\"k\">C</span>          <span class=\"o\">|</span> <span class=\"n\">A</span>\n <span class=\"n\">D</span>          <span class=\"o\">|</span> <span class=\"k\">C</span>\n <span class=\"n\">E</span>          <span class=\"o\">|</span> <span class=\"k\">C</span>\n <span class=\"n\">F</span>          <span class=\"o\">|</span> <span class=\"n\">E</span>\n <span class=\"k\">G</span>          <span class=\"o\">|</span> <span class=\"n\">E</span>\n <span class=\"n\">H</span>          <span class=\"o\">|</span> <span class=\"k\">G</span>\n <span class=\"n\">I</span>          <span class=\"o\">|</span> <span class=\"k\">G</span>\n</pre></div></div>\n\n<p>つまり自分自身と自分自身の親を示す情報を隣接リスト風に持っておくわけですね。<strong>このような構造のテーブルはナイーブツリー(Naive Tree)などと呼ばれ、有名なアンチパターンのひとつ</strong>なのですが、アンチパターンだからといって設計を見直したりなどできないのが「システムエンジニア」の悲しいところ。それはさておき、親や子を再帰的に取得するクエリは「再帰クエリ」(with-recursive)を利用して次のように書くことができます。</p>\n\n<div class=\"code-frame\" data-lang=\"sql\"><div class=\"highlight\"><pre><span class=\"c1\">-- treeテーブルを生成&amp;初期化する。</span>\n<span class=\"k\">create</span> <span class=\"k\">table</span> <span class=\"n\">tree</span> <span class=\"p\">(</span>\n    <span class=\"n\">id</span> <span class=\"nb\">char</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span> <span class=\"k\">not</span> <span class=\"k\">null</span> <span class=\"k\">primary</span> <span class=\"k\">key</span><span class=\"p\">,</span>\n    <span class=\"n\">parent</span> <span class=\"nb\">char</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span> \n<span class=\"p\">);</span>\n<span class=\"k\">insert</span> <span class=\"k\">into</span> <span class=\"n\">tree</span> <span class=\"k\">values</span>\n    <span class=\"p\">(</span><span class=\"s1\">'A'</span><span class=\"p\">,</span> <span class=\"k\">null</span><span class=\"p\">),</span>\n    <span class=\"p\">(</span><span class=\"s1\">'B'</span><span class=\"p\">,</span> <span class=\"s1\">'A'</span><span class=\"p\">),</span>\n    <span class=\"p\">(</span><span class=\"s1\">'C'</span><span class=\"p\">,</span> <span class=\"s1\">'A'</span><span class=\"p\">),</span>\n    <span class=\"p\">(</span><span class=\"s1\">'D'</span><span class=\"p\">,</span> <span class=\"s1\">'C'</span><span class=\"p\">),</span>\n    <span class=\"p\">(</span><span class=\"s1\">'E'</span><span class=\"p\">,</span> <span class=\"s1\">'C'</span><span class=\"p\">),</span>\n    <span class=\"p\">(</span><span class=\"s1\">'F'</span><span class=\"p\">,</span> <span class=\"s1\">'E'</span><span class=\"p\">),</span>\n    <span class=\"p\">(</span><span class=\"s1\">'G'</span><span class=\"p\">,</span> <span class=\"s1\">'E'</span><span class=\"p\">),</span>\n    <span class=\"p\">(</span><span class=\"s1\">'H'</span><span class=\"p\">,</span> <span class=\"s1\">'G'</span><span class=\"p\">),</span>\n    <span class=\"p\">(</span><span class=\"s1\">'I'</span><span class=\"p\">,</span> <span class=\"s1\">'G'</span><span class=\"p\">);</span>\n\n<span class=\"c1\">-- id = 'I'の先祖をたどるクエリ。</span>\n<span class=\"k\">with</span> <span class=\"k\">recursive</span> <span class=\"n\">ancestor</span> <span class=\"p\">(</span><span class=\"n\">depth</span><span class=\"p\">,</span> <span class=\"n\">id</span><span class=\"p\">,</span> <span class=\"n\">parent</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"p\">(</span>\n        <span class=\"k\">select</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">tree</span><span class=\"p\">.</span><span class=\"n\">id</span><span class=\"p\">,</span> <span class=\"n\">tree</span><span class=\"p\">.</span><span class=\"n\">parent</span> <span class=\"k\">from</span> <span class=\"n\">tree</span> <span class=\"k\">where</span> <span class=\"n\">tree</span><span class=\"p\">.</span><span class=\"n\">id</span> <span class=\"o\">=</span> <span class=\"s1\">'I'</span>\n    <span class=\"k\">union</span> <span class=\"k\">all</span>\n        <span class=\"k\">select</span> \n            <span class=\"n\">ancestor</span><span class=\"p\">.</span><span class=\"n\">depth</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n            <span class=\"n\">tree</span><span class=\"p\">.</span><span class=\"n\">id</span><span class=\"p\">,</span>\n            <span class=\"n\">tree</span><span class=\"p\">.</span><span class=\"n\">parent</span>\n        <span class=\"k\">from</span> <span class=\"n\">ancestor</span><span class=\"p\">,</span> <span class=\"n\">tree</span>\n        <span class=\"k\">where</span> <span class=\"n\">ancestor</span><span class=\"p\">.</span><span class=\"n\">parent</span> <span class=\"o\">=</span> <span class=\"n\">tree</span><span class=\"p\">.</span><span class=\"n\">id</span><span class=\"p\">)</span>\n<span class=\"k\">select</span> <span class=\"n\">depth</span><span class=\"p\">,</span> <span class=\"n\">id</span> <span class=\"k\">from</span> <span class=\"n\">ancestor</span> <span class=\"k\">order</span> <span class=\"k\">by</span> <span class=\"n\">depth</span><span class=\"p\">;</span>\n\n<span class=\"cm\">/*\n depth |     id\n-------+------------\n     0 | I\n     1 | G\n     2 | E\n     3 | C\n     4 | A\n(5 行)\n*/</span>\n\n<span class=\"c1\">-- id = 'C'の子供の一覧を取得するクエリ。</span>\n<span class=\"k\">with</span> <span class=\"k\">recursive</span> <span class=\"n\">child</span> <span class=\"p\">(</span><span class=\"n\">depth</span><span class=\"p\">,</span> <span class=\"n\">id</span><span class=\"p\">,</span> <span class=\"n\">parent</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"p\">(</span>\n        <span class=\"k\">select</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">tree</span><span class=\"p\">.</span><span class=\"n\">id</span><span class=\"p\">,</span> <span class=\"n\">tree</span><span class=\"p\">.</span><span class=\"n\">parent</span> <span class=\"k\">from</span> <span class=\"n\">tree</span> <span class=\"k\">where</span> <span class=\"n\">tree</span><span class=\"p\">.</span><span class=\"n\">id</span> <span class=\"o\">=</span> <span class=\"s1\">'C'</span>\n    <span class=\"k\">union</span> <span class=\"k\">all</span>\n        <span class=\"k\">select</span>\n            <span class=\"n\">child</span><span class=\"p\">.</span><span class=\"n\">depth</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n            <span class=\"n\">tree</span><span class=\"p\">.</span><span class=\"n\">id</span><span class=\"p\">,</span>\n            <span class=\"n\">tree</span><span class=\"p\">.</span><span class=\"n\">parent</span>\n        <span class=\"k\">from</span> <span class=\"n\">tree</span><span class=\"p\">,</span> <span class=\"n\">child</span>\n        <span class=\"k\">where</span> <span class=\"n\">tree</span><span class=\"p\">.</span><span class=\"n\">parent</span> <span class=\"o\">=</span> <span class=\"n\">child</span><span class=\"p\">.</span><span class=\"n\">id</span><span class=\"p\">)</span>\n<span class=\"k\">select</span> <span class=\"n\">depth</span><span class=\"p\">,</span> <span class=\"n\">id</span> <span class=\"k\">from</span> <span class=\"n\">child</span> <span class=\"k\">order</span> <span class=\"k\">by</span> <span class=\"n\">depth</span><span class=\"p\">;</span>\n\n<span class=\"cm\">/*\n depth |     id\n-------+------------\n     0 | C\n     1 | D\n     1 | E\n     2 | F\n     2 | G\n     3 | H\n     3 | I\n(7 行)\n*/</span>\n</pre></div></div>\n\n<p>今回は単なる<code>select</code>だったので、簡単にクエリを書くことができましたが、<code>update</code>や<code>delete</code>となると途端に複雑化します。また再帰を利用するため、階層が深くなってくるとパフォーマンスのことも考える必要がありそうです。一見するとシンプルだが、実際の運用はかなり大変。このあたりがアンチパターンたるゆえんでしょうか。</p>\n\n<p>なおMySQLのように「再帰クエリ」をサポートしていないDBMSを利用している場合は――あきらめましょう(´・ω・｀) とはいえ「再帰クエリ」は標準SQLの反中なので、将来的サポートされる可能性が高い構文ではあります。</p>\n","body":"\n注意: 以下のクエリはPostgreSQLにより動作確認を行っています。\n\n```sql\npostgres=# select version();\n                           version\n-------------------------------------------------------------\n PostgreSQL 9.6.1, compiled by Visual C++ build 1800, 64-bit\n(1 行)\n```\n\n***\n\n![木構造.PNG](https://qiita-image-store.s3.amazonaws.com/0/105859/a9415d47-f51b-b384-73f1-00da391328aa.png)\n\n上のような木構造のデータを次のように表現したとします。\n\n```sql\n     id     |   parent\n------------+------------\n A          |\n B          | A\n C          | A\n D          | C\n E          | C\n F          | E\n G          | E\n H          | G\n I          | G\n```\n\nつまり自分自身と自分自身の親を示す情報を隣接リスト風に持っておくわけですね。__このような構造のテーブルはナイーブツリー(Naive Tree)などと呼ばれ、有名なアンチパターンのひとつ__なのですが、アンチパターンだからといって設計を見直したりなどできないのが「システムエンジニア」の悲しいところ。それはさておき、親や子を再帰的に取得するクエリは「再帰クエリ」(with-recursive)を利用して次のように書くことができます。\n\n```sql\n-- treeテーブルを生成&初期化する。\ncreate table tree (\n\tid char(10) not null primary key,\n\tparent char(10) \n);\ninsert into tree values\n\t('A', null),\n\t('B', 'A'),\n\t('C', 'A'),\n\t('D', 'C'),\n\t('E', 'C'),\n\t('F', 'E'),\n\t('G', 'E'),\n\t('H', 'G'),\n\t('I', 'G');\n\n-- id = 'I'の先祖をたどるクエリ。\nwith recursive ancestor (depth, id, parent) as (\n\t\tselect 0, tree.id, tree.parent from tree where tree.id = 'I'\n\tunion all\n\t\tselect \n\t\t\tancestor.depth + 1,\n\t\t\ttree.id,\n\t\t\ttree.parent\n\t\tfrom ancestor, tree\n\t\twhere ancestor.parent = tree.id)\nselect depth, id from ancestor order by depth;\n\n/*\n depth |     id\n-------+------------\n     0 | I\n     1 | G\n     2 | E\n     3 | C\n     4 | A\n(5 行)\n*/\n\n-- id = 'C'の子供の一覧を取得するクエリ。\nwith recursive child (depth, id, parent) as (\n\t\tselect 0, tree.id, tree.parent from tree where tree.id = 'C'\n\tunion all\n\t\tselect\n\t\t\tchild.depth + 1,\n\t\t\ttree.id,\n\t\t\ttree.parent\n\t\tfrom tree, child\n\t\twhere tree.parent = child.id)\nselect depth, id from child order by depth;\n\n/*\n depth |     id\n-------+------------\n     0 | C\n     1 | D\n     1 | E\n     2 | F\n     2 | G\n     3 | H\n     3 | I\n(7 行)\n*/\n```\n\n今回は単なる`select`だったので、簡単にクエリを書くことができましたが、`update`や`delete`となると途端に複雑化します。また再帰を利用するため、階層が深くなってくるとパフォーマンスのことも考える必要がありそうです。一見するとシンプルだが、実際の運用はかなり大変。このあたりがアンチパターンたるゆえんでしょうか。\n\nなおMySQLのように「再帰クエリ」をサポートしていないDBMSを利用している場合は――あきらめましょう(´・ω・｀) とはいえ「再帰クエリ」は標準SQLの反中なので、将来的サポートされる可能性が高い構文ではあります。\n","coediting":false,"comments_count":4,"created_at":"2017-01-10T23:37:05+09:00","group":null,"id":"d401e0c23892b0d53c2a","likes_count":28,"private":false,"reactions_count":0,"tags":[{"name":"SQL","versions":[]},{"name":"PostgreSQL","versions":[]}],"title":"木構造の親または子を再帰的に取得する","updated_at":"2017-01-10T23:39:46+09:00","url":"https://qiita.com/neko_the_shadow/items/d401e0c23892b0d53c2a","user":{"description":"IT業界の片隅でひっそり生きるシステムエンジニアです(´・ω・｀)","facebook_id":"","followees_count":0,"followers_count":33,"github_login_name":null,"id":"neko_the_shadow","items_count":171,"linkedin_id":"","location":"神奈川県川崎市","name":"","organization":"","permanent_id":105859,"profile_image_url":"https://qiita-image-store.s3.amazonaws.com/0/105859/profile-images/1473709753","team_only":false,"twitter_screen_name":"neko_the_shadow","website_url":"https://nekotheshadow.github.io/"},"page_views_count":null}