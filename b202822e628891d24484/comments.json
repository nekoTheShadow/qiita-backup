[{"body":"コメントありがとうございます(｀・ω・´)ｼｬｷｰﾝ\n\n@nakatashunsuke\n\n- `\"\\n\"`の使用を避けた方がいいというのはおっしゃるとおりです。修正したいと思います。\n- ちなみにCodeIQの改行は`\"\\n\"`で大丈夫です(経験則)\n\n@anohana \n\n- 文字列の結合は線形時間だと勘違いしておりました……。こちらも修正します。\n- CodeIQの問題を回答するにあたっては「入力を1度リストやベクタにまとめてからほかの関数やモジュールに引き渡す」ことが多いので、その観点から入力をひとつにまとめています。\n\n@SaitoAtsushi \n\n- 「named-letの方が効率的」というのは書き方がまずいですよね……。完全に筆が滑っています(´・ω・`)\n- CodeIQはオンラインジャッジ系のサイトとしては珍しくScheme(Guile1.8)が使えるのですが、メモリや制限時間が意外にかつかつなので、再帰関係については気を付けていきたいと思います。\n","created_at":"2016-02-12T20:21:24+09:00","id":"64d71bb7f40f50eba17f","rendered_body":"<p>コメントありがとうございます(｀・ω・´)ｼｬｷｰﾝ</p>\n\n<p><a href=\"/nakatashunsuke\" class=\"user-mention js-hovercard\" title=\"nakatashunsuke\" data-hovercard-target-type=\"user\" data-hovercard-target-name=\"nakatashunsuke\">@nakatashunsuke</a></p>\n\n<ul>\n<li>\n<code>\"\\n\"</code>の使用を避けた方がいいというのはおっしゃるとおりです。修正したいと思います。</li>\n<li>ちなみにCodeIQの改行は<code>\"\\n\"</code>で大丈夫です(経験則)</li>\n</ul>\n\n<p><a href=\"/anohana\" class=\"user-mention js-hovercard\" title=\"anohana\" data-hovercard-target-type=\"user\" data-hovercard-target-name=\"anohana\">@anohana</a> </p>\n\n<ul>\n<li>文字列の結合は線形時間だと勘違いしておりました……。こちらも修正します。</li>\n<li>CodeIQの問題を回答するにあたっては「入力を1度リストやベクタにまとめてからほかの関数やモジュールに引き渡す」ことが多いので、その観点から入力をひとつにまとめています。</li>\n</ul>\n\n<p><a href=\"/SaitoAtsushi\" class=\"user-mention js-hovercard\" title=\"SaitoAtsushi\" data-hovercard-target-type=\"user\" data-hovercard-target-name=\"SaitoAtsushi\">@SaitoAtsushi</a> </p>\n\n<ul>\n<li>「named-letの方が効率的」というのは書き方がまずいですよね……。完全に筆が滑っています(´・ω・`)</li>\n<li>CodeIQはオンラインジャッジ系のサイトとしては珍しくScheme(Guile1.8)が使えるのですが、メモリや制限時間が意外にかつかつなので、再帰関係については気を付けていきたいと思います。</li>\n</ul>\n","updated_at":"2016-02-12T20:21:24+09:00","user":{"description":"IT業界の片隅でひっそり生きるシステムエンジニアです(´・ω・｀)","facebook_id":"","followees_count":0,"followers_count":35,"github_login_name":null,"id":"neko_the_shadow","items_count":210,"linkedin_id":"","location":"神奈川県川崎市","name":"","organization":"","permanent_id":105859,"profile_image_url":"https://qiita-image-store.s3.amazonaws.com/0/105859/profile-images/1473709753","team_only":false,"twitter_screen_name":"neko_the_shadow","website_url":"https://nekotheshadow.github.io/"}},{"body":"関数を定義する場合に lambda を省略した書き方 (この記法に公式な名前はありませんが一部ではMIT記法と呼ばれているそうです) を使うことの方が多いとは思います。 関数が第一級であるということを意識しやすいことから lambda を陽に書くスタイルを好む人もいます。 同じ意味であることが仕様上保証されています。 効率に差はありませんし、単純に好みで選ばれると思います。\n\nnamed let を使っても再帰と同じです。 仕様では let は以下のように定義されています。\n\n```scheme\n(define-syntax let\n  (syntax-rules ()\n    ((let ((name val) ...) body1 body2 ...)\n     ((lambda (name ...) body1 body2 ...)\n      val ...))\n    ((let tag ((name val) ...) body1 body2 ...)\n     ((letrec ((tag (lambda (name ...)\n                      body1 body2 ...)))\n        tag)\n      val ...))))\n```\n\n実際には、これと同じ挙動であればよいので let を組込みの機能として持っている処理系もありますし、場合によってはもっと効率的な形に展開されるかもしれませんが、再帰構造になっていることにかわりありません。 また、既に指摘されているように、末尾呼出しの回数に制限がないことが仕様上保証されています (事実上、末尾呼出し最適化を要求している) ので、末尾再帰になっているのであればどちらでも同じですし、末尾呼出しでないなら named let であっても非効率です。\n\n`read` や `write` のポートが省略された場合は `(current-input-port)` や `(current-output-port)` から取得することが保証されています。 一般には、どちらも省略すると思います。\n","created_at":"2016-02-11T23:17:10+09:00","id":"636cadc224cbe6d03810","rendered_body":"<p>関数を定義する場合に lambda を省略した書き方 (この記法に公式な名前はありませんが一部ではMIT記法と呼ばれているそうです) を使うことの方が多いとは思います。 関数が第一級であるということを意識しやすいことから lambda を陽に書くスタイルを好む人もいます。 同じ意味であることが仕様上保証されています。 効率に差はありませんし、単純に好みで選ばれると思います。</p>\n\n<p>named let を使っても再帰と同じです。 仕様では let は以下のように定義されています。</p>\n\n<div class=\"code-frame\" data-lang=\"scheme\"><div class=\"highlight\"><pre><code><span class=\"p\">(</span><span class=\"k\">define-syntax</span> <span class=\"nv\">let</span>\n  <span class=\"p\">(</span><span class=\"k\">syntax-rules</span> <span class=\"p\">()</span>\n    <span class=\"p\">((</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nf\">name</span> <span class=\"nv\">val</span><span class=\"p\">)</span> <span class=\"o\">...</span><span class=\"p\">)</span> <span class=\"nv\">body1</span> <span class=\"nv\">body2</span> <span class=\"o\">...</span><span class=\"p\">)</span>\n     <span class=\"p\">((</span><span class=\"k\">lambda</span> <span class=\"p\">(</span><span class=\"nf\">name</span> <span class=\"o\">...</span><span class=\"p\">)</span> <span class=\"nv\">body1</span> <span class=\"nv\">body2</span> <span class=\"o\">...</span><span class=\"p\">)</span>\n      <span class=\"nv\">val</span> <span class=\"o\">...</span><span class=\"p\">))</span>\n    <span class=\"p\">((</span><span class=\"k\">let</span> <span class=\"nv\">tag</span> <span class=\"p\">((</span><span class=\"nf\">name</span> <span class=\"nv\">val</span><span class=\"p\">)</span> <span class=\"o\">...</span><span class=\"p\">)</span> <span class=\"nv\">body1</span> <span class=\"nv\">body2</span> <span class=\"o\">...</span><span class=\"p\">)</span>\n     <span class=\"p\">((</span><span class=\"k\">letrec</span> <span class=\"p\">((</span><span class=\"nf\">tag</span> <span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"p\">(</span><span class=\"nf\">name</span> <span class=\"o\">...</span><span class=\"p\">)</span>\n                      <span class=\"nv\">body1</span> <span class=\"nv\">body2</span> <span class=\"o\">...</span><span class=\"p\">)))</span>\n        <span class=\"nv\">tag</span><span class=\"p\">)</span>\n      <span class=\"nv\">val</span> <span class=\"o\">...</span><span class=\"p\">))))</span>\n</code></pre></div></div>\n\n<p>実際には、これと同じ挙動であればよいので let を組込みの機能として持っている処理系もありますし、場合によってはもっと効率的な形に展開されるかもしれませんが、再帰構造になっていることにかわりありません。 また、既に指摘されているように、末尾呼出しの回数に制限がないことが仕様上保証されています (事実上、末尾呼出し最適化を要求している) ので、末尾再帰になっているのであればどちらでも同じですし、末尾呼出しでないなら named let であっても非効率です。</p>\n\n<p><code>read</code> や <code>write</code> のポートが省略された場合は <code>(current-input-port)</code> や <code>(current-output-port)</code> から取得することが保証されています。 一般には、どちらも省略すると思います。</p>\n","updated_at":"2016-02-11T23:17:10+09:00","user":{"description":"","facebook_id":"atsushi.saito.1042","followees_count":14,"followers_count":76,"github_login_name":"SaitoAtsushi","id":"SaitoAtsushi","items_count":49,"linkedin_id":"","location":"香川県観音寺市","name":"齊藤 敦志","organization":"","permanent_id":5894,"profile_image_url":"https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/5894/profile-images/1597137314","team_only":false,"twitter_screen_name":"SaitoAtsushi","website_url":"http://saito.s4.xrea.com/"}},{"body":"strにstring-appendで追加していってますが、入力長に対してO(n^2)になるので避けたいところです。入力行数が大きくなる可能性を考えるならなおさらです。\n\nどうしても最後に一気に書き出したいならリストに逆順につないでいって `(for-each display (reverse lst))` が定番ですね。reverseも避けたければstring port (srfi-6)という手もあります。\n","created_at":"2016-02-11T23:12:44+09:00","id":"f8dbde500218eea1f8ab","rendered_body":"<p>strにstring-appendで追加していってますが、入力長に対してO(n^2)になるので避けたいところです。入力行数が大きくなる可能性を考えるならなおさらです。</p>\n\n<p>どうしても最後に一気に書き出したいならリストに逆順につないでいって <code>(for-each display (reverse lst))</code> が定番ですね。reverseも避けたければstring port (srfi-6)という手もあります。</p>\n","updated_at":"2016-02-11T23:12:44+09:00","user":{"description":null,"facebook_id":null,"followees_count":1,"followers_count":25,"github_login_name":"shirok","id":"anohana","items_count":0,"linkedin_id":null,"location":null,"name":"","organization":null,"permanent_id":9173,"profile_image_url":"https://secure.gravatar.com/avatar/223493dc04f78d4a990a24235ff1ab9f?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png","team_only":false,"twitter_screen_name":"anohana","website_url":null}}]