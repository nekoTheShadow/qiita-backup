{"rendered_body":"<p><strong>注意:本記事は2015/2/11に書かれたものです。</strong><br>\n<strong>2016/2/12追記</strong></p>\n\n<p><a href=\"https://codeiq.jp/node/1598\" rel=\"nofollow noopener\" target=\"_blank\">先日大規模アップデートされたCodeIQの入出力サンプル表</a>ですが、そこに掲げられたSchemeの例に因縁をつけてみたいと思います。</p>\n\n<p>「改行区切りのアルファベット文字列を1行ずつ標準入力から読み込んで、それを大文字に変換した後、標準出力に出力する」にあたって、上述のサンプルでは次のような関数<code>f</code>を定義しています。</p>\n\n<div class=\"code-frame\" data-lang=\"scm\"><div class=\"highlight\"><pre>(use-modules (ice-9 rdelim))\n(define f (lambda()\n        (let ((s (read-line (current-input-port))))\n                (if (not (eof-object? s)) (begin\n                        (display (string-upcase (string-trim s)))\n                        (newline)\n                        (f)\n                ))\n        )\n))\n(f)\n</pre></div></div>\n\n<p>たとえば<code>\"hello\\nworld\\n\"</code>が入力された場合<code>\"HELLO\\nWORLD\\n\"</code>が出力されるわけですが……この例は実際どうなんでしょう? Schemeに詳しい方がいらっしゃれば教えてほしいのですが、少なくともわたしであれば次のように書くと思います。ちなみにCodeIQで採用されている処理系は<strong>Guile1.8</strong>です。</p>\n\n<div class=\"code-frame\" data-lang=\"scm\"><div class=\"highlight\"><pre>(use-modules (ice-9 rdelim))\n\n(define (f)\n  (let loop ((line (read-line)) (str \"\"))\n    (if (eof-object? line)\n      (display str)\n      (loop (read-line) (string-append str (string-upcase line) \"\\n\")))))\n\n(f)\n</pre></div></div>\n\n<hr>\n\n<p><strong>2016/2/12追記</strong> : コメントでいくつかご指摘を受けていくつか修正します(´・ω・`)</p>\n\n<div class=\"code-frame\" data-lang=\"scm\"><div class=\"highlight\"><pre>(use-modules (ice-9 rdelim))\n\n(define (f)\n  (let loop ((line (read-line)) (ls '()))\n    (if (eof-object? line)\n      (reverse ls)\n      (loop (read-line) (cons (string-upcase line) ls)))))\n\n(for-each\n  (lambda (line) (begin (display line) (newline)))\n  (f))\n</pre></div></div>\n\n<hr>\n\n<ul>\n<li>関数<code>f</code>の束縛に際して<code>(define f (lambda ...))</code>というような書き方をしていますが、こういう場合は<code>lambda</code>を省略することができます。</li>\n<li>本問の中核的な処理はEOFまで1行ずつ読み込むというところにあり、<code>while</code>的なループが必要になります。<del>例ではそれを関数<code>f</code>の再帰によって実現していますが、named-letの方が効率的で一般的だと思います。</del>例では関数<code>f</code>の再帰呼び出しによってそれを実現していますが、いろいろ気になるのでnamed-let&amp;末尾再帰に書き換えました。<strong>(2016/2/16追記:表現がまずいので変更)</strong>\n\n<ul>\n<li>CodeIQの問題には数百行数千行読み込まねばならないものもあり、それを単なる再帰でさばくとなるとかなりつらいのでは?</li>\n<li>実際には「読み込んだものを順番にリストに突っ込み、最後にそれを関数の返り値とする」ような関数がもとめられる場合が多いと思いますが、例のような書き方だとそれは難しくなります。</li>\n</ul>\n</li>\n<li>\n<code>read-line</code>ではportを指定しているのに、<code>display</code>ではしていないというのはアンバランスな印象を受けます。\n\n<ul>\n<li>というか挙げられた例の最大目的は「入出力先のportは<code>current-input-port</code>や<code>current-output-port</code>でとれる」ということを示すことにあるとも思うので<code>(display ... (current-output-port))</code>としないと目的が達成されていないような気もします。</li>\n<li>ちなみにCodeIQの問題を解くにあたっては、<code>read</code>や<code>write</code>のportは省略できます(経験則)</li>\n</ul>\n</li>\n<li>\n<code>read-line</code>ですが、末尾の改行(<code>\"\\n\"</code>)は読み込まれなかったような……。つまり<code>string-trim</code>はいらない気がします(´・ω・`)</li>\n</ul>\n","body":"__注意:本記事は2015/2/11に書かれたものです。__\n__2016/2/12追記__\n\n[先日大規模アップデートされたCodeIQの入出力サンプル表](https://codeiq.jp/node/1598)ですが、そこに掲げられたSchemeの例に因縁をつけてみたいと思います。\n\n「改行区切りのアルファベット文字列を1行ずつ標準入力から読み込んで、それを大文字に変換した後、標準出力に出力する」にあたって、上述のサンプルでは次のような関数`f`を定義しています。\n\n```scm\n(use-modules (ice-9 rdelim))\n(define f (lambda()\n        (let ((s (read-line (current-input-port))))\n                (if (not (eof-object? s)) (begin\n                        (display (string-upcase (string-trim s)))\n                        (newline)\n                        (f)\n                ))\n        )\n))\n(f)\n```\n\nたとえば`\"hello\\nworld\\n\"`が入力された場合`\"HELLO\\nWORLD\\n\"`が出力されるわけですが……この例は実際どうなんでしょう? Schemeに詳しい方がいらっしゃれば教えてほしいのですが、少なくともわたしであれば次のように書くと思います。ちなみにCodeIQで採用されている処理系は**Guile1.8**です。\n\n```scm\n(use-modules (ice-9 rdelim))\n\n(define (f)\n  (let loop ((line (read-line)) (str \"\"))\n    (if (eof-object? line)\n      (display str)\n      (loop (read-line) (string-append str (string-upcase line) \"\\n\")))))\n\n(f)\n```\n***\n__2016/2/12追記__ : コメントでいくつかご指摘を受けていくつか修正します(´・ω・`)\n\n```scm\n(use-modules (ice-9 rdelim))\n\n(define (f)\n  (let loop ((line (read-line)) (ls '()))\n    (if (eof-object? line)\n      (reverse ls)\n      (loop (read-line) (cons (string-upcase line) ls)))))\n\n(for-each\n  (lambda (line) (begin (display line) (newline)))\n  (f))\n```\n***\n\n- 関数`f`の束縛に際して`(define f (lambda ...))`というような書き方をしていますが、こういう場合は`lambda`を省略することができます。\n- 本問の中核的な処理はEOFまで1行ずつ読み込むというところにあり、`while`的なループが必要になります。~~例ではそれを関数`f`の再帰によって実現していますが、named-letの方が効率的で一般的だと思います。~~例では関数`f`の再帰呼び出しによってそれを実現していますが、いろいろ気になるのでnamed-let&末尾再帰に書き換えました。__(2016/2/16追記:表現がまずいので変更)__\n    - CodeIQの問題には数百行数千行読み込まねばならないものもあり、それを単なる再帰でさばくとなるとかなりつらいのでは?\n    - 実際には「読み込んだものを順番にリストに突っ込み、最後にそれを関数の返り値とする」ような関数がもとめられる場合が多いと思いますが、例のような書き方だとそれは難しくなります。\n- `read-line`ではportを指定しているのに、`display`ではしていないというのはアンバランスな印象を受けます。\n    - というか挙げられた例の最大目的は「入出力先のportは`current-input-port`や`current-output-port`でとれる」ということを示すことにあるとも思うので`(display ... (current-output-port))`としないと目的が達成されていないような気もします。\n    - ちなみにCodeIQの問題を解くにあたっては、`read`や`write`のportは省略できます(経験則)\n- `read-line`ですが、末尾の改行(`\"\\n\"`)は読み込まれなかったような……。つまり`string-trim`はいらない気がします(´・ω・`)\n\n","coediting":false,"comments_count":3,"created_at":"2016-02-11T21:31:57+09:00","group":null,"id":"b202822e628891d24484","likes_count":0,"private":false,"reactions_count":0,"tags":[{"name":"Scheme","versions":[]},{"name":"codeiq","versions":[]}],"title":"CodeIQの入出力サンプル<Scheme>について","updated_at":"2016-02-12T20:36:42+09:00","url":"https://qiita.com/neko_the_shadow/items/b202822e628891d24484","user":{"description":"IT業界の片隅でひっそり生きるシステムエンジニアです(´・ω・｀)","facebook_id":"","followees_count":0,"followers_count":34,"github_login_name":null,"id":"neko_the_shadow","items_count":172,"linkedin_id":"","location":"神奈川県川崎市","name":"","organization":"","permanent_id":105859,"profile_image_url":"https://qiita-image-store.s3.amazonaws.com/0/105859/profile-images/1473709753","team_only":false,"twitter_screen_name":"neko_the_shadow","website_url":"https://nekotheshadow.github.io/"},"page_views_count":null}