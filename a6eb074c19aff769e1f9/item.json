{"rendered_body":"<p>Pythonには<code>itertools#product</code>というデカルト積を簡単に実現できるメソッドが用意されており、個人的には2重ループのネストを減らすために頻繁に利用します。C#では標準ライブラリには用意されていないものの、以下のサンプルに示すように<code>SelectMany</code>を利用すれば、これと同様の機能が実現可能です。</p>\n\n<div class=\"code-frame\" data-lang=\"csharp\"><div class=\"highlight\"><pre><code><span class=\"k\">using</span> <span class=\"nn\">System</span><span class=\"p\">;</span>\n<span class=\"k\">using</span> <span class=\"nn\">System.Linq</span><span class=\"p\">;</span>\n<span class=\"k\">using</span> <span class=\"nn\">System.Collections.Generic</span><span class=\"p\">;</span>\n\n<span class=\"k\">public</span> <span class=\"k\">class</span> <span class=\"nc\">Program</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">public</span> <span class=\"k\">static</span> <span class=\"n\">IEnumerable</span><span class=\"p\">&lt;</span><span class=\"n\">TResult</span><span class=\"p\">&gt;</span> <span class=\"n\">product</span><span class=\"p\">&lt;</span><span class=\"n\">T1</span><span class=\"p\">,</span> <span class=\"n\">T2</span><span class=\"p\">,</span> <span class=\"n\">TResult</span><span class=\"p\">&gt;(</span><span class=\"n\">IEnumerable</span><span class=\"p\">&lt;</span><span class=\"n\">T1</span><span class=\"p\">&gt;</span> <span class=\"n\">ts1</span><span class=\"p\">,</span> <span class=\"n\">IEnumerable</span><span class=\"p\">&lt;</span><span class=\"n\">T2</span><span class=\"p\">&gt;</span> <span class=\"n\">ts2</span><span class=\"p\">,</span> <span class=\"n\">Func</span><span class=\"p\">&lt;</span><span class=\"n\">T1</span><span class=\"p\">,</span> <span class=\"n\">T2</span><span class=\"p\">,</span> <span class=\"n\">TResult</span><span class=\"p\">&gt;</span> <span class=\"n\">func</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n         <span class=\"k\">return</span> <span class=\"n\">ts1</span><span class=\"p\">.</span><span class=\"nf\">SelectMany</span><span class=\"p\">((</span><span class=\"n\">t1</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">(</span><span class=\"n\">ts2</span><span class=\"p\">.</span><span class=\"nf\">Select</span><span class=\"p\">((</span><span class=\"n\">t2</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"n\">func</span><span class=\"p\">.</span><span class=\"nf\">Invoke</span><span class=\"p\">(</span><span class=\"n\">t1</span><span class=\"p\">,</span> <span class=\"n\">t2</span><span class=\"p\">))));</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">public</span> <span class=\"k\">static</span> <span class=\"n\">IEnumerable</span><span class=\"p\">&lt;</span><span class=\"n\">TResult</span><span class=\"p\">&gt;</span> <span class=\"n\">product</span><span class=\"p\">&lt;</span><span class=\"n\">T1</span><span class=\"p\">,</span> <span class=\"n\">T2</span><span class=\"p\">,</span> <span class=\"n\">T3</span><span class=\"p\">,</span> <span class=\"n\">TResult</span><span class=\"p\">&gt;(</span><span class=\"n\">IEnumerable</span><span class=\"p\">&lt;</span><span class=\"n\">T1</span><span class=\"p\">&gt;</span> <span class=\"n\">ts1</span><span class=\"p\">,</span> <span class=\"n\">IEnumerable</span><span class=\"p\">&lt;</span><span class=\"n\">T2</span><span class=\"p\">&gt;</span> <span class=\"n\">ts2</span><span class=\"p\">,</span> <span class=\"n\">IEnumerable</span><span class=\"p\">&lt;</span><span class=\"n\">T3</span><span class=\"p\">&gt;</span> <span class=\"n\">ts3</span><span class=\"p\">,</span> <span class=\"n\">Func</span><span class=\"p\">&lt;</span><span class=\"n\">T1</span><span class=\"p\">,</span> <span class=\"n\">T2</span><span class=\"p\">,</span> <span class=\"n\">T3</span><span class=\"p\">,</span> <span class=\"n\">TResult</span><span class=\"p\">&gt;</span> <span class=\"n\">func</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">ts1</span><span class=\"p\">.</span><span class=\"nf\">SelectMany</span><span class=\"p\">((</span><span class=\"n\">t1</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"nf\">product</span><span class=\"p\">(</span><span class=\"n\">ts2</span><span class=\"p\">,</span> <span class=\"n\">ts3</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">t2</span><span class=\"p\">,</span> <span class=\"n\">t3</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"n\">func</span><span class=\"p\">.</span><span class=\"nf\">Invoke</span><span class=\"p\">(</span><span class=\"n\">t1</span><span class=\"p\">,</span> <span class=\"n\">t2</span><span class=\"p\">,</span> <span class=\"n\">t3</span><span class=\"p\">)));</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">public</span> <span class=\"k\">static</span> <span class=\"k\">void</span> <span class=\"nf\">Main</span><span class=\"p\">()</span>\n    <span class=\"p\">{</span>\n        <span class=\"kt\">var</span> <span class=\"n\">strs</span> <span class=\"p\">=</span> <span class=\"k\">new</span> <span class=\"n\">List</span><span class=\"p\">&lt;</span><span class=\"kt\">string</span><span class=\"p\">&gt;()</span> <span class=\"p\">{</span> <span class=\"s\">\"a\"</span><span class=\"p\">,</span> <span class=\"s\">\"b\"</span><span class=\"p\">,</span> <span class=\"s\">\"c\"</span> <span class=\"p\">};</span>\n        <span class=\"kt\">var</span> <span class=\"n\">nums</span> <span class=\"p\">=</span> <span class=\"k\">new</span> <span class=\"n\">List</span><span class=\"p\">&lt;</span><span class=\"kt\">int</span><span class=\"p\">&gt;()</span> <span class=\"p\">{</span> <span class=\"m\">1</span><span class=\"p\">,</span> <span class=\"m\">2</span><span class=\"p\">,</span> <span class=\"m\">3</span> <span class=\"p\">};</span>\n\n        <span class=\"c1\">// \"べた\"に書く場合:</span>\n        <span class=\"kt\">var</span> <span class=\"n\">tuples1</span> <span class=\"p\">=</span> <span class=\"n\">strs</span><span class=\"p\">.</span><span class=\"nf\">SelectMany</span><span class=\"p\">((</span><span class=\"n\">str</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"n\">nums</span><span class=\"p\">.</span><span class=\"nf\">Select</span><span class=\"p\">((</span><span class=\"n\">num</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"k\">new</span> <span class=\"n\">Tuple</span><span class=\"p\">&lt;</span><span class=\"kt\">string</span><span class=\"p\">,</span> <span class=\"kt\">int</span><span class=\"p\">&gt;(</span><span class=\"n\">str</span><span class=\"p\">,</span> <span class=\"n\">num</span><span class=\"p\">)));</span>\n        <span class=\"k\">foreach</span> <span class=\"p\">(</span><span class=\"kt\">var</span> <span class=\"n\">tuple</span> <span class=\"k\">in</span> <span class=\"n\">tuples1</span><span class=\"p\">)</span>\n        <span class=\"p\">{</span>\n            <span class=\"n\">Console</span><span class=\"p\">.</span><span class=\"nf\">WriteLine</span><span class=\"p\">(</span><span class=\"n\">tuple</span><span class=\"p\">);</span>\n        <span class=\"p\">}</span>\n\n        <span class=\"c1\">// メソッド定義した場合: </span>\n        <span class=\"kt\">var</span> <span class=\"n\">tuples2</span> <span class=\"p\">=</span> <span class=\"nf\">product</span><span class=\"p\">(</span><span class=\"n\">strs</span><span class=\"p\">,</span> <span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">str</span><span class=\"p\">,</span> <span class=\"n\">num</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"k\">new</span> <span class=\"n\">Tuple</span><span class=\"p\">&lt;</span><span class=\"kt\">string</span><span class=\"p\">,</span> <span class=\"kt\">int</span><span class=\"p\">&gt;(</span><span class=\"n\">str</span><span class=\"p\">,</span> <span class=\"n\">num</span><span class=\"p\">));</span>\n        <span class=\"k\">foreach</span> <span class=\"p\">(</span><span class=\"kt\">var</span> <span class=\"n\">tuple</span> <span class=\"k\">in</span> <span class=\"n\">tuples2</span><span class=\"p\">)</span>\n        <span class=\"p\">{</span>\n            <span class=\"n\">Console</span><span class=\"p\">.</span><span class=\"nf\">WriteLine</span><span class=\"p\">(</span><span class=\"n\">tuple</span><span class=\"p\">);</span>\n        <span class=\"p\">}</span>\n\n        <span class=\"c1\">// 引数が3つの場合:</span>\n        <span class=\"kt\">var</span> <span class=\"n\">xs</span> <span class=\"p\">=</span> <span class=\"k\">new</span> <span class=\"n\">List</span><span class=\"p\">&lt;</span><span class=\"kt\">int</span><span class=\"p\">&gt;()</span> <span class=\"p\">{</span> <span class=\"m\">1</span><span class=\"p\">,</span> <span class=\"m\">2</span><span class=\"p\">,</span> <span class=\"m\">3</span> <span class=\"p\">};</span>\n        <span class=\"kt\">var</span> <span class=\"n\">ys</span> <span class=\"p\">=</span> <span class=\"k\">new</span> <span class=\"n\">List</span><span class=\"p\">&lt;</span><span class=\"kt\">int</span><span class=\"p\">&gt;()</span> <span class=\"p\">{</span> <span class=\"m\">1</span><span class=\"p\">,</span> <span class=\"m\">2</span><span class=\"p\">,</span> <span class=\"m\">3</span> <span class=\"p\">};</span>\n        <span class=\"kt\">var</span> <span class=\"n\">zs</span> <span class=\"p\">=</span> <span class=\"k\">new</span> <span class=\"n\">List</span><span class=\"p\">&lt;</span><span class=\"kt\">int</span><span class=\"p\">&gt;()</span> <span class=\"p\">{</span> <span class=\"m\">1</span><span class=\"p\">,</span> <span class=\"m\">2</span><span class=\"p\">,</span> <span class=\"m\">3</span> <span class=\"p\">};</span>\n        <span class=\"kt\">var</span> <span class=\"n\">tuples3</span> <span class=\"p\">=</span> <span class=\"nf\">product</span><span class=\"p\">(</span><span class=\"n\">xs</span><span class=\"p\">,</span> <span class=\"n\">ys</span><span class=\"p\">,</span> <span class=\"n\">zs</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">z</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">(</span><span class=\"k\">new</span> <span class=\"n\">Tuple</span><span class=\"p\">&lt;</span><span class=\"kt\">int</span><span class=\"p\">,</span> <span class=\"kt\">int</span><span class=\"p\">,</span> <span class=\"kt\">int</span><span class=\"p\">&gt;(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">z</span><span class=\"p\">)));</span>\n        <span class=\"k\">foreach</span> <span class=\"p\">(</span><span class=\"kt\">var</span> <span class=\"n\">tuple</span> <span class=\"k\">in</span> <span class=\"n\">tuples3</span><span class=\"p\">)</span>\n        <span class=\"p\">{</span>\n            <span class=\"n\">Console</span><span class=\"p\">.</span><span class=\"nf\">WriteLine</span><span class=\"p\">(</span><span class=\"n\">tuple</span><span class=\"p\">);</span>\n        <span class=\"p\">}</span>\n\n        <span class=\"c1\">// ===&gt; \"べた\"に書く場合 &lt;===</span>\n        <span class=\"c1\">// (a, 1)</span>\n        <span class=\"c1\">// (a, 2)</span>\n        <span class=\"c1\">// (a, 3)</span>\n        <span class=\"c1\">// (b, 1)</span>\n        <span class=\"c1\">// (b, 2)</span>\n        <span class=\"c1\">// (b, 3)</span>\n        <span class=\"c1\">// (c, 1)</span>\n        <span class=\"c1\">// (c, 2)</span>\n        <span class=\"c1\">// (c, 3)</span>\n\n        <span class=\"c1\">// ===&gt; メソッド定義した場合 &lt;===</span>\n        <span class=\"c1\">// (a, 1)</span>\n        <span class=\"c1\">// (a, 2)</span>\n        <span class=\"c1\">// (a, 3)</span>\n        <span class=\"c1\">// (b, 1)</span>\n        <span class=\"c1\">// (b, 2)</span>\n        <span class=\"c1\">// (b, 3)</span>\n        <span class=\"c1\">// (c, 1)</span>\n        <span class=\"c1\">// (c, 2)</span>\n        <span class=\"c1\">// (c, 3)</span>\n\n        <span class=\"c1\">// ===&gt; 引数が3つの場合 &lt;===</span>\n        <span class=\"c1\">// (1, 1, 1)</span>\n        <span class=\"c1\">// (1, 1, 2)</span>\n        <span class=\"c1\">// (1, 1, 3)</span>\n        <span class=\"c1\">// (1, 2, 1)</span>\n        <span class=\"c1\">// (1, 2, 2)</span>\n        <span class=\"c1\">// (1, 2, 3)</span>\n        <span class=\"c1\">// (1, 3, 1)</span>\n        <span class=\"c1\">// (1, 3, 2)</span>\n        <span class=\"c1\">// (1, 3, 3)</span>\n        <span class=\"c1\">// (2, 1, 1)</span>\n        <span class=\"c1\">// (2, 1, 2)</span>\n        <span class=\"c1\">// (2, 1, 3)</span>\n        <span class=\"c1\">// (2, 2, 1)</span>\n        <span class=\"c1\">// (2, 2, 2)</span>\n        <span class=\"c1\">// (2, 2, 3)</span>\n        <span class=\"c1\">// (2, 3, 1)</span>\n        <span class=\"c1\">// (2, 3, 2)</span>\n        <span class=\"c1\">// (2, 3, 3)</span>\n        <span class=\"c1\">// (3, 1, 1)</span>\n        <span class=\"c1\">// (3, 1, 2)</span>\n        <span class=\"c1\">// (3, 1, 3)</span>\n        <span class=\"c1\">// (3, 2, 1)</span>\n        <span class=\"c1\">// (3, 2, 2)</span>\n        <span class=\"c1\">// (3, 2, 3)</span>\n        <span class=\"c1\">// (3, 3, 1)</span>\n        <span class=\"c1\">// (3, 3, 2)</span>\n        <span class=\"c1\">// (3, 3, 3)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>ちなみに<code>SelectMany</code>という名前、あまり耳慣れない類ですが、ほかのプログラミング言語でいうところの<code>flattenmap</code>や<code>flatmap</code>と同じものになります。個人的には<code>SelectMany</code>という名前は直観に反すると思うのですが、好みですかね(´・ω・｀)</p>\n\n<hr>\n\n<p>とここまで書いたあと、ふと<code>yield return</code>という遅延評価を実現する構文があることを思い出しました(´・ω・｀)　これを利用するとよりシンプルかつ分かりやすい形でデカルト積が実現できてしまいます。まあ好みの問題ですね……。</p>\n\n<div class=\"code-frame\" data-lang=\"csharp\"><div class=\"highlight\"><pre><code><span class=\"k\">using</span> <span class=\"nn\">System</span><span class=\"p\">;</span>\n<span class=\"k\">using</span> <span class=\"nn\">System.Collections.Generic</span><span class=\"p\">;</span>\n\n<span class=\"k\">public</span> <span class=\"k\">class</span> <span class=\"nc\">Program</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">public</span> <span class=\"k\">static</span> <span class=\"n\">IEnumerable</span><span class=\"p\">&lt;</span><span class=\"n\">TResult</span><span class=\"p\">&gt;</span> <span class=\"n\">product</span><span class=\"p\">&lt;</span><span class=\"n\">T1</span><span class=\"p\">,</span> <span class=\"n\">T2</span><span class=\"p\">,</span> <span class=\"n\">TResult</span><span class=\"p\">&gt;(</span><span class=\"n\">IEnumerable</span><span class=\"p\">&lt;</span><span class=\"n\">T1</span><span class=\"p\">&gt;</span> <span class=\"n\">ts1</span><span class=\"p\">,</span> <span class=\"n\">IEnumerable</span><span class=\"p\">&lt;</span><span class=\"n\">T2</span><span class=\"p\">&gt;</span> <span class=\"n\">ts2</span><span class=\"p\">,</span> <span class=\"n\">Func</span><span class=\"p\">&lt;</span><span class=\"n\">T1</span><span class=\"p\">,</span> <span class=\"n\">T2</span><span class=\"p\">,</span> <span class=\"n\">TResult</span><span class=\"p\">&gt;</span> <span class=\"n\">func</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">foreach</span> <span class=\"p\">(</span><span class=\"kt\">var</span> <span class=\"n\">t1</span> <span class=\"k\">in</span> <span class=\"n\">ts1</span><span class=\"p\">)</span>\n        <span class=\"p\">{</span>\n            <span class=\"k\">foreach</span> <span class=\"p\">(</span><span class=\"kt\">var</span> <span class=\"n\">t2</span> <span class=\"k\">in</span> <span class=\"n\">ts2</span><span class=\"p\">)</span>\n            <span class=\"p\">{</span>\n                <span class=\"k\">yield</span> <span class=\"k\">return</span> <span class=\"nf\">func</span><span class=\"p\">(</span><span class=\"n\">t1</span><span class=\"p\">,</span> <span class=\"n\">t2</span><span class=\"p\">);</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">public</span> <span class=\"k\">static</span> <span class=\"n\">IEnumerable</span><span class=\"p\">&lt;</span><span class=\"n\">TResult</span><span class=\"p\">&gt;</span> <span class=\"n\">product</span><span class=\"p\">&lt;</span><span class=\"n\">T1</span><span class=\"p\">,</span> <span class=\"n\">T2</span><span class=\"p\">,</span> <span class=\"n\">T3</span><span class=\"p\">,</span> <span class=\"n\">TResult</span><span class=\"p\">&gt;(</span><span class=\"n\">IEnumerable</span><span class=\"p\">&lt;</span><span class=\"n\">T1</span><span class=\"p\">&gt;</span> <span class=\"n\">ts1</span><span class=\"p\">,</span> <span class=\"n\">IEnumerable</span><span class=\"p\">&lt;</span><span class=\"n\">T2</span><span class=\"p\">&gt;</span> <span class=\"n\">ts2</span><span class=\"p\">,</span> <span class=\"n\">IEnumerable</span><span class=\"p\">&lt;</span><span class=\"n\">T3</span><span class=\"p\">&gt;</span> <span class=\"n\">ts3</span><span class=\"p\">,</span> <span class=\"n\">Func</span><span class=\"p\">&lt;</span><span class=\"n\">T1</span><span class=\"p\">,</span> <span class=\"n\">T2</span><span class=\"p\">,</span> <span class=\"n\">T3</span><span class=\"p\">,</span> <span class=\"n\">TResult</span><span class=\"p\">&gt;</span> <span class=\"n\">func</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">foreach</span> <span class=\"p\">(</span><span class=\"kt\">var</span> <span class=\"n\">t1</span> <span class=\"k\">in</span> <span class=\"n\">ts1</span><span class=\"p\">)</span>\n        <span class=\"p\">{</span>\n            <span class=\"k\">foreach</span> <span class=\"p\">(</span><span class=\"kt\">var</span> <span class=\"n\">t2</span> <span class=\"k\">in</span> <span class=\"n\">ts2</span><span class=\"p\">)</span>\n            <span class=\"p\">{</span>\n                <span class=\"k\">foreach</span> <span class=\"p\">(</span><span class=\"kt\">var</span> <span class=\"n\">t3</span> <span class=\"k\">in</span> <span class=\"n\">ts3</span><span class=\"p\">)</span>\n                <span class=\"p\">{</span>\n                    <span class=\"k\">yield</span> <span class=\"k\">return</span> <span class=\"nf\">func</span><span class=\"p\">(</span><span class=\"n\">t1</span><span class=\"p\">,</span> <span class=\"n\">t2</span><span class=\"p\">,</span> <span class=\"n\">t3</span><span class=\"p\">);</span>\n                <span class=\"p\">}</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n","body":"\nPythonには`itertools#product`というデカルト積を簡単に実現できるメソッドが用意されており、個人的には2重ループのネストを減らすために頻繁に利用します。C#では標準ライブラリには用意されていないものの、以下のサンプルに示すように`SelectMany`を利用すれば、これと同様の機能が実現可能です。\n\n```csharp\nusing System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static IEnumerable<TResult> product<T1, T2, TResult>(IEnumerable<T1> ts1, IEnumerable<T2> ts2, Func<T1, T2, TResult> func)\n    {\n         return ts1.SelectMany((t1) => (ts2.Select((t2) => func.Invoke(t1, t2))));\n    }\n\n    public static IEnumerable<TResult> product<T1, T2, T3, TResult>(IEnumerable<T1> ts1, IEnumerable<T2> ts2, IEnumerable<T3> ts3, Func<T1, T2, T3, TResult> func)\n    {\n        return ts1.SelectMany((t1) => product(ts2, ts3, (t2, t3) => func.Invoke(t1, t2, t3)));\n    }\n\n    public static void Main()\n    {\n        var strs = new List<string>() { \"a\", \"b\", \"c\" };\n        var nums = new List<int>() { 1, 2, 3 };\n\n        // \"べた\"に書く場合:\n        var tuples1 = strs.SelectMany((str) => nums.Select((num) => new Tuple<string, int>(str, num)));\n        foreach (var tuple in tuples1)\n        {\n            Console.WriteLine(tuple);\n        }\n\n        // メソッド定義した場合: \n        var tuples2 = product(strs, nums, (str, num) => new Tuple<string, int>(str, num));\n        foreach (var tuple in tuples2)\n        {\n            Console.WriteLine(tuple);\n        }\n        \n        // 引数が3つの場合:\n        var xs = new List<int>() { 1, 2, 3 };\n        var ys = new List<int>() { 1, 2, 3 };\n        var zs = new List<int>() { 1, 2, 3 };\n        var tuples3 = product(xs, ys, zs, (x, y, z) => (new Tuple<int, int, int>(x, y, z)));\n        foreach (var tuple in tuples3)\n        {\n            Console.WriteLine(tuple);\n        }\n\n        // ===> \"べた\"に書く場合 <===\n        // (a, 1)\n        // (a, 2)\n        // (a, 3)\n        // (b, 1)\n        // (b, 2)\n        // (b, 3)\n        // (c, 1)\n        // (c, 2)\n        // (c, 3)\n        \n        // ===> メソッド定義した場合 <===\n        // (a, 1)\n        // (a, 2)\n        // (a, 3)\n        // (b, 1)\n        // (b, 2)\n        // (b, 3)\n        // (c, 1)\n        // (c, 2)\n        // (c, 3)\n\n        // ===> 引数が3つの場合 <===\n        // (1, 1, 1)\n        // (1, 1, 2)\n        // (1, 1, 3)\n        // (1, 2, 1)\n        // (1, 2, 2)\n        // (1, 2, 3)\n        // (1, 3, 1)\n        // (1, 3, 2)\n        // (1, 3, 3)\n        // (2, 1, 1)\n        // (2, 1, 2)\n        // (2, 1, 3)\n        // (2, 2, 1)\n        // (2, 2, 2)\n        // (2, 2, 3)\n        // (2, 3, 1)\n        // (2, 3, 2)\n        // (2, 3, 3)\n        // (3, 1, 1)\n        // (3, 1, 2)\n        // (3, 1, 3)\n        // (3, 2, 1)\n        // (3, 2, 2)\n        // (3, 2, 3)\n        // (3, 3, 1)\n        // (3, 3, 2)\n        // (3, 3, 3)\n    }\n}\n```\n\nちなみに`SelectMany`という名前、あまり耳慣れない類ですが、ほかのプログラミング言語でいうところの`flattenmap`や`flatmap`と同じものになります。個人的には`SelectMany`という名前は直観に反すると思うのですが、好みですかね(´・ω・｀)\n\n***\n\nとここまで書いたあと、ふと`yield return`という遅延評価を実現する構文があることを思い出しました(´・ω・｀)　これを利用するとよりシンプルかつ分かりやすい形でデカルト積が実現できてしまいます。まあ好みの問題ですね……。\n\n```csharp\nusing System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static IEnumerable<TResult> product<T1, T2, TResult>(IEnumerable<T1> ts1, IEnumerable<T2> ts2, Func<T1, T2, TResult> func)\n    {\n        foreach (var t1 in ts1)\n        {\n            foreach (var t2 in ts2)\n            {\n                yield return func(t1, t2);\n            }\n        }\n    }\n\n    public static IEnumerable<TResult> product<T1, T2, T3, TResult>(IEnumerable<T1> ts1, IEnumerable<T2> ts2, IEnumerable<T3> ts3, Func<T1, T2, T3, TResult> func)\n    {\n        foreach (var t1 in ts1)\n        {\n            foreach (var t2 in ts2)\n            {\n                foreach (var t3 in ts3)\n                {\n                    yield return func(t1, t2, t3);\n                }\n            }\n        }\n    }\n}\n```\n","coediting":false,"comments_count":2,"created_at":"2017-11-06T23:07:35+09:00","group":null,"id":"a6eb074c19aff769e1f9","likes_count":2,"private":false,"reactions_count":0,"tags":[{"name":"C#","versions":[]}],"title":"LINQでデカルト積を実現したい(Pythonのitertools#productのような機能を実現したい)","updated_at":"2017-11-06T23:08:56+09:00","url":"https://qiita.com/neko_the_shadow/items/a6eb074c19aff769e1f9","user":{"description":"IT業界の片隅でひっそり生きるシステムエンジニアです(´・ω・｀)","facebook_id":"","followees_count":0,"followers_count":35,"github_login_name":null,"id":"neko_the_shadow","items_count":186,"linkedin_id":"","location":"神奈川県川崎市","name":"","organization":"","permanent_id":105859,"profile_image_url":"https://qiita-image-store.s3.amazonaws.com/0/105859/profile-images/1473709753","team_only":false,"twitter_screen_name":"neko_the_shadow","website_url":"https://nekotheshadow.github.io/"},"page_views_count":null,"team_membership":null}