{"rendered_body":"<p>突然ですが次のコードは例外をスローします。なぜでしょうか?</p>\n\n<div class=\"code-frame\" data-lang=\"py\"><div class=\"highlight\"><pre><span class=\"kn\">import</span> <span class=\"nn\">collections</span>\n\n<span class=\"n\">ht</span> <span class=\"o\">=</span> <span class=\"n\">collections</span><span class=\"p\">.</span><span class=\"n\">defaultdict</span><span class=\"p\">(</span><span class=\"nb\">int</span><span class=\"p\">)</span>\n<span class=\"n\">ht</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">ht</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n<span class=\"k\">for</span> <span class=\"n\">ky</span> <span class=\"ow\">in</span> <span class=\"n\">ht</span><span class=\"p\">:</span>\n    <span class=\"k\">if</span> <span class=\"n\">ht</span><span class=\"p\">[</span><span class=\"n\">ky</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span> <span class=\"n\">do_something</span><span class=\"p\">()</span>\n\n<span class=\"c1\">#=&gt; RuntimeError: dictionary changed size during iteration\n</span></pre></div></div>\n\n<p>Python3ではループ中に対象の辞書のサイズが変化すると<code>RuntimeError</code>を投げます。<code>collections.defaultdict</code>も同じで、上記の例では<code>ky = 1</code>のとき<code>ht[2]</code>という未定義領域にアクセスした結果、<code>ht[2] = 0</code>と定義されてしまいます。そのためループ中に辞書のサイズが変化したとして例外になるのです。</p>\n\n<p><code>collections.defaultdict</code>は未定義領域に問答無用でアクセスできるという点でとても便利ですが、だからといって<strong>「とあるkeyのvalueがすでに定義されているかどうか」のチェックに際して、「とりあえずそのkeyでアクセスしてみて、帰ってきた値がデフォルト値だったら結果的に未定義だったとわかる」という方法は推奨できません</strong>_。上記の例がその典型といえるでしょう。ややまどろっこしくとも<code>if ky in ht</code>のように、きちんと存在チェックを行いましょう。</p>\n\n<p>ちなみにRubyの<code>Hash</code>の場合はどうでしょう? 実は次の例ではエラーにはなりません。</p>\n\n<div class=\"code-frame\" data-lang=\"rb\"><div class=\"highlight\"><pre><span class=\"nb\">hash</span> <span class=\"o\">=</span> <span class=\"no\">Hash</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"nb\">hash</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">hash</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"nb\">hash</span><span class=\"p\">.</span><span class=\"nf\">each</span><span class=\"p\">{</span><span class=\"o\">|</span><span class=\"n\">ky</span><span class=\"p\">,</span> <span class=\"n\">val</span><span class=\"o\">|</span> <span class=\"nb\">p</span> <span class=\"nb\">hash</span><span class=\"p\">[</span><span class=\"n\">ky</span> <span class=\"o\">+</span> <span class=\"mi\">100</span><span class=\"p\">]</span> <span class=\"k\">if</span> <span class=\"nb\">hash</span><span class=\"p\">[</span><span class=\"n\">ky</span> <span class=\"o\">+</span> <span class=\"mi\">100</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">}</span>\n\n<span class=\"c1\">#=&gt; 0 0</span>\n</pre></div></div>\n\n<p>Rubyの場合<code>Hash</code>の未定義領域にアクセスすると、規定されたデフォルト値を返しますが、<strong><em>明示的な代入行為が行われない限りは定義されたとみなされず、したがって<code>Hash</code>のサイズは変動しません。</em></strong>未定義領域にアクセスした瞬間にkeyに対するvalueをデフォルト値で定義してしまうPython3の<code>collections.defaultdict</code>とは性質がかなり異なります。</p>\n\n<p>なおループ中に<code>Hash</code>のサイズが変動するとエラーになるのはRubyも同じです。残念(´・ω・`)</p>\n\n<div class=\"code-frame\" data-lang=\"rb\"><div class=\"highlight\"><pre><span class=\"nb\">hash</span> <span class=\"o\">=</span> <span class=\"no\">Hash</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"nb\">hash</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">hash</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"nb\">hash</span><span class=\"p\">.</span><span class=\"nf\">each</span><span class=\"p\">{</span><span class=\"o\">|</span><span class=\"n\">ky</span><span class=\"p\">,</span> <span class=\"n\">val</span><span class=\"o\">|</span> <span class=\"nb\">hash</span><span class=\"p\">[</span><span class=\"n\">ky</span> <span class=\"o\">+</span> <span class=\"mi\">100</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span> <span class=\"k\">if</span> <span class=\"nb\">hash</span><span class=\"p\">[</span><span class=\"n\">ky</span> <span class=\"o\">+</span> <span class=\"mi\">100</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">}</span>\n\n<span class=\"c1\">#=&gt; can't add a new key into hash during iteration (RuntimeError)</span>\n</pre></div></div>\n","body":"突然ですが次のコードは例外をスローします。なぜでしょうか?\n\n```py\nimport collections\n\nht = collections.defaultdict(int)\nht[0] = ht[1] = 1\nx = 2\nfor ky in ht:\n    if ht[ky + 1] == 0: do_something()\n    \n#=> RuntimeError: dictionary changed size during iteration\n```\n\nPython3ではループ中に対象の辞書のサイズが変化すると`RuntimeError`を投げます。`collections.defaultdict`も同じで、上記の例では`ky = 1`のとき`ht[2]`という未定義領域にアクセスした結果、`ht[2] = 0`と定義されてしまいます。そのためループ中に辞書のサイズが変化したとして例外になるのです。\n\n`collections.defaultdict`は未定義領域に問答無用でアクセスできるという点でとても便利ですが、だからといって__「とあるkeyのvalueがすでに定義されているかどうか」のチェックに際して、「とりあえずそのkeyでアクセスしてみて、帰ってきた値がデフォルト値だったら結果的に未定義だったとわかる」という方法は推奨できません___。上記の例がその典型といえるでしょう。ややまどろっこしくとも`if ky in ht`のように、きちんと存在チェックを行いましょう。\n\nちなみにRubyの`Hash`の場合はどうでしょう? 実は次の例ではエラーにはなりません。\n\n```rb\nhash = Hash.new(0)\nhash[0] = hash[1] = 1\nhash.each{|ky, val| p hash[ky + 100] if hash[ky + 100] == 0}\n\n#=> 0 0\n```\n\nRubyの場合`Hash`の未定義領域にアクセスすると、規定されたデフォルト値を返しますが、___明示的な代入行為が行われない限りは定義されたとみなされず、したがって`Hash`のサイズは変動しません。___未定義領域にアクセスした瞬間にkeyに対するvalueをデフォルト値で定義してしまうPython3の`collections.defaultdict`とは性質がかなり異なります。\n\nなおループ中に`Hash`のサイズが変動するとエラーになるのはRubyも同じです。残念(´・ω・`)\n\n```rb\nhash = Hash.new(0)\nhash[0] = hash[1] = 1\nhash.each{|ky, val| hash[ky + 100] += 1 if hash[ky + 100] == 0}\n\n#=> can't add a new key into hash during iteration (RuntimeError)\n```\n\n","coediting":false,"comments_count":0,"created_at":"2016-12-13T00:10:54+09:00","group":null,"id":"2d9ab4d77d0d56e5a9a7","likes_count":1,"private":false,"reactions_count":0,"tags":[{"name":"Ruby","versions":[]},{"name":"Python","versions":[]},{"name":"Python3","versions":[]}],"title":"ループ中にdefaultdictの未定義領域にアクセスすると例外","updated_at":"2016-12-13T00:12:55+09:00","url":"https://qiita.com/neko_the_shadow/items/2d9ab4d77d0d56e5a9a7","user":{"description":"IT業界の片隅でひっそり生きるシステムエンジニアです(´・ω・｀)","facebook_id":"","followees_count":0,"followers_count":33,"github_login_name":null,"id":"neko_the_shadow","items_count":171,"linkedin_id":"","location":"神奈川県川崎市","name":"","organization":"","permanent_id":105859,"profile_image_url":"https://qiita-image-store.s3.amazonaws.com/0/105859/profile-images/1473709753","team_only":false,"twitter_screen_name":"neko_the_shadow","website_url":"https://nekotheshadow.github.io/"},"page_views_count":null}