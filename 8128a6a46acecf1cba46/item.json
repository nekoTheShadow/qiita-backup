{"rendered_body":"<p>再帰の最大回数を確認したい場合は<code>sys.getrecursionlimit</code>、設定したい場合は<code>sys.setrecursionlimit</code>をそれぞれ利用します。なお2つのメソッドのドキュメントはそれぞれ次の通りです。</p>\n\n<ul>\n<li>\n<code>sys.getrecursionlimit</code>: <a href=\"https://docs.python.org/ja/3/library/sys.html#sys.getrecursionlimit\" class=\"autolink\" rel=\"nofollow noopener\" target=\"_blank\">https://docs.python.org/ja/3/library/sys.html#sys.getrecursionlimit</a>\n</li>\n<li>\n<code>sys.setrecursionlimit</code>: <a href=\"https://docs.python.org/ja/3/library/sys.html#sys.setrecursionlimit\" class=\"autolink\" rel=\"nofollow noopener\" target=\"_blank\">https://docs.python.org/ja/3/library/sys.html#sys.setrecursionlimit</a>\n</li>\n</ul>\n\n<p>実際的なアプリケーション開発において、再帰が必要になることは少ないと思いますが、たとえば競技プログラミングでは再帰関数を実装する機会が多々あります。そのような場合に<code>sys.setrecursionlimit</code>を覚えておくと、とても便利です。というのは、再帰の最大回数を増やしてやるだけで、ACするケースが意外にあるからです(個人的な体感)。逆に言うと、再帰の回数がデフォルト値だと少なすぎ、そのせいでRuntime Error (RE; Stack Over Flow)になっているケースが少なからず存在するということです。</p>\n\n<p>では簡単に実験してみましょう。なおPythonのバージョンは<code>3.7.2</code>になります。</p>\n\n<p><code>fib</code>は再帰を用いてフィボナッチ数列を求める関数です。<code>sys.setrecursionlimit</code>により再帰の最大回数を変えることで、<code>fib</code>がStack Over Flowになったり、正しく数値を求めることができたりする様子が確認できます。</p>\n\n<div class=\"code-frame\" data-lang=\"python\"><div class=\"highlight\"><pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">sys</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">fib</span> <span class=\"o\">=</span> <span class=\"k\">lambda</span> <span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"mi\">1</span> <span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"o\">&lt;</span> <span class=\"mi\">2</span> <span class=\"k\">else</span> <span class=\"n\">fib</span><span class=\"p\">(</span><span class=\"n\">n</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">fib</span><span class=\"p\">(</span><span class=\"n\">n</span> <span class=\"o\">-</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span>\n<span class=\"o\">&gt;&gt;&gt;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">sys</span><span class=\"p\">.</span><span class=\"n\">setrecursionlimit</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">sys</span><span class=\"p\">.</span><span class=\"n\">getrecursionlimit</span><span class=\"p\">()</span>\n<span class=\"mi\">10</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">fib</span><span class=\"p\">(</span><span class=\"mi\">20</span><span class=\"p\">)</span>\n<span class=\"n\">Traceback</span> <span class=\"p\">(</span><span class=\"n\">most</span> <span class=\"n\">recent</span> <span class=\"n\">call</span> <span class=\"n\">last</span><span class=\"p\">):</span>\n  <span class=\"n\">File</span> <span class=\"s\">\"&lt;stdin&gt;\"</span><span class=\"p\">,</span> <span class=\"n\">line</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"ow\">in</span> <span class=\"o\">&lt;</span><span class=\"n\">module</span><span class=\"o\">&gt;</span>\n  <span class=\"n\">File</span> <span class=\"s\">\"&lt;stdin&gt;\"</span><span class=\"p\">,</span> <span class=\"n\">line</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"ow\">in</span> <span class=\"o\">&lt;</span><span class=\"k\">lambda</span><span class=\"o\">&gt;</span>\n  <span class=\"n\">File</span> <span class=\"s\">\"&lt;stdin&gt;\"</span><span class=\"p\">,</span> <span class=\"n\">line</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"ow\">in</span> <span class=\"o\">&lt;</span><span class=\"k\">lambda</span><span class=\"o\">&gt;</span>\n  <span class=\"n\">File</span> <span class=\"s\">\"&lt;stdin&gt;\"</span><span class=\"p\">,</span> <span class=\"n\">line</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"ow\">in</span> <span class=\"o\">&lt;</span><span class=\"k\">lambda</span><span class=\"o\">&gt;</span>\n  <span class=\"p\">[</span><span class=\"n\">Previous</span> <span class=\"n\">line</span> <span class=\"n\">repeated</span> <span class=\"mi\">6</span> <span class=\"n\">more</span> <span class=\"n\">times</span><span class=\"p\">]</span>\n<span class=\"nb\">RecursionError</span><span class=\"p\">:</span> <span class=\"n\">maximum</span> <span class=\"n\">recursion</span> <span class=\"n\">depth</span> <span class=\"n\">exceeded</span> <span class=\"ow\">in</span> <span class=\"n\">comparison</span>\n<span class=\"o\">&gt;&gt;&gt;</span>\n<span class=\"o\">&gt;&gt;&gt;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">sys</span><span class=\"p\">.</span><span class=\"n\">setrecursionlimit</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">sys</span><span class=\"p\">.</span><span class=\"n\">getrecursionlimit</span><span class=\"p\">()</span>\n<span class=\"mi\">100</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">fib</span><span class=\"p\">(</span><span class=\"mi\">20</span><span class=\"p\">)</span>\n<span class=\"mi\">10946</span>\n</pre></div></div>\n","body":"再帰の最大回数を確認したい場合は`sys.getrecursionlimit`、設定したい場合は`sys.setrecursionlimit`をそれぞれ利用します。なお2つのメソッドのドキュメントはそれぞれ次の通りです。\n\n- `sys.getrecursionlimit`: https://docs.python.org/ja/3/library/sys.html#sys.getrecursionlimit\n- `sys.setrecursionlimit`: https://docs.python.org/ja/3/library/sys.html#sys.setrecursionlimit\n\n実際的なアプリケーション開発において、再帰が必要になることは少ないと思いますが、たとえば競技プログラミングでは再帰関数を実装する機会が多々あります。そのような場合に`sys.setrecursionlimit`を覚えておくと、とても便利です。というのは、再帰の最大回数を増やしてやるだけで、ACするケースが意外にあるからです(個人的な体感)。逆に言うと、再帰の回数がデフォルト値だと少なすぎ、そのせいでRuntime Error (RE; Stack Over Flow)になっているケースが少なからず存在するということです。\n\nでは簡単に実験してみましょう。なおPythonのバージョンは`3.7.2`になります。\n\n`fib`は再帰を用いてフィボナッチ数列を求める関数です。`sys.setrecursionlimit`により再帰の最大回数を変えることで、`fib`がStack Over Flowになったり、正しく数値を求めることができたりする様子が確認できます。\n\n```python\n>>> import sys\n>>> fib = lambda n: 1 if n < 2 else fib(n - 1) + fib(n - 2)\n>>>\n>>>\n>>> sys.setrecursionlimit(10)\n>>> sys.getrecursionlimit()\n10\n>>> fib(20)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"<stdin>\", line 1, in <lambda>\n  File \"<stdin>\", line 1, in <lambda>\n  File \"<stdin>\", line 1, in <lambda>\n  [Previous line repeated 6 more times]\nRecursionError: maximum recursion depth exceeded in comparison\n>>>\n>>>\n>>> sys.setrecursionlimit(100)\n>>> sys.getrecursionlimit()\n100\n>>> fib(20)\n10946\n```\n","coediting":false,"comments_count":0,"created_at":"2019-03-05T23:20:50+09:00","group":null,"id":"8128a6a46acecf1cba46","likes_count":0,"private":false,"reactions_count":0,"tags":[{"name":"Python3","versions":[]}],"title":"再帰の最大回数を確認する/設定する","updated_at":"2019-03-05T23:24:58+09:00","url":"https://qiita.com/neko_the_shadow/items/8128a6a46acecf1cba46","user":{"description":"IT業界の片隅でひっそり生きるシステムエンジニアです(´・ω・｀)","facebook_id":"","followees_count":0,"followers_count":33,"github_login_name":null,"id":"neko_the_shadow","items_count":171,"linkedin_id":"","location":"神奈川県川崎市","name":"","organization":"","permanent_id":105859,"profile_image_url":"https://qiita-image-store.s3.amazonaws.com/0/105859/profile-images/1473709753","team_only":false,"twitter_screen_name":"neko_the_shadow","website_url":"https://nekotheshadow.github.io/"},"page_views_count":null}